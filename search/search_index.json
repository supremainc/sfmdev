{
    "docs": [
        {
            "location": "/",
            "text": "SFM Developer Center\n\u00b6\n\n\nQuick Access\n\u00b6\n\n\nSFM SDK : \nC/C++\n, \n.NET\n, \nAndroid\n, \npython\n\nTutorials : \npysfm\n\n\n\n\nWhat is SFM?\n\u00b6\n\n\nSFM (Suprema Fingerprint Module) is the world's most widely used fingerprint module manufactured by \nSuprema Inc\n. It provides the most powerful fingerprint recognition performance than other competitors. \n\n\nWhat is SFM Developer Center?\n\u00b6\n\n\nSFM Developer Center is an online space that provides technical information and technical communication with customers. In SFM Developer Center, We will open various open source projects using SFM to provide the opportunity to utilize fingerprint recognition technology not only for fingerprint recognition experts but also for those interested in hobbies such as start-up companies or DIY. \n\n\n\n\n\n\n\n\n                  \n Join our Slack\n\n\n\n\n\n\n\nAbout Suprema Inc.\n\n\nSuprema is a leading global provider of biometrics and security technology. By combining world renowned biometric algorithms with superior engineering, Suprema continually designs and develops industry leading products and solutions. Suprema's extensive range of portfolio includes biometric access control systems, time & attendance solutions, fingerprint live scanners, mobile authentication solutions and embedded fingerprint modules. Suprema has worldwide sales network in over 130 countries and is one of the world's Top 50 security company in its turnover (ranked in A&S's Security 50, 2010-2016). For more information, please visit \nwww.supremainc.com",
            "title": "About"
        },
        {
            "location": "/#sfm-developer-center",
            "text": "",
            "title": "SFM Developer Center"
        },
        {
            "location": "/#quick-access",
            "text": "SFM SDK :  C/C++ ,  .NET ,  Android ,  python \nTutorials :  pysfm",
            "title": "Quick Access"
        },
        {
            "location": "/#what-is-sfm",
            "text": "SFM (Suprema Fingerprint Module) is the world's most widely used fingerprint module manufactured by  Suprema Inc . It provides the most powerful fingerprint recognition performance than other competitors.",
            "title": "What is SFM?"
        },
        {
            "location": "/#what-is-sfm-developer-center",
            "text": "SFM Developer Center is an online space that provides technical information and technical communication with customers. In SFM Developer Center, We will open various open source projects using SFM to provide the opportunity to utilize fingerprint recognition technology not only for fingerprint recognition experts but also for those interested in hobbies such as start-up companies or DIY.     \n                    Join our Slack    About Suprema Inc.  Suprema is a leading global provider of biometrics and security technology. By combining world renowned biometric algorithms with superior engineering, Suprema continually designs and develops industry leading products and solutions. Suprema's extensive range of portfolio includes biometric access control systems, time & attendance solutions, fingerprint live scanners, mobile authentication solutions and embedded fingerprint modules. Suprema has worldwide sales network in over 130 countries and is one of the world's Top 50 security company in its turnover (ranked in A&S's Security 50, 2010-2016). For more information, please visit  www.supremainc.com",
            "title": "What is SFM Developer Center?"
        },
        {
            "location": "/products/SFMSlim/",
            "text": "SFM Slim\n\u00b6\n\n\nSFM Slim is the slimmest FAP20-certified optical fingerprint module featuring an array of cutting-edge technologies.\nAlong with its 13.5mm-slim optical sensor and Suprema\u2019s Conformance Decision Engine (CDE) technology that captures an optimal fingerprint image for all the finger types, SFM Slim offers you flexibility to create a new and innovative system design with its reduced form factor at a whole new level of performance that will distinguish you from your competitors.\nPowered by a state-of-the-art 1GHz CPU, MINEX-certified algorithm and 256-bit AES fingerprint data encryption, SFM Slim also features best-in-class performance (5,000 match/ sec) and FBI PIV-compliance with the highest level security.\n\n\n\n\n\n\n\n\n\nFeatures\n\u00b6\n\n\n\n\nWorld\u2019s Slimmest 13.5 mm FAP 20-certified Optical Fingerprint Module\n\n\n\n\nUltra performance with 1.0GHz CPU\n\n\n\n\n5,000 templates matching per second\n\n\n\n\n\n\n\n\nClass-leading User Capacity\n\n\n\n\nStore Max 22,000 templates (in One Template Mode)\n\n\n\n\n\n\n\n\nFBI PIV and FBI Mobile ID FAP20 certificates\n\n\n\n\nNIST certified interoperable image & template format standards (ANSI-378, ISO19794-2)\n\n\nImage compression standard: WSQ\n\n\n\n\n\n\n\n\nLive Fingerprint Detection (LFD) Technology\n\n\n\n\nDistinguish fake fingerprints made from various materials including clay, rubber, silicon, glue, paper, film and more\n\n\n\n\n\n\n\n\nAdvanced Data Protection\n\n\n\n\n256-bit AES Fingerprint Data Encryption of fingerprint templates\n\n\nProtect template data with Secure IC\n\n\n\n\n\n\n\n\nEasy Integration\n\n\n\n\nSFM SDK for easy application development\n\n\nAndroid, Windows & Linux compatible\n\n\n\n\n\n\n\n\nSmart Sensor Control by Conformance Decision Engine(CDE)\n\n\n\n\nOptimize the fingerprint sensor and algorithm\n\n\nProvide a fast feedback when the fingerprint is input incorrectly\n\n\n\n\n\n\n\n\n\n\nInfo\n\n\nClick here to get detailed information of SFMSlim.\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFMSlim\n\n\n\n\nFirmware\n\u00b6\n\n\n\n\nDownload link\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM Slim Series"
        },
        {
            "location": "/products/SFMSlim/#sfm-slim",
            "text": "SFM Slim is the slimmest FAP20-certified optical fingerprint module featuring an array of cutting-edge technologies.\nAlong with its 13.5mm-slim optical sensor and Suprema\u2019s Conformance Decision Engine (CDE) technology that captures an optimal fingerprint image for all the finger types, SFM Slim offers you flexibility to create a new and innovative system design with its reduced form factor at a whole new level of performance that will distinguish you from your competitors.\nPowered by a state-of-the-art 1GHz CPU, MINEX-certified algorithm and 256-bit AES fingerprint data encryption, SFM Slim also features best-in-class performance (5,000 match/ sec) and FBI PIV-compliance with the highest level security.",
            "title": "SFM Slim"
        },
        {
            "location": "/products/SFMSlim/#features",
            "text": "World\u2019s Slimmest 13.5 mm FAP 20-certified Optical Fingerprint Module   Ultra performance with 1.0GHz CPU   5,000 templates matching per second     Class-leading User Capacity   Store Max 22,000 templates (in One Template Mode)     FBI PIV and FBI Mobile ID FAP20 certificates   NIST certified interoperable image & template format standards (ANSI-378, ISO19794-2)  Image compression standard: WSQ     Live Fingerprint Detection (LFD) Technology   Distinguish fake fingerprints made from various materials including clay, rubber, silicon, glue, paper, film and more     Advanced Data Protection   256-bit AES Fingerprint Data Encryption of fingerprint templates  Protect template data with Secure IC     Easy Integration   SFM SDK for easy application development  Android, Windows & Linux compatible     Smart Sensor Control by Conformance Decision Engine(CDE)   Optimize the fingerprint sensor and algorithm  Provide a fast feedback when the fingerprint is input incorrectly      Info  Click here to get detailed information of SFMSlim.",
            "title": "Features"
        },
        {
            "location": "/products/SFMSlim/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFMSlim/#datasheets",
            "text": "SFMSlim",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFMSlim/#firmware",
            "text": "Download link",
            "title": "Firmware"
        },
        {
            "location": "/products/SFMSlim/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFMSlim/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM6000/",
            "text": "SFM6000 Series\n\u00b6\n\n\nSFM6000 Series represents a great leap forward in biometrics.\nIt boasts a powerful 1.0GHz CPU that empowers the worlds\u2019\nfastest authentication and supports multiple interfaces\nincluding RS232 and USB2.0 that allow high-speed data\ntransfer. With enlarged template capacity up to 25,000\ntemplates, SFM6000 Series is the perfect solution for\na large-scaled yet fast authentication\n\n\nFeatures\n\u00b6\n\n\n\n\nPowerful 1.0GHz CPU\n\n\n1:1 verification in 330ms\n\n\nFast Power-on Time\n\n\n8 configurable Digital I/O Ports\n\n\n1:1,000 Identification in 400ms\n\n\nSuprema, ISO 19794-2, ANSI 378 Template Options\n\n\nAndroid SDK\n\n\nWSQ Image Compression Algorithm certified by FBI\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n8MB and 16MB Flash Memory Option\n\n\nRS232, USB2.0 Host Communication\n\n\n\n\n\n\nInfo\n\n\nClick here to get detailed information of SFM6000 series.\n\n\n\n\nStandard pin assignment\n\u00b6\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM6020-OP\n\n\nSFM6030-OC\n\n\nSFM6050-T\n\n\n\n\nFirmware\n\u00b6\n\n\n\n\nDownload link\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM6000 Series"
        },
        {
            "location": "/products/SFM6000/#sfm6000-series",
            "text": "SFM6000 Series represents a great leap forward in biometrics.\nIt boasts a powerful 1.0GHz CPU that empowers the worlds\u2019\nfastest authentication and supports multiple interfaces\nincluding RS232 and USB2.0 that allow high-speed data\ntransfer. With enlarged template capacity up to 25,000\ntemplates, SFM6000 Series is the perfect solution for\na large-scaled yet fast authentication",
            "title": "SFM6000 Series"
        },
        {
            "location": "/products/SFM6000/#features",
            "text": "Powerful 1.0GHz CPU  1:1 verification in 330ms  Fast Power-on Time  8 configurable Digital I/O Ports  1:1,000 Identification in 400ms  Suprema, ISO 19794-2, ANSI 378 Template Options  Android SDK  WSQ Image Compression Algorithm certified by FBI  256-bit AES Fingerprint Data Encryption  8MB and 16MB Flash Memory Option  RS232, USB2.0 Host Communication    Info  Click here to get detailed information of SFM6000 series.",
            "title": "Features"
        },
        {
            "location": "/products/SFM6000/#standard-pin-assignment",
            "text": "",
            "title": "Standard pin assignment"
        },
        {
            "location": "/products/SFM6000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM6000/#datasheets",
            "text": "SFM6020-OP  SFM6030-OC  SFM6050-T",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM6000/#firmware",
            "text": "Download link",
            "title": "Firmware"
        },
        {
            "location": "/products/SFM6000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM6000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM5500/",
            "text": "SFM5500 Series\n\u00b6\n\n\nSFM5500 is a high-end standalone fingerprint module\nequipped with versatile external interface including\nRS232, RS422/485, Wiegand, Digital I/O and LED\nControl, readily applicable to access control applications.\nSFM5500 offers comprehensive functionalities and\ninterfaces to be used as a complete standalone fingerprint\naccess reader by itself.\n\n\nFeatures\n\u00b6\n\n\n\n\nPowerful 533MHz DSP\n\n\n1:1 verification in 550ms\n\n\nFast Power-on Time\n\n\nConfigurable Digital I/O and LED Control Ports\n\n\nWiegand Input & Output Ports\n\n\nAuxiliary Communication Ports\n\n\n1:1,000 Identification in 700ms\n\n\nSuprema, ISO 19794-2, ANSI 378 Template Options\n\n\nWSQ Image Compression Algorithm certified by FBI\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n8MB Flash Memory Option\n\n\nRS232, RS422/485 Host Communication\n\n\n\n\n\n\nInfo\n\n\nClick here to get detailed information of SFM5500 series.\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM5520-OP\n\n\nSFM5530-OC\n\n\nSFM5550-TC\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM5500 Series"
        },
        {
            "location": "/products/SFM5500/#sfm5500-series",
            "text": "SFM5500 is a high-end standalone fingerprint module\nequipped with versatile external interface including\nRS232, RS422/485, Wiegand, Digital I/O and LED\nControl, readily applicable to access control applications.\nSFM5500 offers comprehensive functionalities and\ninterfaces to be used as a complete standalone fingerprint\naccess reader by itself.",
            "title": "SFM5500 Series"
        },
        {
            "location": "/products/SFM5500/#features",
            "text": "Powerful 533MHz DSP  1:1 verification in 550ms  Fast Power-on Time  Configurable Digital I/O and LED Control Ports  Wiegand Input & Output Ports  Auxiliary Communication Ports  1:1,000 Identification in 700ms  Suprema, ISO 19794-2, ANSI 378 Template Options  WSQ Image Compression Algorithm certified by FBI  256-bit AES Fingerprint Data Encryption  8MB Flash Memory Option  RS232, RS422/485 Host Communication    Info  Click here to get detailed information of SFM5500 series.",
            "title": "Features"
        },
        {
            "location": "/products/SFM5500/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM5500/#datasheets",
            "text": "SFM5520-OP  SFM5530-OC  SFM5550-TC",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM5500/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM5500/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM5000/",
            "text": "SFM5000 Series\n\u00b6\n\n\nSFM5000 is the latest UniFinger module equipped with\nworld\u2019s leading fingerprint authentication algorithm, which\nranked No. 1 in FVC2004, 2006 and ongoing. The SFM5000\nseries features powerful 533MHz DSP which optimized\nfor performance while minimizing power consumption\n\n\nFeatures\n\u00b6\n\n\n\n\nPowerful 533MHz DSP\n\n\n1:1 verification in 600ms\n\n\nFast Power-on Time\n\n\n8 configurable Digital I/O Ports\n\n\n1:1,000 Identification in 760ms\n\n\nSuprema, ISO 19794-2 and ANSI 378 Template Options\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n4MB Flash Memory Option  \n\n\n\n\n\n\nHybrid Live Finger Detection Technology\n\nSuprema\u2019s LFD technology is based on comparison of dynamic and static image characteristics of the fake fingers to live fingers. By the advanced analysis algorithm to detect the abnormalities in dynamic changing pattern of fingerprint images, and several static features showing liveliness or unnaturalness of fingers, fake fingers are clearly distinguished from the live fingers. This new LFD technology provides efficient and effective solution to protect the fingerprint system from attack via fake fingerprints.\n\n\n\n\n\n\nInfo\n\n\nClick here to get detailed information of SFM5000 series.\n\n\n\n\nStandard pin assignment\n\u00b6\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM5020-OP\n\n\nSFM5030-OC\n\n\nSFM5060-OH\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM5000 Series"
        },
        {
            "location": "/products/SFM5000/#sfm5000-series",
            "text": "SFM5000 is the latest UniFinger module equipped with\nworld\u2019s leading fingerprint authentication algorithm, which\nranked No. 1 in FVC2004, 2006 and ongoing. The SFM5000\nseries features powerful 533MHz DSP which optimized\nfor performance while minimizing power consumption",
            "title": "SFM5000 Series"
        },
        {
            "location": "/products/SFM5000/#features",
            "text": "Powerful 533MHz DSP  1:1 verification in 600ms  Fast Power-on Time  8 configurable Digital I/O Ports  1:1,000 Identification in 760ms  Suprema, ISO 19794-2 and ANSI 378 Template Options  256-bit AES Fingerprint Data Encryption  4MB Flash Memory Option      Hybrid Live Finger Detection Technology \nSuprema\u2019s LFD technology is based on comparison of dynamic and static image characteristics of the fake fingers to live fingers. By the advanced analysis algorithm to detect the abnormalities in dynamic changing pattern of fingerprint images, and several static features showing liveliness or unnaturalness of fingers, fake fingers are clearly distinguished from the live fingers. This new LFD technology provides efficient and effective solution to protect the fingerprint system from attack via fake fingerprints.    Info  Click here to get detailed information of SFM5000 series.",
            "title": "Features"
        },
        {
            "location": "/products/SFM5000/#standard-pin-assignment",
            "text": "",
            "title": "Standard pin assignment"
        },
        {
            "location": "/products/SFM5000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM5000/#datasheets",
            "text": "SFM5020-OP  SFM5030-OC  SFM5060-OH",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM5000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM5000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM4000/",
            "text": "SFM4000 Series\n\u00b6\n\n\nSFM4000 is a compact, power efficient module that is simple\nto integrate with various system applications. The module\noffers flexible supply voltage, integrated power management,\nsmall footprint, and voltage detector functions. SFM4000 is\nspecially designed for lock and safe manufacturers look for\nan inexpensive, reliable biometric solution with extra low\npower-consumption and compact size.\n\n\nFeatures\n\u00b6\n\n\n\n\nIntegrated power control circuit\n\n\nSuprema, ISO 19794-2 and ANSI 378 template options\n\n\nSerial Interface with simple protocol\n\n\n4 configurable Digital I/O ports\n\n\nSingle 3.3 VDC regulated power source\n\n\n256-bit AES fingerprint data encryption\n\n\n\n\n\n\nInfo\n\n\nClick here to get detailed information of SFM4000 series.\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM4020-OP\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM4000 Series"
        },
        {
            "location": "/products/SFM4000/#sfm4000-series",
            "text": "SFM4000 is a compact, power efficient module that is simple\nto integrate with various system applications. The module\noffers flexible supply voltage, integrated power management,\nsmall footprint, and voltage detector functions. SFM4000 is\nspecially designed for lock and safe manufacturers look for\nan inexpensive, reliable biometric solution with extra low\npower-consumption and compact size.",
            "title": "SFM4000 Series"
        },
        {
            "location": "/products/SFM4000/#features",
            "text": "Integrated power control circuit  Suprema, ISO 19794-2 and ANSI 378 template options  Serial Interface with simple protocol  4 configurable Digital I/O ports  Single 3.3 VDC regulated power source  256-bit AES fingerprint data encryption    Info  Click here to get detailed information of SFM4000 series.",
            "title": "Features"
        },
        {
            "location": "/products/SFM4000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM4000/#datasheets",
            "text": "SFM4020-OP",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM4000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM4000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/SFM3000/",
            "text": "SFM3000 Series\n\u00b6\n\n\nCore Features, World Class Technology\n\n\nSFM3000 is a cost effective fingerprint identification module\nequipped with essential part for fingerprint identification\nand template storage. SFM3000 is suitable for most of the\napplications where it processes fingerprint recognition and\nhost controller is used to handle other operations. The\ncommunication between SFM3000 and host controller is\ndone by packet protocol through CMOS level serial interface.\n\n\nFeatures\n\u00b6\n\n\n\n\nHigh Performance 400MHz DSP\n\n\nFast Power-on Time\n\n\nSuprema, ISO19794-2 and ANSI 378 Template Options\n\n\n8 Configurable Digital I/O Ports\n\n\nLow Power Consumption\n\n\n256-bit AES Fingerprint Data Encryption\n\n\n\n\n\n\nInfo\n\n\nClick here to get detailed information of SFM3000 series.\n\n\n\n\nStandard pin assignment\n\u00b6\n\n\n\n\nRelated links\n\u00b6\n\n\nDatasheets\n\u00b6\n\n\n\n\nSFM3050-TC1\n\n\nSFM3050-TC2\n\n\nSFM3050-TC2S\n\n\n\n\nDocuments\n\u00b6\n\n\n\n\nUF Protocol Manual\n\n\n\n\nSoftware\n\u00b6\n\n\n\n\nUnifingerUI",
            "title": "SFM3000 Series"
        },
        {
            "location": "/products/SFM3000/#sfm3000-series",
            "text": "Core Features, World Class Technology  SFM3000 is a cost effective fingerprint identification module\nequipped with essential part for fingerprint identification\nand template storage. SFM3000 is suitable for most of the\napplications where it processes fingerprint recognition and\nhost controller is used to handle other operations. The\ncommunication between SFM3000 and host controller is\ndone by packet protocol through CMOS level serial interface.",
            "title": "SFM3000 Series"
        },
        {
            "location": "/products/SFM3000/#features",
            "text": "High Performance 400MHz DSP  Fast Power-on Time  Suprema, ISO19794-2 and ANSI 378 Template Options  8 Configurable Digital I/O Ports  Low Power Consumption  256-bit AES Fingerprint Data Encryption    Info  Click here to get detailed information of SFM3000 series.",
            "title": "Features"
        },
        {
            "location": "/products/SFM3000/#standard-pin-assignment",
            "text": "",
            "title": "Standard pin assignment"
        },
        {
            "location": "/products/SFM3000/#related-links",
            "text": "",
            "title": "Related links"
        },
        {
            "location": "/products/SFM3000/#datasheets",
            "text": "SFM3050-TC1  SFM3050-TC2  SFM3050-TC2S",
            "title": "Datasheets"
        },
        {
            "location": "/products/SFM3000/#documents",
            "text": "UF Protocol Manual",
            "title": "Documents"
        },
        {
            "location": "/products/SFM3000/#software",
            "text": "UnifingerUI",
            "title": "Software"
        },
        {
            "location": "/products/hardware-privacy-notice/",
            "text": "\u00b6\n\n\nHardware Privacy Notice\n\u00b6\n\n\nThis Hardware Privacy Notice applies to anyone using this product, \u201c[OEM Biometric Modules]\u201d. \nPlease be reminded that WE, Suprema Inc., DO NOT COLLECT ANY DATA stored in or collected through this product. \nYou will be collecting and/or using the data independently of us and thus, you should bear in mind that the following data may be stored in this product. \n\n\n\n\n\n\n\n\nProduct\n\n\nUser ID\n\n\nBiometric Template\n\n\n\n\n\n\n\n\n\n\nOEM Biometric Modules \n (Fingerprint and Face Recognition Modules)\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nYour use of this product may be subject to your company\u2019s policies, if any. We are not responsible for the privacy or security practices that are managed by you and your company and that are not within our control. \nThis HW Privacy Notice may be updated from time to time. We suggest that you review this Notice periodically. In the event of a material change, we will notify you of such changes through contact information that we have prior to the change becoming effective. \n\n\n\n\nHardware Privacy Notice (\ud55c\uad6d\uc5b4)\n\u00b6\n\n\n\ubcf8 Hardware Privacy Notice\ub294 \ubcf8 \uc81c\ud488, \u201c[OEM Biometric Modules]\u201d\uc744 \uc0ac\uc6a9\ud558\ub294 \ubaa8\ub4e0 \uc774\uc5d0\uac8c \uc801\uc6a9\ub429\ub2c8\ub2e4. \n[\uc288\ud504\ub9ac\ub9c8]\ub294 \uadc0\ud558\uc640 \uadc0\ud558\uc758 \uace0\uac1d\uc5d0 \ub300\ud55c \uc5b4\ub5a0\ud55c \uc815\ubcf4\ub3c4 \uc218\uc9d1\ud558\uc9c0 \uc54a\ub294\ub2e4\ub294 \uc810\uc744 \uba85\uc2ec\ud574\uc8fc\uc2dc\uae30 \ubc14\ub78d\ub2c8\ub2e4. \n\uadc0\ud558\ub294 \ub2f9\uc0ac\uc640 \ub3c5\ub9bd\uc801\uc73c\ub85c \uc815\ubcf4\ub97c \uc218\uc9d1 \ubc0f/\ub610\ub294 \uc0ac\uc6a9\ud558\uac8c \ub418\ubbc0\ub85c \uc774 \uc81c\ud488\uc5d0 \uc800\uc7a5\ub420 \uc218 \uc788\ub294 \ub2e4\uc74c \uc815\ubcf4\ub4e4\uc744 \ubc18\ub4dc\uc2dc \ud655\uc778\ud574\uc57c \ud569\ub2c8\ub2e4. \n\n\n\n\n\n\n\n\nProduct\n\n\nUser ID\n\n\nBiometric Template\n\n\n\n\n\n\n\n\n\n\nOEM Biometric Modules \n (Fingerprint and Face Recognition Modules)\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\n\uc774 \uc81c\ud488 \uc0ac\uc6a9\uc5d0\ub294 \uadc0\ud558\uac00 \uc18d\ud55c \ud68c\uc0ac\uc758 \uc815\ucc45\uc774 \uc801\uc6a9\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ub2f9\uc0ac\ub294 \uadc0\ud558\uc640 \uadc0\ud558\uc758 \ud68c\uc0ac\uac00 \uad00\ub9ac\ud558\uace0 \ub2f9\uc0ac\uac00 \ud1b5\uc81c\ud560 \uc218 \uc5c6\ub294 \uac1c\uc778 \uc815\ubcf4\uc758 \ubcf4\ud638\uc5d0 \ub300\ud574 \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \n\ubcf8 Privacy Notice\ub294 \uc218\uc2dc\ub85c \uc5c5\ub370\uc774\ud2b8 \ub420 \uc218 \uc788\uc73c\ubbc0\ub85c \ubcf8 \uace0\uc9c0\ub97c \uc8fc\uae30\uc801\uc73c\ub85c \uc0b4\ud3b4\ubcf4\ub294 \uac83\uc774 \uc88b\uc2b5\ub2c8\ub2e4. \uc911\ub300\ud55c \ubcc0\uacbd \uc0ac\ud56d\uc774 \uc788\ub294 \uacbd\uc6b0 \ubcc0\uacbd \uc0ac\ud56d\uc774 \uc801\uc6a9\ub418\uae30 \uc804\uc5d0 \ub2f9\uc0ac\uac00 \ubcf4\uc720\ud55c \uc5f0\ub77d\ucc98 \uc815\ubcf4\ub97c \uc774\uc6a9\ud558\uc5ec \ubcc0\uacbd \uc0ac\ud56d\uc744 \uc54c\ub824\ub4dc\ub9bd\ub2c8\ub2e4.",
            "title": "Hardware Privacy Notice"
        },
        {
            "location": "/products/hardware-privacy-notice/#hardware-privacy-notice",
            "text": "This Hardware Privacy Notice applies to anyone using this product, \u201c[OEM Biometric Modules]\u201d. \nPlease be reminded that WE, Suprema Inc., DO NOT COLLECT ANY DATA stored in or collected through this product. \nYou will be collecting and/or using the data independently of us and thus, you should bear in mind that the following data may be stored in this product.      Product  User ID  Biometric Template      OEM Biometric Modules   (Fingerprint and Face Recognition Modules)  O  O     Your use of this product may be subject to your company\u2019s policies, if any. We are not responsible for the privacy or security practices that are managed by you and your company and that are not within our control. \nThis HW Privacy Notice may be updated from time to time. We suggest that you review this Notice periodically. In the event of a material change, we will notify you of such changes through contact information that we have prior to the change becoming effective.",
            "title": "Hardware Privacy Notice"
        },
        {
            "location": "/products/hardware-privacy-notice/#hardware-privacy-notice_1",
            "text": "\ubcf8 Hardware Privacy Notice\ub294 \ubcf8 \uc81c\ud488, \u201c[OEM Biometric Modules]\u201d\uc744 \uc0ac\uc6a9\ud558\ub294 \ubaa8\ub4e0 \uc774\uc5d0\uac8c \uc801\uc6a9\ub429\ub2c8\ub2e4. \n[\uc288\ud504\ub9ac\ub9c8]\ub294 \uadc0\ud558\uc640 \uadc0\ud558\uc758 \uace0\uac1d\uc5d0 \ub300\ud55c \uc5b4\ub5a0\ud55c \uc815\ubcf4\ub3c4 \uc218\uc9d1\ud558\uc9c0 \uc54a\ub294\ub2e4\ub294 \uc810\uc744 \uba85\uc2ec\ud574\uc8fc\uc2dc\uae30 \ubc14\ub78d\ub2c8\ub2e4. \n\uadc0\ud558\ub294 \ub2f9\uc0ac\uc640 \ub3c5\ub9bd\uc801\uc73c\ub85c \uc815\ubcf4\ub97c \uc218\uc9d1 \ubc0f/\ub610\ub294 \uc0ac\uc6a9\ud558\uac8c \ub418\ubbc0\ub85c \uc774 \uc81c\ud488\uc5d0 \uc800\uc7a5\ub420 \uc218 \uc788\ub294 \ub2e4\uc74c \uc815\ubcf4\ub4e4\uc744 \ubc18\ub4dc\uc2dc \ud655\uc778\ud574\uc57c \ud569\ub2c8\ub2e4.      Product  User ID  Biometric Template      OEM Biometric Modules   (Fingerprint and Face Recognition Modules)  O  O     \uc774 \uc81c\ud488 \uc0ac\uc6a9\uc5d0\ub294 \uadc0\ud558\uac00 \uc18d\ud55c \ud68c\uc0ac\uc758 \uc815\ucc45\uc774 \uc801\uc6a9\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ub2f9\uc0ac\ub294 \uadc0\ud558\uc640 \uadc0\ud558\uc758 \ud68c\uc0ac\uac00 \uad00\ub9ac\ud558\uace0 \ub2f9\uc0ac\uac00 \ud1b5\uc81c\ud560 \uc218 \uc5c6\ub294 \uac1c\uc778 \uc815\ubcf4\uc758 \ubcf4\ud638\uc5d0 \ub300\ud574 \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \n\ubcf8 Privacy Notice\ub294 \uc218\uc2dc\ub85c \uc5c5\ub370\uc774\ud2b8 \ub420 \uc218 \uc788\uc73c\ubbc0\ub85c \ubcf8 \uace0\uc9c0\ub97c \uc8fc\uae30\uc801\uc73c\ub85c \uc0b4\ud3b4\ubcf4\ub294 \uac83\uc774 \uc88b\uc2b5\ub2c8\ub2e4. \uc911\ub300\ud55c \ubcc0\uacbd \uc0ac\ud56d\uc774 \uc788\ub294 \uacbd\uc6b0 \ubcc0\uacbd \uc0ac\ud56d\uc774 \uc801\uc6a9\ub418\uae30 \uc804\uc5d0 \ub2f9\uc0ac\uac00 \ubcf4\uc720\ud55c \uc5f0\ub77d\ucc98 \uc815\ubcf4\ub97c \uc774\uc6a9\ud558\uc5ec \ubcc0\uacbd \uc0ac\ud56d\uc744 \uc54c\ub824\ub4dc\ub9bd\ub2c8\ub2e4.",
            "title": "Hardware Privacy Notice (\ud55c\uad6d\uc5b4)"
        },
        {
            "location": "/products/product-disclaimer/",
            "text": "\u00b6\n\n\nSuprema General Disclaimer\n\u00b6\n\n\nInformation in this document is provided in connection with Suprema products.\n\n\nThe right to use is acknowledged only for Suprema products included in the terms and conditions of use or sale for such products guaranteed by Suprema. No license, express or implied, by estoppel or otherwise, to any intellectual property is granted by this document.\n\n\nExcept as expressly stated in an agreement between you and Suprema, Suprema assumes no liability whatsoever, and Suprema disclaims all warranties, express or implied including, without limitation, relating to fitness for a particular purpose, merchantability, or noninfringement. \n\n\nAll warranties are VOID if Suprema products have been: 1) improperly installed or where the serial numbers, warranty date or quality assurance decals on the hardware are altered or removed; 2) used in a manner other than as authorized by Suprema; 3) modified, altered or repaired by a party other than Suprema or a party authorized by Suprema; or 4) operated or maintained in unsuitable environmental conditions.\n\n\nSuprema products are not intended for use in medical, lifesaving, life-sustaining applications, or other applications in which the failure of the Suprema product could create a situation where personal injury or death may occur. Should you purchase or use Suprema products for any such unintended or unauthorized application, you shall indemnify and hold Suprema and its officers, employees, subsidiaries, affiliates, and distributors harmless against all claims, costs, damages, and expenses, and reasonable attorney fees arising out of, directly or indirectly, any claim of personal injury or death associated with such unintended or unauthorized use, even if such claim alleges that Suprema was negligent regarding the design or manufacture of the part.\n\n\nSuprema reserves the right to make changes to specifications and product descriptions at any time without notice to improve reliability, function, or design.\n\n\nPersonal information, in the form of authentication messages and other relative information, may be stored within Suprema products during usage. Suprema does not take responsibility for any information, including personal information, stored within Suprema\u2019s products that are not within Suprema\u2019s direct control or as stated by the relevant terms and conditions. When any stored information, including personal information, is used, it is the responsibility of the product users to comply with national legislation (such as GDPR) and to ensure proper handling and processing. \n\n\nYou must not rely on the absence or characteristics of any features or instructions marked \"reserved\" or \"undefined.\" Suprema reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them.\n\n\nExcept as expressly set forth herein, to the maximum extent permitted by law, the Suprema products are sold \u201cas is\u201d. \n\n\nContact your local Suprema sales office or your distributor to obtain the latest specifications and before placing your product order. \n\n\nCopyright 2021. Suprema Inc. All rights reserved.\n\n\n\n\nSuprema General Disclaimer (\ud55c\uad6d\uc5b4)\n\u00b6\n\n\n\uc774 \ubb38\uc11c\ub294 \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uacfc \uad00\ub828\ub41c \uc815\ubcf4\ub97c \uc81c\uacf5\ud569\ub2c8\ub2e4.\n\n\n\uc774 \ubb38\uc11c\ub294 \uc288\ud504\ub9ac\ub9c8\uc758 \uc81c\ud488 \uc0ac\uc6a9 \ubc0f \ud310\ub9e4 \uacc4\uc57d\uc5d0 \ud3ec\ud568\ub41c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc5d0\ub9cc \uc0ac\uc6a9\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \n\n\n\uc774 \ubb38\uc11c\ub294 \uba85\uc2dc\uc801, \ubb35\uc2dc\uc801, \uae08\ubc18\uc5b8\uc758 \uc6d0\uce59 \ub610\ub294 \uc5b4\ub5a0\ud55c \ubc29\uc2dd\uc73c\ub85c\ub3c4 \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc5d0 \ub300\ud55c \ub77c\uc774\uc120\uc2a4\ub97c \ubd80\uc5ec\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\n\n\n\uadc0\ud558\uc640 \uc288\ud504\ub9ac\ub9c8 \uac04\uc758 \uacc4\uc57d\uc5d0 \uba85\uc2dc\ub41c \uacbd\uc6b0\ub97c \uc81c\uc678\ud558\uace0, \uc288\ud504\ub9ac\ub9c8\ub294 \uc5b4\ub5a0\ud55c \ucc45\uc784\ub3c4 \uc9c0\uc9c0 \uc54a\uc73c\uba70 \uc288\ud504\ub9ac\ub9c8\ub294 \ud2b9\uc815 \ubaa9\uc801\uc5d0\uc758 \uc801\ud569\uc131, \uc0c1\ud488\uc131 \ub610\ub294 \ube44\uce68\ud574\uc640 \uad00\ub828\ub41c \ubaa8\ub4e0 \uba85\uc2dc\uc801, \ubb35\uc2dc\uc801 \ubcf4\uc99d\uc744 \ubd80\uc778\ud569\ub2c8\ub2e4.\n\n\n\ubaa8\ub4e0 \ubcf4\uc99d\uc774 \ubb34\ud6a8\ud654\ub418\ub294 \uacbd\uc6b0\ub294 \ub2e4\uc74c\uacfc \uac19\uc2b5\ub2c8\ub2e4: \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc774 1) \uc798\ubabb \uc124\uce58\ub41c \uacbd\uc6b0 \ub610\ub294 \ud558\ub4dc\uc6e8\uc5b4\uc758 \uc77c\ub828\ubc88\ud638, \ubcf4\uc99d\uc815\ubcf4 \ub610\ub294 \ud488\uc9c8 \ubcf4\uc99d \uc2a4\ud2f0\ucee4\uac00 \ubcc0\uacbd \ub610\ub294 \uc81c\uac70\ub41c \uacbd\uc6b0; 2) \uc288\ud504\ub9ac\ub9c8\uac00 \ud5c8\uc6a9\ud55c  \ubc29\ubc95 \uc774\uc678\uc758 \ubc29\ubc95\uc73c\ub85c \uc0ac\uc6a9\ud55c \uacbd\uc6b0; 3)\uc288\ud504\ub9ac\ub9c8 \ub610\ub294 \uc288\ud504\ub9ac\ub9c8\uac00 \uc2b9\uc778\ud55c \ub2f9\uc0ac\uc790 \uc774\uc678\uc758 \ub2f9\uc0ac\uc790\uc5d0 \uc758\ud558\uc5ec \ubcc0\uacbd, \uc218\uc815 \ub610\ub294 \uc218\ub9ac\ub41c \uacbd\uc6b0; \ub610\ub294 4) \ubd80\uc801\uc808\ud55c \ud658\uacbd\uc5d0\uc11c \uc791\ub3d9\ub418\uac70\ub098 \uc720\uc9c0\ub41c \uacbd\uc6b0.\n\n\n\uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc740 \uc81c\ud488\uc758 \uace0\uc7a5\uc774 \ubd80\uc0c1\uc774\ub098 \uc0ac\ub9dd\uc0ac\uace0\ub85c \uc774\uc5b4\uc9c8 \uc218 \uc788\ub294 \uc758\ub8cc, \uc778\uba85 \uad6c\uc870, \uc0dd\uba85 \uc720\uc9c0\uc640 \uac19\uc740 \uc6a9\ub3c4\ub85c \uc0ac\uc6a9\ud558\ub3c4\ub85d \ub9cc\ub4e4\uc5b4\uc9c4 \uac83\uc740 \uc544\ub2d9\ub2c8\ub2e4. \ub9cc\uc57d \uadc0\ud558\uaed8\uc11c \uc774\ub7ec\ud55c  \uc6a9\ub3c4\ub85c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc744 \uad6c\ub9e4\ud558\uac70\ub098 \uc0ac\uc6a9\ud560 \uacbd\uc6b0, \uc774\ub85c \uc778\ud55c \ubd80\uc0c1 \ub610\ub294 \uc0ac\ub9dd\uc73c\ub85c \ubc1c\uc0dd\ud558\ub294 \ubaa8\ub4e0 \uccad\uad6c, \ube44\uc6a9, \uc190\uc2e4, \uc9c0\ucd9c \ubc0f \ud569\ub9ac\uc801\uc778 \ubcc0\ud638\uc0ac \ube44\uc6a9\uc73c\ub85c\ubd80\ud130 \uc288\ud504\ub9ac\ub9c8\uc640 \uadf8 \uad6c\uc131\uc6d0, \uc790\ud68c\uc0ac, \uacc4\uc5f4\uc0ac \ubc0f \uacf5\uae09\uc0ac\ub97c \uba74\ucc45\uc2dc\ucf1c\uc57c \ud569\ub2c8\ub2e4. \uc81c\ud488 \ub514\uc790\uc778\uc774\ub098 \uc81c\uc870\uc5d0 \uc288\ud504\ub9ac\ub9c8\uc758 \uacfc\uc2e4\uc774 \uc788\ub2e4\uace0 \uc8fc\uc7a5\ub418\ub294 \uacbd\uc6b0\uc5d0\ub3c4 \ub9c8\ucc2c\uac00\uc9c0\uc785\ub2c8\ub2e4.\n\n\n\uc288\ud504\ub9ac\ub9c8\ub294 \uc2e0\ub8b0\uc131, \uae30\ub2a5 \ub610\ub294 \ub514\uc790\uc778\uc744 \uac1c\uc120\ud558\uae30 \uc704\ud558\uc5ec \uc5b8\uc81c\ub4e0\uc9c0 \uc608\uace0\uc5c6\uc774 \uc0ac\uc591\uacfc \uc81c\ud488 \uc124\uba85\uc744 \ubcc0\uacbd\ud560 \uad8c\ub9ac\ub97c \uac00\uc9c0\uace0 \uc788\uc2b5\ub2c8\ub2e4.\n\n\n\uac1c\uc778\uc815\ubcf4\ub294 \uc81c\ud488 \uc0ac\uc6a9\uc2dc \uc778\uc99d\uba54\uc2dc\uc9c0 \ubc0f \uae30\ud0c0 \uad00\ub828 \uc815\ubcf4\uc758 \ud615\ud0dc\ub85c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc5d0 \uc800\uc7a5\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4.  \uc288\ud504\ub9ac\ub9c8\ub294 \uc288\ud504\ub9ac\ub9c8\uac00 \uc9c1\uc811 \ud1b5\uc81c\ud560 \uc218 \uc5c6\ub294 \ub610\ub294 \uad00\ub828 \uacc4\uc57d\uc5d0 \uba85\uc2dc\ub41c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc5d0 \uc800\uc7a5\ub418\ub294 \uac1c\uc778\uc815\ubcf4\ub97c \ube44\ub86f\ud55c \uc5b4\ub5a0\ud55c \uc815\ubcf4\uc5d0 \ub300\ud574\uc11c\ub3c4 \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \uac1c\uc778 \uc815\ubcf4\ub97c \ud3ec\ud568\ud558\uc5ec \uc800\uc7a5\ub41c \uc815\ubcf4\ub97c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 \uc81c\ud488 \uc0ac\uc6a9\uc790\ub294 \uad00\ub828 \ubc95\ub960 (\uc608\ub97c\ub4e4\uc5b4, GDPR)\uc744 \uc900\uc218\ud558\uace0 \uc801\uc808\ud55c \ucde8\uae09\uacfc \ucc98\ub9ac\ub97c \ud574\uc57c \ud560 \ucc45\uc784\uc774 \uc788\uc2b5\ub2c8\ub2e4.\n\n\n\uadc0\ud558\ub294 \uc5b4\ub5a0\ud55c \uae30\ub2a5\uc758 \ubd80\uc7ac \ub610\ub294 \ud2b9\uc9d5,  \u201creserved\u201d \ub610\ub294 \u201cundefined\u201d\ub85c \ud45c\uc2dc\ub41c \uc124\uba85\uc5d0 \uc758\uc874\ud574\uc11c\ub294 \uc548\ub429\ub2c8\ub2e4. \uc288\ud504\ub9ac\ub9c8\ub294 \uc774\ub97c \ucd94\ud6c4\uc5d0 \uc815\uc758\ud560 \uc218 \uc788\uc73c\uba70 \ucd94\ud6c4\uc5d0 \uac00\ud55c \ubcc0\uacbd\uc774 \ud604\uc7ac\uc640 \uc0c1\ucda9\ub41c\ub2e4\uace0 \ud558\ub354\ub77c\ub3c4 \uc288\ud504\ub9ac\ub9c8\ub294 \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\n\n\n\uc774 \ubb38\uc11c\uc5d0 \uba85\uc2dc\uc801\uc73c\ub85c \uae30\uc7ac\ub418\uc5b4 \uc788\ub294 \uacbd\uc6b0\ub97c \uc81c\uc678\ud558\uace0, \uc288\ud504\ub9ac\ub9c8\ub294 \ubc95\ub960\uc774 \ud5c8\uc6a9\ud558\ub294 \ucd5c\ub300 \ubc94\uc704 \ub0b4\uc5d0\uc11c \u201c\uc788\ub294 \uadf8\ub300\ub85c\u201d \ud310\ub9e4\ub429\ub2c8\ub2e4.\n\n\n\uc81c\ud488\uc744 \uc8fc\ubb38\ud558\uae30 \uc804\uc5d0 \uac00\uae4c\uc6b4 \uc288\ud504\ub9ac\ub9c8 \uc601\uc5c5\uc18c \ub610\ub294 \ub300\ub9ac\uc810\uc5d0 \ubb38\uc758\ud558\uc5ec \ucd5c\uc2e0 \uc0ac\uc591\uc744 \ud655\uc778\ud558\uc2ed\uc2dc\uc624.\n\n\nCopyright 2021. Suprema Inc. All rights reserved.",
            "title": "Product Disclaimer"
        },
        {
            "location": "/products/product-disclaimer/#suprema-general-disclaimer",
            "text": "Information in this document is provided in connection with Suprema products.  The right to use is acknowledged only for Suprema products included in the terms and conditions of use or sale for such products guaranteed by Suprema. No license, express or implied, by estoppel or otherwise, to any intellectual property is granted by this document.  Except as expressly stated in an agreement between you and Suprema, Suprema assumes no liability whatsoever, and Suprema disclaims all warranties, express or implied including, without limitation, relating to fitness for a particular purpose, merchantability, or noninfringement.   All warranties are VOID if Suprema products have been: 1) improperly installed or where the serial numbers, warranty date or quality assurance decals on the hardware are altered or removed; 2) used in a manner other than as authorized by Suprema; 3) modified, altered or repaired by a party other than Suprema or a party authorized by Suprema; or 4) operated or maintained in unsuitable environmental conditions.  Suprema products are not intended for use in medical, lifesaving, life-sustaining applications, or other applications in which the failure of the Suprema product could create a situation where personal injury or death may occur. Should you purchase or use Suprema products for any such unintended or unauthorized application, you shall indemnify and hold Suprema and its officers, employees, subsidiaries, affiliates, and distributors harmless against all claims, costs, damages, and expenses, and reasonable attorney fees arising out of, directly or indirectly, any claim of personal injury or death associated with such unintended or unauthorized use, even if such claim alleges that Suprema was negligent regarding the design or manufacture of the part.  Suprema reserves the right to make changes to specifications and product descriptions at any time without notice to improve reliability, function, or design.  Personal information, in the form of authentication messages and other relative information, may be stored within Suprema products during usage. Suprema does not take responsibility for any information, including personal information, stored within Suprema\u2019s products that are not within Suprema\u2019s direct control or as stated by the relevant terms and conditions. When any stored information, including personal information, is used, it is the responsibility of the product users to comply with national legislation (such as GDPR) and to ensure proper handling and processing.   You must not rely on the absence or characteristics of any features or instructions marked \"reserved\" or \"undefined.\" Suprema reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them.  Except as expressly set forth herein, to the maximum extent permitted by law, the Suprema products are sold \u201cas is\u201d.   Contact your local Suprema sales office or your distributor to obtain the latest specifications and before placing your product order.   Copyright 2021. Suprema Inc. All rights reserved.",
            "title": "Suprema General Disclaimer"
        },
        {
            "location": "/products/product-disclaimer/#suprema-general-disclaimer_1",
            "text": "\uc774 \ubb38\uc11c\ub294 \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uacfc \uad00\ub828\ub41c \uc815\ubcf4\ub97c \uc81c\uacf5\ud569\ub2c8\ub2e4.  \uc774 \ubb38\uc11c\ub294 \uc288\ud504\ub9ac\ub9c8\uc758 \uc81c\ud488 \uc0ac\uc6a9 \ubc0f \ud310\ub9e4 \uacc4\uc57d\uc5d0 \ud3ec\ud568\ub41c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc5d0\ub9cc \uc0ac\uc6a9\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4.   \uc774 \ubb38\uc11c\ub294 \uba85\uc2dc\uc801, \ubb35\uc2dc\uc801, \uae08\ubc18\uc5b8\uc758 \uc6d0\uce59 \ub610\ub294 \uc5b4\ub5a0\ud55c \ubc29\uc2dd\uc73c\ub85c\ub3c4 \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc5d0 \ub300\ud55c \ub77c\uc774\uc120\uc2a4\ub97c \ubd80\uc5ec\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.  \uadc0\ud558\uc640 \uc288\ud504\ub9ac\ub9c8 \uac04\uc758 \uacc4\uc57d\uc5d0 \uba85\uc2dc\ub41c \uacbd\uc6b0\ub97c \uc81c\uc678\ud558\uace0, \uc288\ud504\ub9ac\ub9c8\ub294 \uc5b4\ub5a0\ud55c \ucc45\uc784\ub3c4 \uc9c0\uc9c0 \uc54a\uc73c\uba70 \uc288\ud504\ub9ac\ub9c8\ub294 \ud2b9\uc815 \ubaa9\uc801\uc5d0\uc758 \uc801\ud569\uc131, \uc0c1\ud488\uc131 \ub610\ub294 \ube44\uce68\ud574\uc640 \uad00\ub828\ub41c \ubaa8\ub4e0 \uba85\uc2dc\uc801, \ubb35\uc2dc\uc801 \ubcf4\uc99d\uc744 \ubd80\uc778\ud569\ub2c8\ub2e4.  \ubaa8\ub4e0 \ubcf4\uc99d\uc774 \ubb34\ud6a8\ud654\ub418\ub294 \uacbd\uc6b0\ub294 \ub2e4\uc74c\uacfc \uac19\uc2b5\ub2c8\ub2e4: \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc774 1) \uc798\ubabb \uc124\uce58\ub41c \uacbd\uc6b0 \ub610\ub294 \ud558\ub4dc\uc6e8\uc5b4\uc758 \uc77c\ub828\ubc88\ud638, \ubcf4\uc99d\uc815\ubcf4 \ub610\ub294 \ud488\uc9c8 \ubcf4\uc99d \uc2a4\ud2f0\ucee4\uac00 \ubcc0\uacbd \ub610\ub294 \uc81c\uac70\ub41c \uacbd\uc6b0; 2) \uc288\ud504\ub9ac\ub9c8\uac00 \ud5c8\uc6a9\ud55c  \ubc29\ubc95 \uc774\uc678\uc758 \ubc29\ubc95\uc73c\ub85c \uc0ac\uc6a9\ud55c \uacbd\uc6b0; 3)\uc288\ud504\ub9ac\ub9c8 \ub610\ub294 \uc288\ud504\ub9ac\ub9c8\uac00 \uc2b9\uc778\ud55c \ub2f9\uc0ac\uc790 \uc774\uc678\uc758 \ub2f9\uc0ac\uc790\uc5d0 \uc758\ud558\uc5ec \ubcc0\uacbd, \uc218\uc815 \ub610\ub294 \uc218\ub9ac\ub41c \uacbd\uc6b0; \ub610\ub294 4) \ubd80\uc801\uc808\ud55c \ud658\uacbd\uc5d0\uc11c \uc791\ub3d9\ub418\uac70\ub098 \uc720\uc9c0\ub41c \uacbd\uc6b0.  \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc740 \uc81c\ud488\uc758 \uace0\uc7a5\uc774 \ubd80\uc0c1\uc774\ub098 \uc0ac\ub9dd\uc0ac\uace0\ub85c \uc774\uc5b4\uc9c8 \uc218 \uc788\ub294 \uc758\ub8cc, \uc778\uba85 \uad6c\uc870, \uc0dd\uba85 \uc720\uc9c0\uc640 \uac19\uc740 \uc6a9\ub3c4\ub85c \uc0ac\uc6a9\ud558\ub3c4\ub85d \ub9cc\ub4e4\uc5b4\uc9c4 \uac83\uc740 \uc544\ub2d9\ub2c8\ub2e4. \ub9cc\uc57d \uadc0\ud558\uaed8\uc11c \uc774\ub7ec\ud55c  \uc6a9\ub3c4\ub85c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc744 \uad6c\ub9e4\ud558\uac70\ub098 \uc0ac\uc6a9\ud560 \uacbd\uc6b0, \uc774\ub85c \uc778\ud55c \ubd80\uc0c1 \ub610\ub294 \uc0ac\ub9dd\uc73c\ub85c \ubc1c\uc0dd\ud558\ub294 \ubaa8\ub4e0 \uccad\uad6c, \ube44\uc6a9, \uc190\uc2e4, \uc9c0\ucd9c \ubc0f \ud569\ub9ac\uc801\uc778 \ubcc0\ud638\uc0ac \ube44\uc6a9\uc73c\ub85c\ubd80\ud130 \uc288\ud504\ub9ac\ub9c8\uc640 \uadf8 \uad6c\uc131\uc6d0, \uc790\ud68c\uc0ac, \uacc4\uc5f4\uc0ac \ubc0f \uacf5\uae09\uc0ac\ub97c \uba74\ucc45\uc2dc\ucf1c\uc57c \ud569\ub2c8\ub2e4. \uc81c\ud488 \ub514\uc790\uc778\uc774\ub098 \uc81c\uc870\uc5d0 \uc288\ud504\ub9ac\ub9c8\uc758 \uacfc\uc2e4\uc774 \uc788\ub2e4\uace0 \uc8fc\uc7a5\ub418\ub294 \uacbd\uc6b0\uc5d0\ub3c4 \ub9c8\ucc2c\uac00\uc9c0\uc785\ub2c8\ub2e4.  \uc288\ud504\ub9ac\ub9c8\ub294 \uc2e0\ub8b0\uc131, \uae30\ub2a5 \ub610\ub294 \ub514\uc790\uc778\uc744 \uac1c\uc120\ud558\uae30 \uc704\ud558\uc5ec \uc5b8\uc81c\ub4e0\uc9c0 \uc608\uace0\uc5c6\uc774 \uc0ac\uc591\uacfc \uc81c\ud488 \uc124\uba85\uc744 \ubcc0\uacbd\ud560 \uad8c\ub9ac\ub97c \uac00\uc9c0\uace0 \uc788\uc2b5\ub2c8\ub2e4.  \uac1c\uc778\uc815\ubcf4\ub294 \uc81c\ud488 \uc0ac\uc6a9\uc2dc \uc778\uc99d\uba54\uc2dc\uc9c0 \ubc0f \uae30\ud0c0 \uad00\ub828 \uc815\ubcf4\uc758 \ud615\ud0dc\ub85c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc5d0 \uc800\uc7a5\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4.  \uc288\ud504\ub9ac\ub9c8\ub294 \uc288\ud504\ub9ac\ub9c8\uac00 \uc9c1\uc811 \ud1b5\uc81c\ud560 \uc218 \uc5c6\ub294 \ub610\ub294 \uad00\ub828 \uacc4\uc57d\uc5d0 \uba85\uc2dc\ub41c \uc288\ud504\ub9ac\ub9c8 \uc81c\ud488\uc5d0 \uc800\uc7a5\ub418\ub294 \uac1c\uc778\uc815\ubcf4\ub97c \ube44\ub86f\ud55c \uc5b4\ub5a0\ud55c \uc815\ubcf4\uc5d0 \ub300\ud574\uc11c\ub3c4 \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \uac1c\uc778 \uc815\ubcf4\ub97c \ud3ec\ud568\ud558\uc5ec \uc800\uc7a5\ub41c \uc815\ubcf4\ub97c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 \uc81c\ud488 \uc0ac\uc6a9\uc790\ub294 \uad00\ub828 \ubc95\ub960 (\uc608\ub97c\ub4e4\uc5b4, GDPR)\uc744 \uc900\uc218\ud558\uace0 \uc801\uc808\ud55c \ucde8\uae09\uacfc \ucc98\ub9ac\ub97c \ud574\uc57c \ud560 \ucc45\uc784\uc774 \uc788\uc2b5\ub2c8\ub2e4.  \uadc0\ud558\ub294 \uc5b4\ub5a0\ud55c \uae30\ub2a5\uc758 \ubd80\uc7ac \ub610\ub294 \ud2b9\uc9d5,  \u201creserved\u201d \ub610\ub294 \u201cundefined\u201d\ub85c \ud45c\uc2dc\ub41c \uc124\uba85\uc5d0 \uc758\uc874\ud574\uc11c\ub294 \uc548\ub429\ub2c8\ub2e4. \uc288\ud504\ub9ac\ub9c8\ub294 \uc774\ub97c \ucd94\ud6c4\uc5d0 \uc815\uc758\ud560 \uc218 \uc788\uc73c\uba70 \ucd94\ud6c4\uc5d0 \uac00\ud55c \ubcc0\uacbd\uc774 \ud604\uc7ac\uc640 \uc0c1\ucda9\ub41c\ub2e4\uace0 \ud558\ub354\ub77c\ub3c4 \uc288\ud504\ub9ac\ub9c8\ub294 \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.  \uc774 \ubb38\uc11c\uc5d0 \uba85\uc2dc\uc801\uc73c\ub85c \uae30\uc7ac\ub418\uc5b4 \uc788\ub294 \uacbd\uc6b0\ub97c \uc81c\uc678\ud558\uace0, \uc288\ud504\ub9ac\ub9c8\ub294 \ubc95\ub960\uc774 \ud5c8\uc6a9\ud558\ub294 \ucd5c\ub300 \ubc94\uc704 \ub0b4\uc5d0\uc11c \u201c\uc788\ub294 \uadf8\ub300\ub85c\u201d \ud310\ub9e4\ub429\ub2c8\ub2e4.  \uc81c\ud488\uc744 \uc8fc\ubb38\ud558\uae30 \uc804\uc5d0 \uac00\uae4c\uc6b4 \uc288\ud504\ub9ac\ub9c8 \uc601\uc5c5\uc18c \ub610\ub294 \ub300\ub9ac\uc810\uc5d0 \ubb38\uc758\ud558\uc5ec \ucd5c\uc2e0 \uc0ac\uc591\uc744 \ud655\uc778\ud558\uc2ed\uc2dc\uc624.  Copyright 2021. Suprema Inc. All rights reserved.",
            "title": "Suprema General Disclaimer (\ud55c\uad6d\uc5b4)"
        },
        {
            "location": "/documents/Introduction/",
            "text": "1. Introduction\n\u00b6\n\n\nThe SFM SDK is a collection of APIs for interfacing with SFM modules and BioEntry readers. In addition to simple wrapper functions for Packet Protocol, it also provides high level APIs such as template DB management, image manipulation, etc. By using the SDK, developers could write Win32 applications quickly without knowing the minute details of Packet Protocol.\n\n\n\n\nFig. 1. SFM SDK\n\n\nAs shown in Fig. 1, the SDK is composed of several layers and developers could choose whichever layer suited for their applications. Another strong point of the SDK is its extensibility. Many of core APIs provide callback mechanism, with which developers can add customized functions. UniFingerUI V5.x is a good example of this feature. Completely rewritten from scratch, UniFingerUI V5.x covers all the core functionalities of SFM modules and shows how to use the SDK in real applications. The source codes of it are also provided in the SDK.\n\n\n1.1. Contents of the SDK\n\u00b6\n\n\n\n\n\n\n\n\nDirectory\n\n\nSub Directory\n\n\nContents\n\n\n\n\n\n\n\n\n\n\nSDK\n\n\nDocument\n\n\n- SFM SDK Reference Manual   \n - Packet Protocol Manual\n\n\n\n\n\n\n\n\nInclude\n\n\n- Header files of SFM SDK.\n\n\n\n\n\n\n\n\nLib\n\n\n- SFM_SDK.dll: SDK DLL file.   \n - SFM_SDK_Debug.dll: SDK DLL with debug information.   \n - SFM_SDK.lib: import library to be linked with C/C++ applications.   \n - SFM_SDK_Debug.lib: import library to be linked with C/C++ applications\n\n\n\n\n\n\n\n\nLib_Ordinal\n\n\nThe functions in these DLLs are exported by ordinal using DEF files. Use these DLLs if you have problem using the SDK in programming languages other than C/C++.\n\n\n\n\n\n\nUniFingerUI\n\n\n\n\n- Source codes   \n - Visual C++ 6.0 project file   \n - Visual C++ 2010 project file (v.5.1~)\n\n\n\n\n\n\nExample\n\n\nC#\n\n\n- A simple example which shows how to use the SDK in .NET environment\n\n\n\n\n\n\n\n\n1.2. Usage\n\u00b6\n\n\n1.2.1. Compilation\n\u00b6\n\n\nTo call APIs defined in the SFM SDK, \u2018UF_API.h\u2019 should be included in the source files and SDK\\Include should be added to the include directories. To link user application with the SFM SDK, SFM_SDK.lib should be added to library modules.\n\n\nThe following snippet shows a typical source file.\n\n\n#include \u201cUF_API.h\u201d\n\n\nint\n \nmain\n()\n\n\n{\n\n\n    \n// First, initialize the serial port\n\n\n    \nUF_RET_CODE\n \nresult\n \n=\n \nUF_InitCommPort\n(\n \n\u201c\nCOM1\n\u201d\n,\n \n115200\n,\n \nFALSE\n \n);\n\n\n\n    \nIf\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n\n\n    \n{\n\n\n        \nreturn\n \n-1\n;\n\n\n    \n}\n\n\n\n    \n// Call APIs\n\n\n    \nUINT32\n \nuserID\n;\n\n\n    \nBYTE\n \nsubID\n;\n\n\n\n    \nresult\n \n=\n \nUF_Identify\n(\n \n&\nuserID\n,\n \n&\nsubID\n \n);\n\n\n\n    \n// \u2026\n\n\n}\n\n\n\n1.2.2. Using the DLL\nTo run applications compiled with the SFM SDK, the SFM_SDK.dll file should be in the system directory or in the same directory of the application.\n\n\n1.3. UniFinger UI\n\u00b6\n\n\nUniFinger UI is a full-featured application by which users can test all the core functionalities of SFM modules. UniFinger UI is implemented using the SFM SDK and full source codes are available for SDK users.\n\n\n1.3.1. Optional Requirements\n\u00b6\n\n\nUniFinger UI uses Microsoft\u2019s HTML Help Workshop for online help. You can download it from the MSDN web site.\n\n\n1.3.2. Compilation\n\u00b6\n\n\nOpen UniFingerUI\\UniFingerUI.dsw in Microsoft Visual C++ 6.0 or later. If you download and install HTML Help Workshop, changes the include directory and library path accordingly. If you don\u2019t want online help, just select \u2018Win32 Debug Without Help\u2019 or \u2018Win32 Release Without Help\u2019 as the active configuration.\n\n\n\n\nFig. 2. UniFingerUI",
            "title": "Introduction"
        },
        {
            "location": "/documents/Introduction/#1-introduction",
            "text": "The SFM SDK is a collection of APIs for interfacing with SFM modules and BioEntry readers. In addition to simple wrapper functions for Packet Protocol, it also provides high level APIs such as template DB management, image manipulation, etc. By using the SDK, developers could write Win32 applications quickly without knowing the minute details of Packet Protocol.   Fig. 1. SFM SDK  As shown in Fig. 1, the SDK is composed of several layers and developers could choose whichever layer suited for their applications. Another strong point of the SDK is its extensibility. Many of core APIs provide callback mechanism, with which developers can add customized functions. UniFingerUI V5.x is a good example of this feature. Completely rewritten from scratch, UniFingerUI V5.x covers all the core functionalities of SFM modules and shows how to use the SDK in real applications. The source codes of it are also provided in the SDK.",
            "title": "1. Introduction"
        },
        {
            "location": "/documents/Introduction/#11-contents-of-the-sdk",
            "text": "Directory  Sub Directory  Contents      SDK  Document  - SFM SDK Reference Manual     - Packet Protocol Manual     Include  - Header files of SFM SDK.     Lib  - SFM_SDK.dll: SDK DLL file.     - SFM_SDK_Debug.dll: SDK DLL with debug information.     - SFM_SDK.lib: import library to be linked with C/C++ applications.     - SFM_SDK_Debug.lib: import library to be linked with C/C++ applications     Lib_Ordinal  The functions in these DLLs are exported by ordinal using DEF files. Use these DLLs if you have problem using the SDK in programming languages other than C/C++.    UniFingerUI   - Source codes     - Visual C++ 6.0 project file     - Visual C++ 2010 project file (v.5.1~)    Example  C#  - A simple example which shows how to use the SDK in .NET environment",
            "title": "1.1. Contents of the SDK"
        },
        {
            "location": "/documents/Introduction/#12-usage",
            "text": "",
            "title": "1.2. Usage"
        },
        {
            "location": "/documents/Introduction/#121-compilation",
            "text": "To call APIs defined in the SFM SDK, \u2018UF_API.h\u2019 should be included in the source files and SDK\\Include should be added to the include directories. To link user application with the SFM SDK, SFM_SDK.lib should be added to library modules.  The following snippet shows a typical source file.  #include \u201cUF_API.h\u201d  int   main ()  {       // First, initialize the serial port       UF_RET_CODE   result   =   UF_InitCommPort (   \u201c COM1 \u201d ,   115200 ,   FALSE   );       If (   result   !=   UF_RET_SUCCESS   )       {           return   -1 ;       }       // Call APIs       UINT32   userID ;       BYTE   subID ;       result   =   UF_Identify (   & userID ,   & subID   );       // \u2026  }  \n1.2.2. Using the DLL\nTo run applications compiled with the SFM SDK, the SFM_SDK.dll file should be in the system directory or in the same directory of the application.",
            "title": "1.2.1. Compilation"
        },
        {
            "location": "/documents/Introduction/#13-unifinger-ui",
            "text": "UniFinger UI is a full-featured application by which users can test all the core functionalities of SFM modules. UniFinger UI is implemented using the SFM SDK and full source codes are available for SDK users.",
            "title": "1.3. UniFinger UI"
        },
        {
            "location": "/documents/Introduction/#131-optional-requirements",
            "text": "UniFinger UI uses Microsoft\u2019s HTML Help Workshop for online help. You can download it from the MSDN web site.",
            "title": "1.3.1. Optional Requirements"
        },
        {
            "location": "/documents/Introduction/#132-compilation",
            "text": "Open UniFingerUI\\UniFingerUI.dsw in Microsoft Visual C++ 6.0 or later. If you download and install HTML Help Workshop, changes the include directory and library path accordingly. If you don\u2019t want online help, just select \u2018Win32 Debug Without Help\u2019 or \u2018Win32 Release Without Help\u2019 as the active configuration.   Fig. 2. UniFingerUI",
            "title": "1.3.2. Compilation"
        },
        {
            "location": "/documents/API_Compatibility/",
            "text": "2. API Compatibility\n\u00b6\n\n\n\n\n\n\n\n\nCategory\n\n\nFunction\n\n\nSFM 3000/5000\n\n\nSFM 4000\n\n\nSFM 3500\n\n\nSFM 5500\n\n\nSFM 6000\n\n\n\n\n\n\n\n\n\n\nSerial Comm. API\n\n\nUF_InitCommPort\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CloseCommPort\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Reconnect\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetBaudrate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetAsciiMode\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nSocket API\n\n\nUF_InitSocket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CloseSocket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nLow-Level Packet API\n\n\nUF_SendPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReceivePacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SendNetworkPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReceiveNetworkPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SendRawData\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReceiveRawData\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SendDataPacket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSendPacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetReceivePacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSendDataPacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetReceiveDataPacketCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSendRawDataCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetReceiveRawDataCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetDefaultPacketSize\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetDefaultPacketSize\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nGeneral Command API\n\n\nUF_Command\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CommandEx\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CommandSendData\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CommandSendDataEx\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Cancel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetProtocol\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetProtocol\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetModuleID\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetGenericCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetInputCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetGenericCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetInputCommandTimeout\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetNetworkDelay\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetNetworkDelay\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nModule API\n\n\nUF_GetModuleInfo\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetModuleString\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModule\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModuleID\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModuleBySocket\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SearchModuleIDEx\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CalibrateSensor\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Upgrade\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Reset\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ PowerOff\n\n\nX\n\n\nO\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_Lock\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_Unlock\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ChangePassword\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\nSystem Parameters API\n\n\nUF_InitSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetMultiSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetMultiSysParameter\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_Save\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SaveConfiguration\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadConfigurationHeader\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_LoadConfiguration\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_MakeParameterConfiguration\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nTemplate Mgmt. API\n\n\nUF_GetNumOfTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetMaxNumOfTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAllUserInfo\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAllUserInfoEx\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SortUserInfo\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetUserInfoCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetAdminLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetAdminLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearAllAdminLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SaveDB\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_LoadDB\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_CheckTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadOneTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetScanCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ScanTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_FixProvisionalTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSecurityLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_GetSecurityLevel\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetUserIDByAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ResetAllAuthType*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetEntranceLimit*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetEntranceLimit*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ClearAllEntranceLimit*\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\nImage API\n\n\nUF_ConvertToBitmap\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SaveImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_LoadImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ScanImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nEnroll API\n\n\nUF_Enroll\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollContinue\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollAfterVerification\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollMultipleTemplates\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnrollImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetEnrollCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nIdentify API\n\n\nUF_Identify\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_IdentifyTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_IdentifyImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetIdentifyCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nVerify API\n\n\nUF_Verify\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_VerifyTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_VerifyHostTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_VerifyImage\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetVerifyCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nDelete API\n\n\nUF_Delete\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteOneTemplate\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteMultipleTemplates\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteAll\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_DeleteByScan\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetDeleteCallback\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nI/O API\n\n\nUF_InitIO\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetInputFunction\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetInputFunction\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetInputStatus\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetOutputEventList\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ClearAllOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ClearOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetOutputEvent\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetOutputStatus\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetLegacyWiegandConfig\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetLegacyWiegandConfig\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_MakeIOConfiguration\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\nGPIO API\n\n\nUF_GetGPIOConfiguration\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetInputGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetOutputGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetSharedGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_DisableGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_ClearAllGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_SetDefaultGPIO\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnableWiegandInput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_EnableWiegandOutput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_DisableWiegandInput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_DisableWiegandOutput\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_MakeGPIOConfiguration\n\n\nO\n\n\nO\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\nUser Memory API\n\n\nUF_WriteUserMemory\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadUserMemory\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nLog and Time Mgmt. API\n\n\nUF_SetTime\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetTime\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetNumOfLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ReadLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ReadLatestLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteOldestLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteAllLog\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ClearLogCache\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ReadLogCache\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetCustomLogField\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetCustomLogField\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\nExtended Wiegand API\n\n\nUF_SetWiegandFormat\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetWiegandFormat\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetWiegandIO\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetWiegandIO\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetWiegandOption\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetWiegandOption\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetAltValue\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ClearAltValue\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetAltValue\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_MakeWiegandConfiguration\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\nWiegand Command Card API\n\n\nUF_AddWiegandCommandCard\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetWiegandCommandCardList\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_ClearAllWiegandCommandCard\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\nSmartCard API\n\n\nUF_ReadSmartCard\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_ReadSmartCardWithAG\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_WriteSmartCard\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_WriteSmartCardWithAG\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_WriteSmartCardWithEntranceLimit*\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_FormatSmartCard\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetSmartCardMode\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetSmartCardMode\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_ChangePrimaryKey\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_ChangeSecondaryKey\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetKeyOption\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetKeyOption\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetCardLayout\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetCardLayout\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetSmartCardCallback\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\nAccess Control API\n\n\nUF_AddTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteAllTimeSchedule\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_AddHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteAllHoliday\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_AddAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteAllAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_SetUserAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetUserAccessGroup\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\nBlacklist API\n\n\nUF_AddBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_GetBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUF_DeleteAllBlacklist\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\nX\n\n\n\n\n\n\nWSQ API\n\n\nUF_ScanImageEx\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_ReadImageEx\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUF_WSQ_Decode\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\nO\n\n\n\n\n\n\nFile System API\n\n\nUF_ResetSystemConfiguration\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nUF_FormatUserDatabase\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nO",
            "title": "API Compatability"
        },
        {
            "location": "/documents/API_Compatibility/#2-api-compatibility",
            "text": "Category  Function  SFM 3000/5000  SFM 4000  SFM 3500  SFM 5500  SFM 6000      Serial Comm. API  UF_InitCommPort  O  O  O  O  O     UF_CloseCommPort  O  O  O  O  O     UF_Reconnect  O  O  O  O  O     UF_SetBaudrate  O  O  O  O  O     UF_SetAsciiMode  O  O  O  O  O    Socket API  UF_InitSocket  O  O  O  O  O     UF_CloseSocket  O  O  O  O  O    Low-Level Packet API  UF_SendPacket  O  O  O  O  O     UF_ReceivePacket  O  O  O  O  O     UF_SendNetworkPacket  O  O  O  O  O     UF_ReceiveNetworkPacket  O  O  O  O  O     UF_SendRawData  O  O  O  O  O     UF_ReceiveRawData  O  O  O  O  O     UF_SendDataPacket  O  O  O  O  O     UF_SetSendPacketCallback  O  O  O  O  O     UF_SetReceivePacketCallback  O  O  O  O  O     UF_SetSendDataPacketCallback  O  O  O  O  O     UF_SetReceiveDataPacketCallback  O  O  O  O  O     UF_SetSendRawDataCallback  O  O  O  O  O     UF_SetReceiveRawDataCallback  O  O  O  O  O     UF_SetDefaultPacketSize  O  O  O  O  O     UF_GetDefaultPacketSize  O  O  O  O  O    General Command API  UF_Command  O  O  O  O  O     UF_CommandEx  O  O  O  O  O     UF_CommandSendData  O  O  O  O  O     UF_CommandSendDataEx  O  O  O  O  O     UF_Cancel  O  O  O  O  O     UF_SetProtocol  O  O  O  O  O     UF_GetProtocol  O  O  O  O  O     UF_GetModuleID  O  O  O  O  O     UF_SetGenericCommandTimeout  O  O  O  O  O     UF_SetInputCommandTimeout  O  O  O  O  O     UF_GetGenericCommandTimeout  O  O  O  O  O     UF_GetInputCommandTimeout  O  O  O  O  O     UF_SetNetworkDelay  O  O  O  O  O     UF_GetNetworkDelay  O  O  O  O  O    Module API  UF_GetModuleInfo  O  O  O  O  O     UF_GetModuleString  O  O  O  O  O     UF_SearchModule  O  O  O  O  O     UF_SearchModuleID  O  O  O  O  O     UF_SearchModuleBySocket  O  O  O  O  O     UF_SearchModuleIDEx  O  O  O  O  O     UF_CalibrateSensor  O  O  O  O  O     UF_Upgrade  O  O  O  O  O     UF_Reset  O  O  O  O  O     UF_ PowerOff  X  O  X  X  X     UF_Lock  X  X  O  O  X     UF_Unlock  X  X  O  O  X     UF_ChangePassword  X  X  O  O  X    System Parameters API  UF_InitSysParameter  O  O  O  O  O     UF_GetSysParameter  O  O  O  O  O     UF_SetSysParameter  O  O  O  O  O     UF_GetMultiSysParameter  O  O  O  O  O     UF_SetMultiSysParameter  O  O  O  O  O     UF_Save  O  O  O  O  O     UF_SaveConfiguration  O  O  O  O  O     UF_ReadConfigurationHeader  O  O  O  O  O     UF_LoadConfiguration  O  O  O  O  O     UF_MakeParameterConfiguration  O  O  O  O  O    Template Mgmt. API  UF_GetNumOfTemplate  O  O  O  O  O     UF_GetMaxNumOfTemplate  O  O  O  O  O     UF_GetAllUserInfo  O  O  O  O  O     UF_GetAllUserInfoEx  X  X  X  X  X     UF_SortUserInfo  O  O  O  O  O     UF_SetUserInfoCallback  O  O  O  O  O     UF_SetAdminLevel  O  O  O  O  O     UF_GetAdminLevel  O  O  O  O  O     UF_ClearAllAdminLevel  O  O  O  O  O     UF_SaveDB  O  O  O  O  O     UF_LoadDB  O  O  O  O  O     UF_CheckTemplate  O  O  O  O  O     UF_ReadTemplate  O  O  O  O  O     UF_ReadOneTemplate  O  O  O  O  O     UF_SetScanCallback  O  O  O  O  O     UF_ScanTemplate  O  O  O  O  O     UF_FixProvisionalTemplate  O  O  O  O  O     UF_SetSecurityLevel  O  O  O  O  O     UF_GetSecurityLevel  O  O  O  O  O     UF_SetAuthType*  X  X  O  O  X     UF_GetAuthType*  X  X  O  O  X     UF_GetUserIDByAuthType*  X  X  O  O  X     UF_ResetAllAuthType*  X  X  O  O  X     UF_SetEntranceLimit*  X  X  O  O  X     UF_GetEntranceLimit*  X  X  O  O  X     UF_ClearAllEntranceLimit*  X  X  O  O  X    Image API  UF_ConvertToBitmap  O  O  O  O  O     UF_SaveImage  O  O  O  O  O     UF_LoadImage  O  O  O  O  O     UF_ReadImage  O  O  O  O  O     UF_ScanImage  O  O  O  O  O    Enroll API  UF_Enroll  O  O  O  O  O     UF_EnrollContinue  O  O  O  O  O     UF_EnrollAfterVerification  O  O  O  O  O     UF_EnrollTemplate  O  O  O  O  O     UF_EnrollMultipleTemplates  O  O  O  O  O     UF_EnrollImage  O  O  O  O  O     UF_SetEnrollCallback  O  O  O  O  O    Identify API  UF_Identify  O  O  O  O  O     UF_IdentifyTemplate  O  O  O  O  O     UF_IdentifyImage  O  O  O  O  O     UF_SetIdentifyCallback  O  O  O  O  O    Verify API  UF_Verify  O  O  O  O  O     UF_VerifyTemplate  O  O  O  O  O     UF_VerifyHostTemplate  O  O  O  O  O     UF_VerifyImage  O  O  O  O  O     UF_SetVerifyCallback  O  O  O  O  O    Delete API  UF_Delete  O  O  O  O  O     UF_DeleteOneTemplate  O  O  O  O  O     UF_DeleteMultipleTemplates  O  O  O  O  O     UF_DeleteAll  O  O  O  O  O     UF_DeleteByScan  O  O  O  O  O     UF_SetDeleteCallback  O  O  O  O  O    I/O API  UF_InitIO  X  X  O  O  X     UF_SetInputFunction  X  X  O  O  X     UF_GetInputFunction  X  X  O  O  X     UF_GetInputStatus  X  X  O  O  X     UF_GetOutputEventList  X  X  O  O  X     UF_ClearAllOutputEvent  X  X  O  O  X     UF_ClearOutputEvent  X  X  O  O  X     UF_SetOutputEvent  X  X  O  O  X     UF_GetOutputEvent  X  X  O  O  X     UF_SetOutputStatus  X  X  O  O  X     UF_SetLegacyWiegandConfig  X  X  O  O  X     UF_GetLegacyWiegandConfig  X  X  O  O  X     UF_MakeIOConfiguration  X  X  O  O  X    GPIO API  UF_GetGPIOConfiguration  O  O  X  X  O     UF_SetInputGPIO  O  O  X  X  O     UF_SetOutputGPIO  O  O  X  X  O     UF_SetSharedGPIO  O  O  X  X  O     UF_DisableGPIO  O  O  X  X  O     UF_ClearAllGPIO  O  O  X  X  O     UF_SetDefaultGPIO  O  O  X  X  O     UF_EnableWiegandInput  O  O  X  X  O     UF_EnableWiegandOutput  O  O  X  X  O     UF_DisableWiegandInput  O  O  X  X  O     UF_DisableWiegandOutput  O  O  X  X  O     UF_MakeGPIOConfiguration  O  O  X  X  O    User Memory API  UF_WriteUserMemory  O  O  O  O  O     UF_ReadUserMemory  O  O  O  O  O    Log and Time Mgmt. API  UF_SetTime  X  X  O  O  X     UF_GetTime  X  X  O  O  X     UF_GetNumOfLog  X  X  O  O  X     UF_ReadLog  X  X  O  O  X     UF_ReadLatestLog  X  X  O  O  X     UF_DeleteOldestLog  X  X  O  O  X     UF_DeleteAllLog  X  X  O  O  X     UF_ClearLogCache  X  X  O  O  X     UF_ReadLogCache  X  X  O  O  X     UF_SetCustomLogField  X  X  O  O  X     UF_GetCustomLogField  X  X  O  O  X    Extended Wiegand API  UF_SetWiegandFormat  X  X  O  O  X     UF_GetWiegandFormat  X  X  O  O  X     UF_SetWiegandIO  X  X  O  O  X     UF_GetWiegandIO  X  X  O  O  X     UF_SetWiegandOption  X  X  O  O  X     UF_GetWiegandOption  X  X  O  O  X     UF_SetAltValue  X  X  O  O  X     UF_ClearAltValue  X  X  O  O  X     UF_GetAltValue  X  X  O  O  X     UF_MakeWiegandConfiguration  X  X  O  O  X    Wiegand Command Card API  UF_AddWiegandCommandCard  X  X  O  O  X     UF_GetWiegandCommandCardList  X  X  O  O  X     UF_ClearAllWiegandCommandCard  X  X  O  O  X    SmartCard API  UF_ReadSmartCard  X  X  X  X  X     UF_ReadSmartCardWithAG  X  X  X  X  X     UF_WriteSmartCard  X  X  X  X  X     UF_WriteSmartCardWithAG  X  X  X  X  X     UF_WriteSmartCardWithEntranceLimit*  X  X  X  X  X     UF_FormatSmartCard  X  X  X  X  X     UF_SetSmartCardMode  X  X  X  X  X     UF_GetSmartCardMode  X  X  X  X  X     UF_ChangePrimaryKey  X  X  X  X  X     UF_ChangeSecondaryKey  X  X  X  X  X     UF_SetKeyOption  X  X  X  X  X     UF_GetKeyOption  X  X  X  X  X     UF_SetCardLayout  X  X  X  X  X     UF_GetCardLayout  X  X  X  X  X     UF_SetSmartCardCallback  X  X  X  X  X    Access Control API  UF_AddTimeSchedule  X  X  X  X  X     UF_GetTimeSchedule  X  X  X  X  X     UF_DeleteTimeSchedule  X  X  X  X  X     UF_DeleteAllTimeSchedule  X  X  X  X  X     UF_AddHoliday  X  X  X  X  X     UF_GetHoliday  X  X  X  X  X     UF_DeleteHoliday  X  X  X  X  X     UF_DeleteAllHoliday  X  X  X  X  X     UF_AddAccessGroup  X  X  X  X  X     UF_GetAccessGroup  X  X  X  X  X     UF_DeleteAccessGroup  X  X  X  X  X     UF_DeleteAllAccessGroup  X  X  X  X  X     UF_SetUserAccessGroup  X  X  X  X  X     UF_GetUserAccessGroup  X  X  X  X  X    Blacklist API  UF_AddBlacklist  X  X  O  O  X     UF_DeleteBlacklist  X  X  O  O  X     UF_GetBlacklist  X  X  O  O  X     UF_DeleteAllBlacklist  X  X  O  O  X    WSQ API  UF_ScanImageEx  X  X  X  O  O     UF_ReadImageEx  X  X  X  O  O     UF_WSQ_Decode  X  X  X  O  O    File System API  UF_ResetSystemConfiguration  X  X  X  X  O     UF_FormatUserDatabase  X  X  X  X  O",
            "title": "2. API Compatibility"
        },
        {
            "location": "/documents/API_Specification/",
            "text": "3. API Specification\n\u00b6\n\n\n3.1. Return Codes\n\u00b6\n\n\nMost APIs in the SDK return UF_RET_CODE. The return codes and their meanings are as follows;\n\n\n\n\n\n\n\n\nCategory\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSuccess\n\n\nUF_RET_SUCCESS\n\n\nThe function succeeds.\n\n\n\n\n\n\nSerial Comm.\n\n\nUF_ERR_CANNOT_OPEN_SEREIAL\n\n\nCannot open the specified serial port.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_SETUP_SERIAL\n\n\nCannot set the baud rate.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_WRITE_SERIAL\n\n\nCannot write data to the serial port.\n\n\n\n\n\n\n\n\nUF_ERR_WRITE_SERIAL_TIMEOUT\n\n\nWrite timeout.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_READ_SERIAL\n\n\nCannot read data from the serial port.\n\n\n\n\n\n\n\n\nUF_ERR_READ_SERIAL_TIMEOUT\n\n\nRead timeout.\n\n\n\n\n\n\n\n\nUF_ERR_CHECKSUM_ERROR\n\n\nReceived packet has wrong checksum.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_SET_TIMEOUT\n\n\nCannot set communication timeout.\n\n\n\n\n\n\nSocket\n\n\nUF_ERR_CANNOT_START_SOCKET\n\n\nCannot initialize the socket interface.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_OPEN_SOCKET\n\n\nCannot open the socket.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_CONNECT_SOCKET\n\n\nCannot connect to the socket.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_READ_SOCKET\n\n\nCannot read data from the socket.\n\n\n\n\n\n\n\n\nUF_ERR_READ_SOCKET_TIMEOUT\n\n\nRead timeout.\n\n\n\n\n\n\n\n\nUF_ERR_CANNOT_WRITE_SOCKET\n\n\nCannot write data to the socket.\n\n\n\n\n\n\n\n\nUF_ERR_WRITE_SOCKET_TIMEOUT\n\n\nWrite timeout.\n\n\n\n\n\n\nProtocol\n\n\nUF_ERR_SCAN_FAIL\n\n\nSensor or fingerprint input has failed.\n\n\n\n\n\n\n\n\nUF_ERR_NOT_FOUND\n\n\nIdentification failed, or the requested data is not found.\n\n\n\n\n\n\n\n\nUF_ERR_NOT_MATCH\n\n\nFingerprint does not match.\n\n\n\n\n\n\n\n\nUF_ERR_TRY_AGAIN\n\n\nFingerprint image is not good.\n\n\n\n\n\n\n\n\nUF_ERR_TIME_OUT\n\n\nTimeout for fingerprint input.\n\n\n\n\n\n\n\n\nUF_ERR_MEM_FULL\n\n\nNo more templates are allowed.\n\n\n\n\n\n\n\n\nUF_ERR_EXIST_ID\n\n\nThe specified user ID already exists.\n\n\n\n\n\n\n\n\nUF_ERR_FINGER_LIMIT\n\n\nThe number of fingerprints enrolled in same ID exceeds its limit.\n\n\n\n\n\n\n\n\nUF_ERR_UNSUPPORTED\n\n\nThe command is not supported.\n\n\n\n\n\n\n\n\nUF_ERR_INVALID_ID\n\n\nThe requested user ID is invalid or missing.\n\n\n\n\n\n\n\n\nUF_ERR_TIMEOUT_MATCH\n\n\nTimeout for fingerprint identification.\n\n\n\n\n\n\n\n\nUF_ERR_BUSY\n\n\nModule is processing another command.\n\n\n\n\n\n\n\n\nUF_ERR_CANCELED\n\n\nThe command is canceled.\n\n\n\n\n\n\n\n\nUF_ERR_DATA_ERROR\n\n\nThe checksum of a data packet is incorrect.\n\n\n\n\n\n\n\n\nUF_ERR_EXIST_FINGER\n\n\nThe finger is already enrolled.\n\n\n\n\n\n\n\n\nUF_ERR_DURESS_FINGER\n\n\nA duress finger is detected.\n\n\n\n\n\n\n\n\nUF_ERR_CARD_ERROR\n\n\nCannot read a smart card.\n\n\n\n\n\n\n\n\nUF_ERR_LOCKED\n\n\nModule is locked.\n\n\n\n\n\n\n\n\nUF_ERR_ACCESS_NOT_GRANTED\n\n\nAccess is not granted by time schedule and access group.\n\n\n\n\n\n\n\n\nUF_ERR_REJECTED_ID\n\n\nAuthentication type of the user is UF_AUTH_REJECT or the ID is in the blacklist.\n\n\n\n\n\n\n\n\nUF_ERR_FAKE_DETECTED\n\n\nScanned finger is determined as a fake finger.\n\n\n\n\n\n\n\n\nUF_ERR_EXCEED_ENTRANCE_LIMIT\n\n\nEntrance limit is exceeded.\n\n\n\n\n\n\nApplication\n\n\nUF_ERR_OUT_OF_MEMORY\n\n\nOut of memory.\n\n\n\n\n\n\n\n\nUF_ERR_INVALID_PARAMETER\n\n\nInvalid parameter.\n\n\n\n\n\n\n\n\nUF_ERR_FILE_IO\n\n\nFile I/O failed\n\n\n\n\n\n\n\n\nUF_ERR_INVALID_FILE\n\n\nThe configuration or DB file is invalid.\n\n\n\n\n\n\n\n\n\n\n3.2. Serial Communication API\n\u00b6\n\n\nTo communicate with SFM modules, users should configure the serial port first.\n\n\n\n\nUF_InitCommPort\n: configures serial port parameters.\n\n\nUF_CloseCommPort\n: closes the serial port.\n\n\nUF_Reconnect\n: resets system parameters and IO settings.\n\n\nUF_SetBaudrate\n: changes the baud rate.\n\n\nUF_SetAsciiMode\n: changes the packet translation mode.\n\n\n\n\n\n\nUF_InitCommPort\n\u00b6\n\n\nOpens a serial port and configures communication parameters. This function should be called first before calling any other APIs.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_InitCommPort\n(\n \nconst\n \nchar\n*\n \ncommPort\n,\n \nint\n \nbaudrate\n,\n \nBOOL\n \nasciiMode\n \n)\n\n\n\n\nParameters\n\n\ncommPort\n\nPointer to a null-terminated string that specifies the name of the serial port.\n\n\nbaudrate\n\nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps (230400bps and 460800bps are available in later version of 5.0). The default setting of SFM modules is 115200bps.\n\n\nasciiMode\n\nDetermines the packet translation mode. If it is set to TRUE, the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\nExample\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_InitCommPort\n(\n \n\u201c\nCOM1\n\u201d\n,\n \n115200\n,\n \nFALSE\n \n);\n\n\n\n\n\n\n\n\nUF_CloseCommPort\n\u00b6\n\n\nCloses the serial port opened by \nUF_InitCommPort\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_CloseCommPort\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_Reconnect\n\u00b6\n\n\nTo improve communication efficiency, the SDK caches basic information of a module such as system parameters and I/O settings. \nUF_Reconnect\n clears this cached information. When changing the modules connected to the serial port, this function should be called.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_Reconnect\n()\n\n\n\n\nParameters\n \n\nNone  \n\n\nReturn Values\n\nNone  \n\n\n\n\n\n\nUF_SetBaudrate\n\u00b6\n\n\nChanges the baud rate.  \n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetBaudrate\n(\n \nint\n \nbaudrate\n \n)\n\n\n\n\nParameters\n\n\nbaudrate\n\nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps. The default setting of SFM modules is 115200bps.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetAsciiMode\n\u00b6\n\n\nChanges the packet translation mode.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetAsciiMode\n(\n \nBOOL\n \nasciiMode\n \n)\n\n\n\n\nParameters\n\n\nasciiMode\n\nTRUE for ascii format, FALSE for binary format.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.3. Socket API\n\u00b6\n\n\nIn addition to serial ports, users can connect to the module by Ethernet-to-Serial converters. In this case, socket API should be used in place of serial API.\n\n\n\n\nUF_InitSocket\n: opens a socket and connects to the specified IP address.\n\n\nUF_CloseSocket\n: closes the socket.\n\n\n\n\n\n\nUF_InitSocket\n\u00b6\n\n\nInitializes the socket interface and connects to the module with specified IP address.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_InitSocket\n(\n \nconst\n \nchar\n*\n \ninetAddr\n,\n \nint\n \nport\n,\n \nBOOL\n \nasciiMode\n \n)\n \n\n\n\n\nParameters\n\n\ninetAddr\n\nIP address of the Ethernet-to-Serial converter.\n\n\nport\n\nTCP port of the socket interface.\n\n\nasciiMode\n\nDetermines the packet translation mode. If it is set to \nTRUE\n, the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_InitSocket\n(\n \n\u201c\n192.168.1.41\n\u201d\n,\n \n1470\n,\n \nFALSE\n \n);\n\n\n\n\n\n\nUF_CloseSocket\n\u00b6\n\n\nCloses the socket interface.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_CloseSocket\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.4. Low-Level Packet API\n\u00b6\n\n\nThese functions provide direct interface to the low-level packet exchanges. In most cases, users need not to call these functions directly. Command API and other high level APIs are implemented on top of this API.\nPacket API also let users set callback functions for data transfer. Examples of using these callback functions for GUI application can be found in UniFingerUI V4.0 source codes.\n\n\n\n\nUF_SendPacket\n: sends a 13 byte packet.\n\n\nUF_SendNetworkPacket\n: sends a 15 byte network packet.\n\n\nUF_ReceivePacket\n: receives a 13 byte packet.\n\n\nUF_ReceiveNetworkPacket\n: receives a 15 byte network packet.\n\n\nUF_SendRawData\n: sends raw data.\n\n\nUF_ReceiveRawData\n: receives raw data.\n\n\nUF_SendDataPacket\n: sends data using Extended Data Transfer Protocol.\n\n\nUF_ReceiveDataPacket\n: receives data using Extended Data Transfer Protocol.\n\n\nUF_SetSendPacketCallback\n: sets the callback function of sending packets.\n\n\nUF_SetReceivePacketCallback\n: sets the callback function of receiving packets.\n\n\nUF_SetSendDataPacketCallback\n: sets the callback function of sending data packets.\n\n\nUF_SetReceiveDataPacketCallback\n: sets the callback function of receiving data packets.\n\n\nUF_SetSendRawDataCallback\n: sets the callback function of sending raw data.\n\n\nUF_SetReceiveRawDataCallback\n: sets the callback function of receiving raw data.\n\n\nUF_SetDefaultPacketSize\n: sets the size of data packets.\n\n\nUF_GetDefaultPacketSize\n: gets the size of data packets.\n\n\n\n\n\n\nUF_SendPacket\n\u00b6\n\n\nSends a 13 byte packet to the module. The packet is composed as follows;\n\n\n\n\n\n\n\n\nStart code\n\n\nCommand\n\n\nParam\n\n\nSize\n\n\nFlag/Error\n\n\nChecksum\n\n\nEnd code\n\n\n\n\n\n\n\n\n\n\n1byte\n\n\n1byte\n\n\n4bytes\n\n\n4bytes\n\n\n1byte\n\n\n1byte\n\n\n1byte\n\n\n\n\n\n\n\n\n\n\nStart code\n: 1 byte. Indicates the beginning of a packet. It always should be 0x40.\n\n\nCommand\n: 1 byte. Refer to the Packet Protocol Manual for available commands.\n\n\nParam\n: 4 bytes. The meaning of this field varies according to each command.\n\n\nSize\n: 4 bytes. The meaning of this field varies according to each command.\n\n\nFlag/Error\n: 1 byte. Indicates flag data in the request packet, and error code in the response packet.\n\n\nChecksum\n: 1 byte. Checks the validity of a packet. Checksum is a remainder of the sum of each field, from the Start code to Flag/Error, divided by 256 (0x100).\n\n\nEnd code\n: 1 byte. Indicates the end of a packet. It always should be 0x0A. It is also used as a code indicating the end of binary data such as fingerprint templates.  \n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SendPacket\n(\n \nBYTE\n \ncommand\n,\n \nUINT32\n \nparam\n,\n \nUINT32\n \nsize\n,\n \nBYTE\n \nflag\n,\n \nint\n \ntimeout\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\n\nparam\n\nParam field of a packet.\n\n\nsize\n\nSize field of a packet.\n\n\nflag\n\nFlag field of a packet.\n\n\ntimeout\n\nSets the timeout in milliseconds. If sending does not complete within this limit, \nUF_ERR_WRITE_SERIAL_TIMEOUT\n will be returned.\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\n// To send ES command with user ID 10 and ADD_NEW(0x79) option,\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SendPacket\n(\n \nUF_COM_ES\n,\n \n10\n,\n \n0\n,\n \n0x79\n,\n \n2000\n \n);\n\n\n\nIf\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n\n\n{\n\n\n    \nReturn\n \nresult\n;\n\n\n}\n\n\n\n\n\n\n\n\nUF_SendNetworkPacket\n\u00b6\n\n\nSends a 15 byte network packet to the specified module. In order to support RS422 or RS485 network interfaces, SFM modules support Network Packet Protocol. Network packet is composed of 15 bytes, whose start code is different from the standard packet, and includes 2 bytes for terminal ID. The terminal ID is equal to the lower 2 bytes of Module ID of system parameter.\n\n\n\n\n\n\n\n\nField\n\n\nStart code\n\n\nTerminal ID\n\n\nCommand\n\n\nParam\n\n\nSize\n\n\nFlag / Error\n\n\nChecksum\n\n\nEnd code\n\n\n\n\n\n\n\n\n\n\nBytes\n\n\n1\n\n\n2\n\n\n1\n\n\n4\n\n\n4\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\n\nValue\n\n\n0x41\n\n\n1 ~ 0xFFFF\n\n\n\n\n\n\nSame as standard protocol\n\n\n\n\nChecksum of 13 bytes\n\n\n0x0A\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nUF_SendNetworkPacket\n(\n \nBYTE\n \ncommand\n,\n \nUSHORT\n \nterminalID\n,\n \nUINT32\n \nparam\n,\n \nUINT32\n \nsize\n,\n \nBYTE\n \nflag\n,\n \nint\n \ntimeout\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\n\nterminalID\n\nSpecifies the terminal ID of the receiving module.\n\n\nparam\n\nParam field of a packet.\n\n\nsize\n\nSize field of a packet.\n\n\nflag\n\nFlag field of a packet.\n\n\ntimeout\n\nSets the timeout in milliseconds. If sending does not complete within this limit, \nUF_ERR_WRITE_SERIAL_TIMEOUT\n will be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReceivePacket\n\u00b6\n\n\nReceives a 13 byte packet from the module. Most commands of Packet Protocol can be implemented by a pair of \nUF_SendPacket\n/\nUF_ReceivePacket\n or \nUF_SendNetworkPacket\n/\nUF_ReceiveNetworkPacket\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReceivePacket\n(\n \nBYTE\n*\n \npacket\n,\n \nint\n \ntimeout\n \n)\n\n\n\n\nParameters\n\n\npacket\n\nPointer to the 13 byte packet.\n\n\ntimeout\n\nSets the timeout in milliseconds. If receiving does not complete within this limit, \nUF_ERR_READ_SERIAL_TIMEOUT\n will be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ReceiveNetworkPacket\n\u00b6\n\n\nReceives a 15 byte network packet from the specified module.\n\n\n\n\nDescription\n\n\nUF_ReceiveNetworkPacket\n(\n \nBYTE\n*\n \npacket\n,\n \nint\n \ntimeout\n \n)\n\n\n\n\nParameters\n\n\npacket\n\nPointer to the 15 byte packet.\n\n\ntimeout\n\nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SendRawData\n\u00b6\n\n\nSome commands such as \nET\n(Enroll Template) and \nIT\n(Identify Template) send additional data after the 13/15 byte request packet. \nUF_SendRawData\n is used in these cases for sending the data.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SendRawData\n(\n \nBYTE\n*\n \nbuf\n,\n \nUINT32\n \nsize\n,\n \nint\n \ntimeout\n \n)\n\n\n\n\nParameters\n\n\nbuf\n\nPointer to a data buffer.\n\n\nsize\n\nNumber of bytes to be sent.\n\n\ntimeout\n\nSets the timeout in milliseconds. If sending does not complete within this limit, \nUF_ERR_WRITE_SERIAL_TIMEOUT\n will be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_ReceiveRawData\n\u00b6\n\n\nSome commands such as \nST\n(Scan Template) and \nRT\n(Read Template) return additional data after the 13/15 byte response packet. \nUF_ReceiveRawData\n is used in these cases for receiving the data.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReceiveRawData\n(\n \nBYTE\n*\n \nbuf\n,\n \nUINT32\n \nsize\n,\n \nint\n \ntimeout\n,\n \nBOOL\n \ncheckEndCode\n \n)\n\n\n\n\nParameters\n\n\nbuf\n\nPointer to a data buffer.\n\n\nsize\n\nNumber of bytes to be received.\n\n\ntimeout\n\nSets the timeout in milliseconds. If receiving does not complete within this limit, \nUF_ERR_READ_SERIAL_TIMEOUT\n will be returned.\n\n\ncheckEndCode\n\nData transfer ends with \u20180x0a\u2019. If this parameter is FALSE, the function returns without checking the end code.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SendDataPacket\n\u00b6\n\n\nSends data using Extended Data Transfer Protocol. Dividing large data into small blocks can reduce communication errors between the host and the module. Extended Data Transfer Protocol is an extension of Packet Protocol to provide a reliable and customizable communication for large data. In Extended Data Transfer Protocol, data is divided into multiple data packets. And a data packet consists of fixed-length header, variable-length data body, and 4 byte checksum. Commands which use the Extended Data Transfer Protocols are \nEIX\n, \nVIX\n, \nIIX\n, \nRIX\n, \nSIX\n, and \nUG\n.\n\n\n\n\nDescription\n\n\nUF_SendDataPacket\n(\n \nBYTE\n \ncommand\n,\n \nBYTE\n*\n \nbuf\n,\n \nUINT32\n \ndataSize\n,\n \nUINT32\n \ndataPacketSize\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Valid commands are \nEIX\n, \nVIX\n, \nIIX\n, \nRIX\n, \nSIX\n, and \nUG\n.\n\n\nbuf\n\nPointer to a data buffer.\n\n\ndataSize\n\nNumber of bytes to be sent.\n\n\ndataPacketSize\n\nSize of data packet. For example, if dataSize is 16384 bytes and dataPacketSize is 4096 bytes, the data will be divided into 4 data packets.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReceiveDataPacket\n\u00b6\n\n\nReceives data using Extended Data Transfer Protocol. The size of data packet should be specified before calling this function.\n\n\n\n\nDescription\n\n\nUF_ReceiveDataPacket\n(\n \nBYTE\n \ncommand\n,\n \nBYTE\n*\n \nbuf\n,\n \nUINT32\n \ndataSize\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Valid commands are \nEIX\n, \nVIX\n, \nIIX\n, \nRIX\n, \nSIX\n, and \nUG\n.\n\n\nbuf\n\nPointer to a data buffer.\n\n\ndataSize\n\nNumber of bytes to be received.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetSendPacketCallback\n\u00b6\n\n\nIf \nSendPacketCallback\n is specified, it is called after sending a packet successfully. The argument of the callback is the pointer to the packet.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetSendPacketCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n*\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone  \n\n\nExample\n\nSee CMainFrame::SendPacketCallback in UniFingerUI source codes.  \n\n\n\n\n\n\nUF_SetReceivePacketCallback\n\u00b6\n\n\nIf \nReceivePacketCallback\n is specified, it is called after receiving a packet successfully. The argument of the callback is the pointer to the received packet.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetReceivePacketCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n*\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone\n\n\nExample\n\nSee CMainFrame::ReceivePacketCallback in UniFingerUI source codes.\n\n\n\n\n\n\nUF_SetSendDataPacketCallback\n\u00b6\n\n\nIf \nSendDataPacketCallback\n is specified, it is called after sending a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.\n\n\n\n\nDescription\n\n\nUF_SetSendDataPacketCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nint\n \nindex\n,\n \nint\n \nnumOfPacket\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone  \n\n\nExample\n\nSee CMainFrame::DataPacketCallback in UniFingerUI source codes.\n\n\n\n\n\n\nUF_SetReceiveDataPacketCallback\n\u00b6\n\n\nIf \nReceiveDataPacketCallback\n is specified, it is called after receiving a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetReceiveDataPacketCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nint\n \nindex\n,\n \nint\n \nnumOfPacket\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone\n\n\nExample\n\nSee CMainFrame::DataPacketCallback in UniFingerUI source codes.\n\n\n\n\n\n\nUF_SetSendRawDataCallback\n\u00b6\n\n\nIf \nSendRawDataCallback\n is specified, it is called during sending raw data. The argument of the callback is the written length and the total length of data.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetSendRawDataCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nint\n \nwrittenLen\n,\n \nint\n \ntotalSize\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone\n\n\nExample\n\nSee CMainFrame::RawDataCallback in UniFingerUI source codes.\n\n\n\n\n\n\nUF_SetReceiveRawDataCallback\n\u00b6\n\n\nIf \nReceiveRawDataCallback\n is specified, it is called during receiving data. The argument of the callback is the read length and the total length of data.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetReceiveRawDataCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nint\n \nreadLen\n,\n \nint\n \ntotalSize\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\nSee CMainFrame::RawDataCallback in UniFingerUI source codes.\n\n\n\n\n\n\nUF_SetDefaultPacketSize\n\u00b6\n\n\nSets the size of data packets used in Extended Data Transfer protocol. The default value is 4096. When BEACon is used as an Ethernet-to-Serial converter, this value should not be larger than 256.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetDefaultPacketSize\n(\n \nint\n \ndefaultSize\n \n)\n\n\n\n\nParameters\n\n\ndefaultSize\n\nSize of data packet.\n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_GetDefaultPacketSize\n\u00b6\n\n\nReturns the size of data packet used in Extended Data Transfer protocol.\n\n\n\n\nDescription\n\n\nint\n \nUF_GetDefaultPacketSize\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nThe size of data packet.\n\n\n\n\n\n\n3.5. Generic Command API\n\u00b6\n\n\nThe commands defined in the Packet Protocol Manual can be classified into several categories according to the types of packet exchange. Generic Command API provides functions which encapsulate these categories. Like low-level Packet API, users need not to call these functions directly. Most commands have corresponding high-level API in the SDK.\n\n\n\n\nUF_Command\n: encapsulates the commands composed of one request packet and one response packet.\n\n\nUF_CommandEx\n: encapsulates the commands composed of one request packet and multiple response packets.\n\n\nUF_CommandSendData\n: encapsulates the commands which send additional data after a request packet.\n\n\nUF_CommandSendDataEx\n: encapsulates the commands which send additional data and have multiple response packets.\n\n\nUF_Cancel\n: cancels the previously issued command.\n\n\nUF_SetProtocol\n: sets the type of packet protocol.\n\n\nUF_GetProtocol\n: gets the type of packet protocol.\n\n\nUF_GetModuleID\n: gets the module ID.\n\n\nUF_SetGenericCommandTimeout\n: sets the timeout for generic commands.\n\n\nUF_SetInputCommandTimeout\n: sets the timeout for commands which require user inputs.\n\n\nUF_GetGenericCommandTimeout\n: gets the timeout for generic commands.\n\n\n'UF_GetInputCommandTimeout`: gets the timeout for commands which require user inputs.\n\n\nUF_SetNetworkDelay\n: sets the delay for the Network Packet Protocol.\n\n\nUF_GetNetworKDelay\n: gets the delay for the Network Packet Protocol.\n\n\n\n\n\n\nUF_Command\n\u00b6\n\n\nEncapsulates the commands composed of one request packet and one response packet. The majority of commands can be implemented using \nUF_Command\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Command\n(\n \nBYTE\n \ncommand\n,\n \nUINT32\n*\n \nparam\n,\n \nUINT32\n*\n \nsize\n,\n \nBYTE\n*\n \nflag\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.  \n\n\nReturn Values\n\nIf packets are transferred successfully, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code. \nUF_RET_SUCCESS\n only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\nExample\n\n\n// To read Timeout(0x62) system parameter,\n\n\nUINT32\n \nparam\n \n=\n \n0\n;\n\n\nUINT32\n \nsize\n \n=\n \n0\n;\n\n\nBYTE\n \nflag\n \n=\n \n0x62\n;\n\n\nUINT32\n \ntimeout\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_Command\n(\n \nUF_COM_SR\n,\n \n&\nparam\n,\n \n&\nsize\n,\n \n&\nflag\n \n);\n\n\n\nIf\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n \n// communication error\n\n\n{\n\n\n    \nreturn\n \nresult\n;\n\n\n}\n\n\nIf\n(\n \nflag\n \n!=\n \nUF_PROTO_RET_SUCCESS\n \n)\n \n// protocol error\n\n\n{\n\n\n    \nreturn\n \nUF_GetErrorCode\n(\n \nresult\n \n);\n\n\n}\n\n\n// succeed\n\n\ntimeout\n \n=\n \nsize\n;\n\n\n\n\n\n\n\n\nUF_CommandEx\n\u00b6\n\n\nEncapsulates the commands composed of one request packet and multiple response packets. Command such as \nES\n(Enroll) and \nIS\n(Identify) can have more than one response packet. To handle these cases, \nUF_CommandEx\n requires a message callback function, which should return TRUE when the received packet is the last one.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_CommandEx\n(\n \nBYTE\n \ncommand\n,\n \nUINT32\n*\n \nparam\n,\n \nUINT32\n*\n \nsize\n,\n \nBYTE\n*\n \nflag\n,\n \nBOOL\n \n(\n*\nmsgCallback\n)(\nBYTE\n)\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.\n\n\nmsgCallback\n\nPointer to the callback function. This callback is called when a response packet is received. If the callback return \nTRUE\n, \nUF_CommandEx\n will return immediately. If the callback return \nFALSE\n, \nUF_CommandEx\n will wait for another response packet.\n\n\nReturn Values\n\nIf packets are transferred successfully, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\nExample\n  \n\n\n// UF_Identify() is implemented as follows;\n\n\n/**\n\n\n* Message callback for identification\n\n\n*/\n\n\nBOOL\n \nUF_IdentifyMsgCallback\n(\n \nBYTE\n \nerrCode\n \n)\n\n\n{\n\n\n    \nif\n(\n \nerrCode\n \n==\n \nUF_PROTO_RET_SCAN_SUCCESS\n \n)\n\n\n    \n{\n\n\n        \nif\n(\n \ns_IdentifyCallback\n \n)\n\n\n        \n{\n\n\n            \n(\n*\ns_IdentifyCallback\n)(\n \nerrCode\n \n);\n\n\n        \n}\n\n\n        \nreturn\n \nFALSE\n;\n\n\n    \n}\n\n\n    \nelse\n\n\n    \n{\n\n\n        \nreturn\n \nTRUE\n;\n\n\n    \n}\n\n\n}\n\n\n/**\n\n\n* Identify\n\n\n*/\n\n\nUF_RET_CODE\n \nUF_Identify\n(\n \nUINT32\n*\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n{\n\n\n    \nUINT32\n \nparam\n \n=\n \n0\n;\n\n\n    \nUINT32\n \nsize\n \n=\n \n0\n;\n\n\n    \nBYTE\n \nflag\n \n=\n \n0\n;\n\n\n\n    \nint\n \nresult\n \n=\n \nUF_CommandEx\n(\n \nUF_COM_IS\n,\n \n&\nparam\n,\n \n&\nsize\n,\n \n&\nflag\n,\n\n\n    \nUF_IdentifyMsgCallback\n \n);\n\n\n\n    \nif\n(\n \nresult\n \n!=\n \nUF_RET_SUCCESS\n \n)\n\n\n    \n{\n\n\n        \nreturn\n \nresult\n;\n\n\n    \n}\n\n\n    \nelse\n \nif\n(\n \nflag\n \n!=\n \nUF_PROTO_RET_SUCCESS\n \n)\n\n\n    \n{\n\n\n        \nreturn\n \nUF_GetErrorCode\n(\n \nflag\n \n);\n\n\n    \n}\n\n\n    \n*\nuserID\n \n=\n \nparam\n;\n\n\n    \n*\nsubID\n \n=\n \nsize\n;\n\n\n\n    \nreturn\n \nUF_RET_SUCCESS\n;\n\n\n}\n\n\n\n\n\n\n\n\nUF_CommandSendData\n\u00b6\n\n\nEncapsulates the commands which send additional data after a request packet. For example, \nGW\n(Write GPIO Configuration) command should send configuration data after the request packet.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_CommandSendData\n(\n \nBYTE\n \ncommand\n,\n \nUINT32\n*\n \nparam\n,\n \nUINT32\n*\n \nsize\n,\n \nBYTE\n*\n \nflag\n,\n \nBYTE\n*\n \ndata\n,\n \nUINT32\n \ndataSize\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.\n\n\ndata\n\nPointer to the data buffer to be sent.\n\n\ndataSize\n\nNumber of bytes to be sent.  \n\n\nReturn Values\n\nIf packets are transferred successfully, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code. \nUF_RET_SUCCESS\n only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\n\n\n\n\nUF_CommandSendDataEx\n\u00b6\n\n\nEncapsulates the commands which send additional data and have multiple response packets. For example, \nET\n(Enroll Template) command sends template data after request packet and can have multiple response packets.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_CommandSendDataEx\n(\n \nBYTE\n \ncommand\n,\n \nUINT32\n*\n \nparam\n,\n \nUINT32\n*\n \nsize\n,\n \nBYTE\n*\n \nflag\n,\n \nBYTE\n*\n \ndata\n,\n \nUINT32\n \ndataSize\n,\n \nBOOL\n \n(\n*\nmsgCallback\n)(\nBYTE\n),\n \nBOOL\n \nwaitUserInput\n \n)\n\n\n\n\nParameters\n\n\ncommand\n\nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.\n\n\nparam\n\nParam field of a packet. This parameter is used both for input and output.\n\n\nsize\n\nSize field of a packet. This parameter is used both for input and output.\n\n\nflag\n\nFlag field of a packet. This parameter is used both for input and output.\n\n\ndata\n\nPointer to the data buffer to be sent.\n\n\ndataSize\n\nNumber of bytes to be sent.\n\n\nmsgCallback\n\nPointer to the callback function. This callback is called when a response packet is received. If the callback return \nTRUE\n, \nUF_CommandSendDataEx\n will return immediately. If the callback return \nFALSE\n, \nUF_CommandSendDataEx\n will wait for another response packet.\n\n\nwaitUserInput\n\n\nTRUE\n if the command needs user input. Otherwise, \nFALSE\n.  \n\n\nReturn Values\n\nIf packets are transferred successfully, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.\n\n\n\n\n\n\nUF_Cancel\n\u00b6\n\n\nCancels the command which is being processed by the module. When the module is executing a command which needs user input to proceed, the status of the module will be changed to \nUF_SYS_BUSY\n. If users want to execute another command before finishing the current one, they can explicitly cancel it by this function.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Cancel\n(\n \nBOOL\n \nreceivePacket\n \n)\n\n\n\n\nParameters\n\n\nreceivePacket\n\nIf TRUE, \nUF_Cancel\n waits until the response packet is received. If \nFALSE\n, \nUF_Cancel\n returns immediately after sending the request packet.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetProtocol\n\u00b6\n\n\nSelects packet protocol. If the host connects to the single module through RS232 interface, use UF_SINGLE_PROTOCOL. If there are multiple modules in RS422/485 networks, use UF_NETWORK_PROTOCOL. The protocol should also be compatible with the Network Mode system parameter.\n\n\n\n\n\n\n\n\nNetwork Mode\n\n\n\n\nSupported Protocol\n\n\n\n\n\n\n\n\n\n\n\n\n13 byte Packet Protocol\n\n\n15 byte Network Packet Protocol\n\n\n\n\n\n\nSingle(0x30)\n\n\nO\n\n\nO\n\n\n\n\n\n\nNetwork (0x31/0x32)\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetProtocol\n(\n \nUF_PROTOCOL\n \nprotocol\n,\n \nUINT32\n \nmoduleID\n \n)\n\n\n\n\nParameters\n\n\nprotocol\n\n\nUF_SINGLE_PROTOCOL\n for 13 byte packet protocol, \nUF_NETWORK_PROTOCOL\n for 15 byte network packet protocol.\n\n\nmoduleID\n\nSpecifies the ID of the module. This parameter is applicable when the protocol is set to \nUF_NETWORK_PROTOCOL\n.\n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_GetProtocol\n\u00b6\n\n\nGets the selected protocol.\n\n\n\n\nDescription\n\n\nUF_PROTOCOL\n \nUF_GetProtocol\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\n\nUF_SINGLE_PROTOCOL\n or \nUF_NETWORK_PROTOCOL\n.\n\n\n\n\n\n\nUF_GetModuleID\n\u00b6\n\n\nGets the ID of the module.\n\n\n\n\nDescription\n\n\nUINT32\n \nUF_GetModuleID\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nID of the module.\n\n\n\n\n\n\nUF_SetGenericCommandTimeout\n\u00b6\n\n\nSets the timeout for generic commands. The default timeout is 2,000ms.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetGenericCommandTimeout\n(\n \nint\n \ntimeout\n \n)\n\n\n\n\nParameters\n\n\ntimeout\n\nSpecifies the timeout period in milliseconds.  \n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_SetInputCommandTimeout\n\u00b6\n\n\nSets the timeout for commands which need user input. The default timeout is 10,000ms.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetInputCommandTimeout\n(\n \nint\n \ntimeout\n \n)\n\n\n\n\nParameters\n\n\ntimeout\n\nSpecifies the timeout period in milliseconds.\n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_GetGenericCommandTimeout\n\u00b6\n\n\nGets the timeout for generic commands.\n\n\n\n\nDescription\n\n\nint\n \nUF_GetGenericCommandTimeout\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nTimeout for generic commands.\n\n\n\n\n\n\nUF_GetInputCommandTimeout\n\u00b6\n\n\nGets the timeout for commands which need user input.\n\n\n\n\nDescription\n\n\nint\n \nUF_GetInputCommandTimeout\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nTimeout for commands which need user input.\n\n\n\n\n\n\nUF_SetNetworkDelay\n\u00b6\n\n\nIn half duplex mode, the same communication lines are shared for sending and receiving data. To prevent packet collisions on the shared line, there should be some delay between receiving and sending data. The default delay is set to 40ms. This value can be optimized for specific environments.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetNetworkDelay\n(\n \nint\n \ndelay\n \n)\n\n\n\n\nParameters\n\n\ndelay\n\nSpecified the delay in milliseconds.\n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_GetNetworkDelay\n\u00b6\n\n\nGets the network delay.\n\n\n\n\nDescription\n\n\nint\n \nUF_GetNetworkDelay\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nDelay in milliseconds.\n\n\n\n\n\n\n3.6. Module API\n\u00b6\n\n\nThese functions provide basic information about the module.\n\n\n\n\nUF_GetModuleInfo\n: gets the basic module information.\n\n\nUF_GetModuleString\n: gets a string describing the module.\n\n\nUF_SearchModule\n: searches a module and find out communication parameters.\n\n\nUF_SearchModuleID\n: searches an ID of a module.\n\n\nUF_SearchModuleBySocket\n: searches a module through socket interface.\n\n\nUF_SearchModuleIDEx\n: searches multiple models in a network.\n\n\nUF_CalibrateSensor\n: calibrates a sensor.\n\n\nUF_Upgrade\n: upgrades firmware.\n\n\nUF_Reset\n: resets the module.\n\n\nUF_Lock\n: locks the module.\n\n\nUF_Unlock\n: unlocks the module.\n\n\nUF_ChangePassword\n: changes the master password of a module.\n\n\nUF_PowerOff\n : Programmatically turns off a module (SFM4000 only).\n\n\n\n\n\n\nUF_GetModuleInfo\n\u00b6\n\n\nRetrieves the type, version and sensor information of the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetModuleInfo\n(\n \nUF_MODULE_TYPE\n*\n \ntype\n,\n \nUF_MODULE_VERSION\n*\n \nversion\n,\n \nUF_MODULE_SENSOR\n*\n \nsensorType\n \n)\n\n\n\n\nParameters\n\n\ntype\n\nAvailable types are as follows;\n\n\n\n\n\n\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_MODULE_3000\n\n\nSFM 3000 series modules\n\n\n\n\n\n\nUF_MODULE_3500\n\n\nSFM 3500 series modules\n\n\n\n\n\n\nUF_MODULE_4000\n\n\nSFM 4000 series modules\n\n\n\n\n\n\nUF_MODULE_5000\n\n\nSFM_5000 series modules\n\n\n\n\n\n\nUF_BIOENTRY_SMART\n\n\nBioEntry Smart\n\n\n\n\n\n\nUF_BIOENTRY_PASS\n\n\nBioEntry Pass\n\n\n\n\n\n\n\n\nversion\n\nVersion number of the module.\n\n\nsensorType\n\nSensor type of the module.\n\n\n\n\n\n\n\n\nValue\n\n\nSensor Type\n\n\n\n\n\n\n\n\n\n\nUF_SENSOR_FL\n\n\nAuthentec AF-S2\n\n\n\n\n\n\nUF_SENSOR_FC\n\n\nAtmel FingerChip\n\n\n\n\n\n\nUF_SENSOR_OP\n\n\nOptical Sensor I (OP2/OP3/OP4)\n\n\n\n\n\n\nUF_SENSOR_TC\n\n\nUPEK TouchChip (TC1/TC2/TC2S)\n\n\n\n\n\n\nUF_SENSOR_OC2\n\n\nOptical Sensor II (OC2/OD)\n\n\n\n\n\n\nUF_SENSOR_TS\n\n\nUPEK TouchStrip (TS4)\n\n\n\n\n\n\nUF_SENSOR_OL\n\n\nOptical Sensor III (OL)\n\n\n\n\n\n\nUF_SENSOR_OH\n\n\nOptical Sensor IV (OH)\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetModuleString\n\u00b6\n\n\nRetrieves a string that describes the module information. This function should be called after \nUF_GetModuleInfo\n.\n\n\n\n\nDescription\n\n\nchar\n*\n \nUF_GetModuleString\n(\n \nUF_MODULE_TYPE\n \ntype\n,\n \nUF_MODULE_VERSION\n \nversion\n,\n \nUF_MODULE_SENSOR\n \nsensorType\n \n)\n\n\n\n\nParameters\n\n\ntype\n\nSpecifies the type of the module.\n\n\nversion\n\nSpecifies the version number of the module.\n\n\nsensorType\n\nSpecifies the sensor type of the module.  \n\n\nReturn Values\n\nNull-terminated string that describes the module information. This pointer is a static data in the SDK. So, it should not be shared or freed by applications.\n\n\n\n\n\n\nUF_SearchModule\n\u00b6\n\n\nSearch a module connected to the specified serial port. \nUF_SearchModule\n tries all combinations of communication parameters. If it finds any module on the serial port, it returns the communication parameters and its module ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SearchModule\n(\n \nconst\n \nchar\n*\n \nport\n,\n \nint\n*\n \nbaudrate\n,\n \nBOOL\n*\n \nasciiMode\n,\n \nUF_PROTOCOL\n*\n \nprotocol\n,\n \nUINT32\n*\n \nmoduleID\n,\n \nvoid\n \n(\n*\ncallback\n)(\n \nconst\n \nchar\n*\n \ncomPort\n,\n \nint\n \nbaudrate\n \n)\n \n)\n\n\n\n\nParameters\n\n\nport\n\nSerial port.\n\n\nbaudrate\n\nPointer to the baud rate to be returned.\n\n\nasciiMode\n \n\nPointer to the packet translation mode to be returned.\n\n\nprotocol\n\nPointer to the protocol type to be returned.\n\n\nmoduleID\n\nPointer to the module ID to be returned.\n\n\ncallback\n\nPointer to the callback function. The callback function can be used for displaying the progress of the search. This parameter can be NULL.  \n\n\nReturn Values\n\nIf it finds a module, return \nUF_RET_SUCCESS\n. If the search fails, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_SearchModuleID\n\u00b6\n\n\nUntil firmware V1.3, SFM modules respond both standard and network packets regardless of Network Mode system parameter. However, since firmware V1.4, the modules only respond to 15 byte network packets if Network Mode system parameter is not Single(0x30). So, if users don\u2019t know ID of the module, they cannot communicate with it in network environments. \nUF_SerachModuleID\n can be used to retrieve the ID of the module in these cases. Refer to ID command section in the Packet Protocol Manual for details.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SearchModuleID\n(\n \nUINT32\n*\n \nmoduleID\n \n)\n\n\n\n\nParameters\n\n\nmoduleID\n\nPointer to the module ID to be returned.\n\n\nReturn Values\n\nIf it finds a module, return \nUF_RET_SUCCESS\n. If the search fails, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SearchModuleBySocket\n\u00b6\n\n\nSearch a module connected to the specified IP address. If it finds any module, it will return the communication parameters and the module ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SearchModuleBySocket\n(\n \nconst\n \nchar\n*\n \ninetAddr\n,\n \nint\n \ntcpPort\n,\n \nBOOL\n*\n \nasciiMode\n,\n \nUF_PROTOCOL\n*\n \nprotocol\n,\n \nUINT32\n*\n \nmoduleID\n \n)\n\n\n\n\nParameters\n\n\ninetAddr\n\nIP address.\n\n\ntcpPort\n\nTCP port.\n\n\nasciiMode\n\nPointer to the packet translation mode to be returned.\n\n\nprotocol\n\nPointer to the protocol type to be returned.\n\n\nmoduleID\n\nPointer to the module ID to be returned.  \n\n\nReturn Values\n\nIf it finds a module, return \nUF_RET_SUCCESS\n. If the search fails, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SearchModuleIDEx\n\u00b6\n\n\nUF_SearchModuleID\n is used for searching a module. To search multiple modules in a RS422/485 network, \nUF_SearchModuleIDEx\n should be used instead. By calling this function repetitively, users can search all the modules connected to a network.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SearchModuleIDEx\n(\n \nunsigned\n \nshort\n*\n \nfoundModuleID\n,\n \nint\n \nnumOfFoundID\n,\n \nunsigned\n \nshort\n*\n \nmoduleID\n,\n \nint\n*\n \nnumOfID\n \n)\n\n\n\n\nParameters\n\n\nfoundModuleID\n\nPointer to the array of module IDs, which are already found. When the ID of a module is in this array, the module will ignore the search command.\n\n\nnumOfFoundID\n\nNumber of module IDs, which are already found.\n\n\nmoduleID\n\nPointer to the array of module IDs, which will be filled with newly found IDs.\n\n\nnumOfID\n\nPointer to the number of module IDs to be returned.  \n\n\nReturn Values\n\nIf it finds one or more modules, return \nUF_RET_SUCCESS\n. If the search fails, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\nint\n \nnumOfModuleID\n;\n\n\nunsigned\n \nshort\n \nmoduleID\n[\n32\n];\n\n\n\nint\n \nnumOfFoundID\n \n=\n \n0\n;\n\n\nBOOL\n \nfoundNewID\n \n=\n \nFALSE\n;\n\n\n\ndo\n \n{\n\n\n    \nresult\n \n=\n \nUF_SearchModuleIDEx\n(\n \nmoduleID\n,\n \nnumOfFoundID\n,\n \nmoduleID\n \n+\n\n\nnumOfFoundID\n,\n \n&\nnumOfModuleID\n \n);\n\n\n\n    \nif\n(\n \nresult\n \n==\n \nUF_RET_SUCCESS\n \n)\n\n\n    \n{\n\n\n        \nfoundNewID\n \n=\n \nTRUE\n;\n\n\n\n        \nnumOfFoundID\n \n+=\n \nnumOfModuleID\n;\n\n\n    \n}\n\n\n    \nelse\n\n\n    \n{\n\n\n        \nfoundNewID\n \n=\n \nFALSE\n;\n\n\n    \n}\n\n\n}\n \nwhile\n(\n \nfoundNewID\n \n&&\n \nnumOfFoundID\n \n<\n \n32\n \n);\n\n\n\n\n\n\n\n\nUF_CalibrateSensor\n\u00b6\n\n\nCalibrates fingerprint sensor. This function is supported for AuthenTec\u2019s FingerLoc AF-S2 and UPEK\u2019s TouchChip. After using the \nUF_CalibrateSensor\n, \nUF_Save\n should be called to save calibration data into flash memory.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_CalibrateSensor\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_Upgrade\n\u00b6\n\n\nUpgrades the firmware of the module. Users should not turn off the module when upgrade is in progress.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Upgrade\n(\n \nconst\n \nchar\n*\n \nfirmwareFilename\n,\n \nint\n \ndataPacketSize\n)\n\n\n\n\nParameters\n\n\nfirmwareFilename\n\nNull-terminated string that specifies the firmware file name.\n\n\ndataPacketSize\n\nThe packet size of firmware data. If it is 16384, the firmware is divided into 16384 byte packets before transferring to the module.  \n\n\nReturn Values\n\nIf upgrade succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_Reset\n\u00b6\n\n\nResets the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Reset\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\n\nUF_RET_SUCCESS\n\n\n\n\n\n\nUF_Lock\n\u00b6\n\n\nLocks the module. When the module is locked, it returns \nUF_ERR_LOCKED\n to functions other than \nUF_Unlock\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Lock\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the module is locked successfully, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_Unlock\n\u00b6\n\n\nUnlocks a locked module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Unlock\n(\n \nconst\n \nunsigned\n \nchar\n*\n \npassword\n \n)\n\n\n\n\nParameters\n\n\npassword\n\n16 byte master password. The default password is a string of 16 NULL characters.\n\n\nReturn Values\n\nIf the password is wrong, return UF_ERR_NOT_MATCH. If it is successful, return UF_RET_SUCCESS.\n\n\n\n\n\n\nUF_ChangePassword\n\u00b6\n\n\nChanges the master password.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ChangePassword\n(\n \nconst\n \nunsigned\n \nchar\n*\n \nnewPassword\n,\n \nconst\n \nunsigned\n \nchar\n*\n \noldPassword\n \n)\n\n\n\n\nParameters\n\n\nnewPassword\n\n16 byte new password.\n\n\noldPassword\n\n16 byte old password.  \n\n\nReturn Values\n\nIf the old password is wrong, return \nUF_ERR_NOT_MATCH\n. If it is successful, return \nUF_RET_SUCCESS\n.\n\n\n\n\n\n\nUF_PowerOff\n\u00b6\n\n\nProgrammatically turns off a module. This function is only available with SFM4000 series.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_PowerOff\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nThe module is powered off successfully, return \nUF_RET_SUCCESS\n.\n\n\n\n\n\n\n3.7. System Parameters API\n\u00b6\n\n\nFunctions for managing system parameters. Available system parameters are defined in UF_SysParameter.h. See the Packet Protocol Manual for available values for each parameter.\nThis API also provides functions for saving and loading system configurations.\n\n\n\n\nUF_InitSysParameter\n: clears the system parameter cache.\n\n\nUF_GetSysParameter\n: gets the value of a system parameter.\n\n\nUF_SetSysParameter\n: sets the value of a system parameter.\n\n\nUF_GetMultiSysParameter\n: gets the values of multiple system parameters.\n\n\nUF_SetMultiSysParameter\n: sets the values of multiple system parameters.\n\n\nUF_Save\n: saves system parameters into the flash memory.\n\n\nUF_SaveConfiguration\n: saves system configurations into the specified file.\n\n\nUF_ReadConfigurationHeader\n: reads configuration information stored in a file.\n\n\nUF_LoadConfiguration\n: loads system configurations from the specified file.\n\n\nUF_MakeParameterConfiguration\n: makes parameter configuration data to be saved.\n\n\n\n\n\n\nUF_InitSysParameter\n\u00b6\n\n\nTo prevent redundant communication, the SFM SDK caches the system parameters previously read or written. \nUF_InitSysParameter\n clears this cache. It is called in \nUF_Reconnect\n.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_InitSysParameter\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_GetSysParameter\n\u00b6\n\n\nReads the value of a system parameter.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetSysParameter\n(\n \nUF_SYS_PARAM\n \nparameter\n,\n \nUINT32\n*\n \nvalue\n \n)\n\n\n\n\nParameters\n\n\nparameter\n\nSystem parameter to be read.\n\n\nvalue\n\nPointer to the value of the specified system parameter to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. If there is no such parameter, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetSysParameter\n\u00b6\n\n\nWrites the value of a system parameter. The parameter value is changed in memory only. To make the change permanent, \nUF_Save\n should be called after this function. For BioEntry Smart and Pass, users cannot change the \nUF_SYS_MODULE_ID\n system parameter.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetSysParameter\n(\n \nUF_SYS_PARAM\n \nparameter\n,\n \nUINT32\n \nvalue\n \n)\n\n\n\n\nParameters\n\n\nparameter\n\nSystem parameter to be written.\n\n\nvalue\n\nValue of the system parameter. Refer to the Packet Protocol Manual for available values for each parameter.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. If there is no such parameter, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetMultiSysParameter\n\u00b6\n\n\nReads the values of multiple system parameters.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetMultiSysParameter\n(\n \nint\n \nparameterCount\n,\n \nUF_SYS_PARAM\n\\\n*\n \nparameters\n,\n \nUINT32\n\\\n*\n \nvalues\n \n)\n\n\n\n\nParameters\n\n\nparameterCount\n\nNumber of system parameters to be read.\n\n\nparameters\n\nArray of system parameters to be read.\n\n\nvalues\n\nArray of the values of the specified system parameters to be read.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\n// To read 3 system parameters, UF_SYS_TIMEOUT, UF_SYS_ENROLL_MODE,\n\n\n// UF_SYS_SECURITY_LEVEL,\n\n\n\nUF_SYS_PARAM\n \nparameters\n[\n3\n]\n \n=\n \n{\n \nUF_SYS_TIMEOUT\n,\n \nUF_SYS_ENROLL_MODE\n,\n \nUF_SYS_SECURITY_LEVEL\n \n};\n\n\nUINT32\n \nvalues\n[\n3\n];\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetMultiSysParameter\n(\n \n3\n,\n \nparameters\n,\n \nvalues\n \n);\n\n\n\n\n\n\n\n\nUF_SetMultiSysParameter\n\u00b6\n\n\nWrites the values of multiple system parameters. The parameter value is changed in memory only. To make the change permanent, \nUF_Save\n should be called.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetMultiSysParameter\n(\n \nint\n \nparameterCount\n,\n \nUF_SYS_PARAM\n\\\n*\n \nparameters\n,\n \nUINT32\n\\\n*\n \nvalues\n \n)\n\n\n\n\nParameters\n\n\nparameterCount\n\nNumber of system parameters to be written.\n\n\nparameters\n\nArray of system parameters to be written.\n\n\nvalues\n\nArray of the values of the specified system parameters to be written.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_Save\n\u00b6\n\n\nSaves the system parameters into the flash memory.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Save\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SaveConfiguration\n\u00b6\n\n\nSaves system configurations into the specified file. The configuration file consists of a file header and multiple configuration components. There are 5 configuration components to be saved.\n\ntypedef\n \nenum\n \n{\n\n\n    \nUF_CONFIG_PARAMETERS\n  \n=\n \n0x01\n,\n \n// System parameters\n\n\n    \nUF_CONFIG_GPIO\n        \n=\n \n0x02\n,\n \n// GPIO configurations for\n\n\n                                  \n// SFM3000\n\n\n    \nUF_CONFIG_IO\n          \n=\n \n0x04\n,\n \n// IO configurations for\n\n\n                                  \n// SFM3500\n\n\n    \nUF_CONFIG_WIEGAND\n     \n=\n \n0x08\n,\n \n// Extended Wiegand\n\n\n    \nUF_CONFIG_USER_MEMORY\n \n=\n \n0x10\n,\n \n// User memory\n\n\n}\n \nUF_CONFIG_TYPE\n;\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SaveConfiguration\n(\n \nconst\n \nchar\n*\n \nfilename\n,\n \nconst\n \nchar\n*\n \ndescription\n,\n \nint\n \nnumOfComponent\n,\n \nUFConfigComponentHeader\n*\n \ncomponentHeader\n,\n \nvoid\n**\n \ncomponentData\n \n)\n\n\n\n\nParameters\n\n\nfilename\n\nNull-terminated string that specifies the file name.\n\n\ndescription\n\nNull-terminated string describing the configuration file. The maximum length of description is 256 bytes.\n\n\nnumOfComponent\n\nNumber of components to be saved.\n\n\ncomponentHeader\n\nPointer to an array of UFConfigComponentHeader structures to be saved.  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUF_CONFIG_TYPE\n \ntype\n;\n\n\n    \nUINT32\n \ndataSize\n;\n\n\n    \nUINT32\n \nchecksum\n;\n\n\n}\n \nUFConfigComponentHeader\n;\n\n\n\n\ncomponentData\n\nPointer to an array of component data to be saved.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\n// To save system parameters and IO configuration\n\n\n// of a SFM 3500 module into \u201cSFM3500.cfg\u201d file,\n\n\nUF_ConfigComponentHeader\n \nconfigHeader\n[\n2\n];\n\n\nvoid\n*\n \nconfigData\n[\n2\n];\n\n\n\n// Make system parameter component\n\n\nUFConfigParameter\n*\n \nparameter\n \n=\n \n(\nUFConfigParameter\n*\n)\nmalloc\n(\n \nsizeof\n(\nint\n)\n \n+\n\n\n    \nNUM_OF_PARAMETER\n \n*\n \nsizeof\n(\nUFConfigParameterItem\n)\n \n);\n\n\nUF_MakeParameterConfiguration\n(\n \n&\nconfigHeader\n[\n0\n],(\nBYTE\n*\n)\nparameter\n \n);\n\n\nconfigData\n[\n0\n]\n \n=\n \n(\nvoid\n*\n)\nparameter\n;\n\n\n\n// Make IO component\n\n\nUFConfigIO\n*\n \nio\n \n=\n \n(\nUFConfigIO\n*\n)\nmalloc\n(\n \nsizeof\n(\nUFConfigIO\n)\n \n+\n\n\n    \nsizeof\n(\nUFConfigOutputItem\n)\n \n*\n \n(\nUF_MAX_OUTPUT_EVENT\n \n-\n \n1\n)\n \n);\n\n\nUF_MakeIOConfiguration\n(\n \n&\nconfigHeader\n[\n1\n],\n \n(\nBYTE\n*\n)\nio\n \n);\n\n\nconfigData\n[\n1\n]\n \n=\n \n(\nvoid\n*\n)\nio\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SaveConfiguration\n(\n \n\u201c\nSFM3500\n.\ncfg\n\u201d\n,\n \n\u201c\nConfiguration\n\n\n    \nfile\n \nfor\n \nSFM3500\n\u201d\n,\n \n2\n,\n \nconfigHeader\n,\n \nconfigData\n \n);\n\n\n\n\n\n\n\n\nUF_ReadConfigurationHeader\n\u00b6\n\n\nReads the header information from a file which is saved by \nUF_SaveConfiguration\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadConfigurationHeader\n(\n \nconst\n \nchar\n*\n \nfilename\n,\n \nUFConfigFileHeader\n*\n \nheader\n \n)\n\n\n\n\nParameters\n\n\nfilename\n\nNull-terminated string that specifies the file name.\n\n\nheader\n\nPointer to the UFConfigFileHeader to be read.  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUINT32\n \nmagicNo\n;\n \n// if valid, UF_VALID_CONFIG_FILE\n\n\n    \nUINT32\n \nnumOfComponent\n;\n\n\n    \nchar\n \ndescription\n[\n256\n];\n\n\n}\n \nUFConfigFileHeader\n;\n\n\n\n\nReturn Values\n\nIf the header is read successfully, return \nUF_RET_SUCCESS\n. If the file is of invalid type, return \nUF_ERR_INVALID_FILE\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_LoadConfiguration\n\u00b6\n\n\nLoads system configurations into a module from the specified file. To make permanent the configuration changes, \nUF_Save\n should be called after \nUF_LoadConfiguration\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_LoadConfiguration\n(\n \nconst\n \nchar\n*\n \nfilename\n,\n \nint\n \nnumOfComponent\n,\n \nUF_CONFIG_TYPE\n*\n \ntype\n \n)\n\n\n\n\nParameters\n\n\nfilename\n\nNull-terminated string that specifies the file name.\n\n\nnumOfComponent\n\nNumber of configuration components to be loaded.\n\n\ntype\n\nArray of component types to be loaded.  \n\n\nReturn Values\n\nIf the configurations are loaded successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.  \n\n\nExample\n  \n\n\n// To load system parameters and IO configuration\n\n\n// of a SFM 3500 module from \u201cSFM3500.cfg\u201d file,\n\n\nUF_CONFIG_TYPE\n \nconfigType\n[\n2\n]\n \n=\n \n{\n \nUF_CONFIG_PARAMETERS\n,\n \nUF_CONFIG_IO\n \n};\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_LoadConfiguration\n(\n \n\u201c\nSFM3500\n.\ncfg\n\u201d\n,\n \n2\n,\n \nconfigType\n \n);\n\n\n\n\n\n\n\n\nUF_MakeParameterConfiguration\n\u00b6\n\n\nMake a UFConfigComponentHeader and a UFConfigParameter structure to be used in \nUF_SaveConfiguration\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_MakeParameterConfiguration\n(\n \nUFConfigComponentHeader\n*\n \nconfigHeader\n,\n \nBYTE\n*\n \nconfigData\n \n)\n\n\n\n\nParameters\n\n\nconfigHeader\n\nPointer to the UFConfigComponentHeader structure.\n\n\nconfigData\n\nPointer to the UFConfigParameter structure. It should be preallocated large enough to store all the parameter information.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\n3.8. Template Management API\n\u00b6\n\n\nThese functions provide template management interfaces such as read, delete and fix. Users can also manage user ids and administration levels associated with templates using these APIs.\n\n\n\n\nUF_GetNumOfTemplate\n: gets the number of template stored in a module.\n\n\nUF_GetMaxNumOfTemplate\n: gets the template capacity of a module.\n\n\nUF_GetAllUserInfo\n: gets all the template and user information stored in a module.\n\n\nUF_GetAllUserInfoEx\n: gets all the template and user information stored in a BioEntry reader.\n\n\nUF_SortUserInfo\n: sorts UFUserInfo structures.\n\n\nUF_SetUserInfoCallback\n: sets the callback function for getting user information.\n\n\nUF_SetAdminLevel\n: sets the administration level of a user.\n\n\nUF_GetAdminLevel\n: gets the administration level of a user.\n\n\nUF_ClearAllAdminLevel\n: clears all the administration levels of users.\n\n\nUF_SaveDB\n: saves templates and user information into the specified file.\n\n\nUF_LoadDB\n: loads templates and user information from the specified file.\n\n\nUF_CheckTemplate\n: checks if the specified ID has templates.\n\n\nUF_ReadTemplate\n: reads the templates of the specified user ID.\n\n\nUF_ReadOneTemplate\n: reads one template of the specified user ID.\n\n\nUF_SetScanCallback\n: sets the callback function for scanning fingerprints.\n\n\nUF_ScanTemplate\n: scans a fingerprint on the sensor and retrieves the fingerprint template.\n\n\nUF_FixProvisionalTemplate\n: saves the provisional templates into the flash memory.\n\n\nUF_SetSecurityLevel\n: sets the security level of a user.\n\n\nUF_GetSecurityLevel\n: gets the security level of a user.\n\n\nUF_SetAuthType\n: sets the authentication type of a user.\n\n\nUF_GetAuthType\n: gets the authentication type of a user.\n\n\nUF_GetUserIDByAuthType\n: gets the user IDs with specified authentication type.\n\n\nUF_ResetAllAuthType\n: resets the authentication types of all users.\n\n\nUF_SetEntranceLimit\n: sets the entrance limit of a user.\n\n\nUF_GetEntranceLimit\n: gets the entrance limit of a user.\n\n\nUF_ClearAllEntranceLimit\n: clears the entrance limits of all users.\n\n\n\n\n\n\nUF_GetNumOfTemplate\n\u00b6\n\n\nGets the number of templates stored in the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetNumOfTemplate\n(\n \nUINT32\n*\n \nnumOfTemplate\n \n)\n\n\n\n\nParameters\n\n\nnumOfTemplate\n\nPointer to the number of templates to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_GetMaxNumOfTemplate\n\u00b6\n\n\nGets the template capacity of the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetMaxNumOfTemplate\n(\n \nUINT32\n*\n \nmaxNumOfTemplate\n \n)\n\n\n\n\nParameters\n\n\nmaxNumOfTemplate\n\nPointer to the template capacity to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetAllUserInfo\n\u00b6\n\n\nRetrieves all the user and template information stored in the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetAllUserInfo\n(\n \nUFUserInfo\n\\\n*\n \nuserInfo\n,\n \nUINT32\n\\\n*\n \nnumOfUser\n,\n \nUINT32\n\\\n*\n \nnumOfTemplate\n \n)\n\n\n\n\nParameters\n\n\nuserInfo\n\nArray of UFUserInfo structures, which will store all the information. This pointer should be preallocated large enough to store all the information. UFUserInfo structure is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUINT32\n \nuserID\n;\n\n\n    \nBYTE\n \nnumOfTemplate\n;\n\n\n    \nBYTE\n \nadminLevel\n;\n \n// See UF_SetAdminLevel\n\n\n    \nBYTE\n \nsecurityLevel\n;\n \n// See UF_SetSecurityLevel\n\n\n    \nBYTE\n \nreserved\n;\n\n\n}\n \nUFUserInfo\n;\n\n\n\n\nnumOfUser\n\nPointer to the number of users to be returned.\n\n\nnumOfTemplate\n\nPointer to the number of templates to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\nExample\n  \n\n\nUINT32\n \nmaxUser\n;\n\n\nUINT32\n \nnumOfUser\n,\n \nnumOfTemplate\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetSysParameter\n(\n \nUF_SYS_ENROLLED_FINGER\n,\n \n&\nmaxUser\n \n);\n\n\n\nUFUserInfo\n*\n \nuserInfo\n \n=\n \n(\nUFUserInfo\n*\n)\nmalloc\n(\n \nmaxUser\n \n*\n \nsizeof\n(\nUFUserInfo\n)\n \n);\n\n\n\nresult\n \n=\n \nUF_GetAllUserInfo\n(\n \nuserInfo\n,\n \n&\nnumOfUser\n,\n \n&\nnumOfTemplate\n \n);\n\n\n\n\n\n\n\n\nUF_GetAllUserInfoEx\n\u00b6\n\n\nRetrieves all the user and template information stored in the BioEntry reader.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetAllUserInfoEx\n(\n \nUFUserInfoEx\n*\n \nuserInfo\n,\n \nUINT32\n*\n \nnumOfUser\n,\n \nUINT32\n*\n \nnumOfTemplate\n \n)\n\n\n\n\nParameters\n\n\nuserInfo\n\nArray of \nUFUserInfoEx\n structures, which will store all the information. This pointer should be preallocated large enough to store all the information. \nUFUserInfoEx\n structure is defined as follows;\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUINT32\n \nuserID\n;\n\n\n    \nUINT32\n \nchecksum\n[\n10\n];\n \n// checksum of each template data\n\n\n    \nBYTE\n \nnumOfTemplate\n;\n\n\n    \nBYTE\n \nadminLevel\n;\n\n\n    \nBYTE\n \nduress\n[\n10\n];\n\n\n    \nBYTE\n \nsecurityLevel\n;\n\n\n}\n \nUFUserInfoEx\n;\n\n\n\n\nnumOfUser\n\nPointer to the number of users to be returned.\n\n\nnumOfTemplate\n\nPointer to the number of templates to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SortUserInfo\n\u00b6\n\n\nSorts an \nUFUserInfo\n array in ascending order of user ID.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SortUserInfo\n(\n \nUFUserInfo\n*\n \nuserInfo\n,\n \nint\n \nnumOfUser\n \n)\n\n\n\n\nParameters\n\n\nuserInfo\n\nArray of UFUserInfo structures.\n\n\nnumOfUser\n\nNumber of UFUserInfo.  \n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_SetUserInfoCallback\n\u00b6\n\n\nSets the callback function for getting user information. It is also called when enrolling templates in \nUF_LoadDB\n and reading templates in \n\nUF_SaveDB\n.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetUserInfoCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nint\n \nindex\n,\n \nint\n \nnumOfTemplate\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.\n\n\nReturn Values\n\nNone\n\n\nExample\n\nSee CMainFrame::UserInfoCallback in UniFingerUI source codes.\n\n\n\n\n\n\nUF_SetAdminLevel\n\u00b6\n\n\nSets the administration level of a user. See \nUF_EnrollAfterVerification\n and \nUF_DeleteAllAfterVerificatoin\n for usage of administration level.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetAdminLevel\n(\n \nUINT32\n \nuserID\n,\n \nUF_ADMIN_LEVEL\n \nadminLevel\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nadminLevel\n\nSpecifies the administration level of the user.  \n\n\n\n\n\n\n\n\nValue\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUF_ADMIN_NONE\n\n\n\n\n\n\n\n\nUF_ADMIN_ENROLL\n\n\nCan enroll users.\n\n\n\n\n\n\nUF_ADMIN_DELETE\n\n\nCan delete users.\n\n\n\n\n\n\nUF_ADMIN_ALL\n\n\nCan enroll and delete users.\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetAdminLevel\n\u00b6\n\n\nGets the administration level of a user.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetAdminLevel\n(\n \nUINT32\n \nuserID\n,\n \nUF_ADMIN_LEVEL\n*\n \nadminLevel\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nadminLevel\n\nPointer to the administration level of the user to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ClearAllAdminLevel\n\u00b6\n\n\nResets administration levels of all users to UF_ADMIN_NONE.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearAllAdminLevel\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SaveDB\n\u00b6\n\n\nSaves all the templates and user information stored in a module into the specified file.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SaveDB\n(\n \nconst\n \nchar\n*\n \nfileName\n \n)\n\n\n\n\nParameters\n\n\nfileName\n\nNull-terminated string that specifies the file name.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_LoadDB\n\u00b6\n\n\nLoads templates and user information from the specified file. All the templates previously stored in the module will be erased before loading the DB.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_LoadDB\n(\n \nconst\n \nchar\n*\n \nfileName\n \n)\n\n\n\n\nParameters\n\n\nfileName\n\nNull-terminated string that specifies the file name.\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_CheckTemplate\n\u00b6\n\n\nChecks if the specified user ID has enrolled templates.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_CheckTemplate\n(\n \nUINT32\n \nuserID\n,\n \nUINT32\n*\n \nnumOfTemplate\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nnumOfTemplate\n\nPointer to the number of templates of the user ID to be returned.  \n\n\nReturn Values\n\nIf there are templates of the user ID, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadTemplate\n\u00b6\n\n\nReads  the templates of the specified user ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadTemplate\n(\n \nUINT32\n \nuserID\n,\n \nUINT32\n*\n \nnumOfTemplate\n,\n \nBYTE\n*\n \ntemplateData\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nnumOfTemplate\n\nPointer to the number of templates of the user ID to be returned.\n\n\ntemplateData\n\nPointer to the template data to be returned. This pointer should be preallocated large enough to store all the template data.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadOneTemplate\n\u00b6\n\n\nReads one template of the specified user ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadOneTemplate\n(\n \nUINT32\n \nuserID\n,\n \nint\n \nsubID\n,\n \nBYTE\n*\n \ntemplateData\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsubID\n\nSub index of the template. It is between 0 and 9.\n\n\ntemplateData\n\nPointer to the template data to be returned. This pointer should be preallocated large enough to store all the template data.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetScanCallback\n\u00b6\n\n\nSets the callback function of scanning fingerprints. This callback is called when \nSCAN_SUCCESS\n message is received.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetScanCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_ScanTemplate\n\u00b6\n\n\nScans a fingerprint on the sensor and receives the template of it.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ScanTemplate\n(\n \nBYTE\n*\n \ntemplateData\n,\n \nUINT32\n*\n \ntemplateSize\n,\n \nUINT32\n*\n \nimageQuality\n \n)\n\n\n\n\nParameters\n\n\ntemplateData\n\nPointer to the template data to be returned.\n\n\ntemplateSize\n\nPointer to the template size to be returned.\n\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_FixProvisionalTemplate\n\u00b6\n\n\nUF_SYS_PROVISIONAL_ENROLL\n determines if enrolled templates are saved permanently into flash memory or temporarily into DRAM. With provisional enroll, enrolled templates on DRAM will be erased if the module is turned off. \nUF_FixProvisionalTemplate\n saves the provisional templates into the flash memory.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_FixProvisionalTemplate\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetSecurityLevel\n\u00b6\n\n\nSince V1.6 firmware, the security level can be assigned per user basis for 1:1 matching. 1:N matching \u2013 identification \u2013 is not affected by this setting.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetSecurityLevel\n(\n \nUINT32\n \nuserID\n,\n \nUF_USER_SECURITY_LEVEL\n \nsecurityLevel\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsecurityLevel\n\nSpecifies the security level of the user.  \n\n\n\n\n\n\n\n\nValue\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUF_USER_SECURITY_DEFAULT\n\n\nSame as defined by Security Level system parameter\n\n\n\n\n\n\nUF_USER_SECURITY_1_TO_1000\n\n\n\n\n\n\n\n\n\u2026\n\n\n\n\n\n\n\n\nUF_USER_SECURITY_1_TO_100000000\n\n\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetSecurityLevel\n\u00b6\n\n\nGets the security level of a user.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetSecurityLevel\n(\n \nUINT32\n \nuserID\n,\n \nUF_SECURITY_LEVEL\n*\n \nsecurityLevel\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsecurityLevel\n\nPointer to the security level of the user to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetAuthType\n\u00b6\n\n\nSets the authentication type of a user. \nUF_AUTH_BYPASS\n can be used for 1:1 matching, when it is necessary to allow access without matching fingerprints. \nUF_AUTH_REJECT\n can be used for disabling some IDs temporarily. The default authentication mode is \nUF_AUTH_FINGERPRINT\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetAuthType\n(\n \nUINT32\n \nuserID\n,\n \nUF_AUTH_TYPE\n \nauthType\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nauthType\n\nSpecifies the authentication type of the user.  \n\n\n\n\n\n\n\n\nValue\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUF_AUTH_FINGERPRINT\n\n\nFingerprint authentication.\n\n\n\n\n\n\nUF_AUTH_BYPASS\n\n\nAuthentication will succeed without matching fingerprints.\n\n\n\n\n\n\nUF_AUTH_REJECT\n\n\nAuthentication will always fail.\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetAuthType\n\u00b6\n\n\nGets the authentication type of a user.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetAuthType\n(\n \nUINT32\n \nuserID\n,\n \nUF_AUTH_TYPE\n*\n \nauthType\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nauthType\n\nPointer to the authentication type of the user to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetUserIDByAuthType\n\u00b6\n\n\nReceive user IDs with the specified authentication type.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetUserIDByAuthType\n(\n \nUF_AUTH_TYPE\n \nauthType\n,\n \nint\n*\n \nnumOfID\n,\n \nUINT32\n*\n \nuserID\n \n)\n\n\n\n\nParameters\n\n\nauthType\n\nAuthentication type.\n\n\nnumOfID\n\nPointer to the number of user IDs to be returned.\n\n\nuserID\n\nArray of user IDs which have the specified authentication type.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ResetAllAuthType\n\u00b6\n\n\nResets the authentication types of all users to UF_AUTH_FINGERPRINT.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ResetAllAuthType\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetEntranceLimit\n\u00b6\n\n\nSpecifies how many times the user is permitted to access per day. The available options are between 0 and 7. The default value is 0, which means that there is no limit. If the user tries to authenticate after the limit is reached, \nUF_ERR_EXCEED_ENTRANCE_LIMIT\n error will be returned.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetEntranceLimit\n(\n \nUINT32\n \nuserID\n,\n \nint\n \nentranceLimit\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nentranceLimit\n\nEntrance limit between 0 and 7.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetEntranceLimit\n\u00b6\n\n\nGets the entrance limit of a user.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetEntranceLimit\n(\n \nUINT32\n \nuserID\n,\n \nint\n*\n \nentranceLimit\n,\n \nint\n*\n \nentranceCount\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nentranceLimit\n\nPointer to the entrance limit of the user.\n\n\nentranceCount\n\nPointer to the number of entrance for today. This count is reset to 0 at midnight.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ClearAllEntranceLimit\n\u00b6\n\n\nResets the entrance limits of of all users to 0 \u2013 infinite.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearAllEntranceLimit\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.9. Image Manipulation API\n\u00b6\n\n\nUFImage is a data structure for exchanging image data between the host and the module. It consists of 28 byte header and raw image data.\n\ntypedef\n \nstruct\n \n{\n\n\n    \nint\n \nwidth\n;\n \n// width of the fingerprint image\n\n\n    \nint\n \nheight\n;\n \n// height of the fingerprint image\n\n\n    \nint\n \ncompressed\n;\n \n// compression status \u2013 currently not used\n\n\n    \nint\n \nencrypted\n;\n \n// encryption status \u2013 currently not used\n\n\n    \nint\n \nformat\n;\n \n// 0- gray, 1- binary, 2- 4bit gray\n\n\n    \nint\n \nimgLen\n;\n \n// width * height\n\n\n    \nint\n \ntemplateLen\n;\n \n// size of fingerprint template \u2013 currently not used\n\n\n    \nBYTE\n \nbuffer\n[\n1\n];\n// pointer to the raw pixel data\n\n\n}\n \nUFImage\n;\n\n\n\n\n\n\nUF_ConvertToBitmap\n: converts a UFImage structure into HBITMAP.\n\n\nUF_SaveImage\n: saves a UFImage structure into BMP file.\n\n\nUF_LoadImage\n: loads a BMP file and convert it into a UFImage structure.\n\n\nUF_ReadImage\n: retrieves the last scanned fingerprint image.\n\n\nUF_ScanImage\n: scans a fingerprint on the sensor and retrieves the image data.\n\n\n\n\n\n\nUF_ConvertToBitmap\n\u00b6\n\n\nTo display a UFImage on the PC screen, it should be converted to a bitmap first. \nUF_ConvertToBitmap\n converts a \nUFImage\n into a device independent bitmap and returns the handle of it. After drawing the bitmap, it should be destroyed by calling \nDeleteObject()\n.\n\n\n\n\nDescription\n\n\nHBITMAP\n \nUF_ConvertToBitmap\n(\n \nUFImage\n*\n \nimage\n \n)\n\n\n\n\nParameters\n\n\nimage\n\nPointer to the UFImage structure to be converted.  \n\n\nReturn Values\n\nIf the function succeeds, return the \nHBITMAP\n of the bitmap. Otherwise, return \nNULL\n.\n\n\nExample\n  \n\n\n// The following snippet is from FingerprintViewer.cpp in UniFingerUI\n\n\n// source codes\n\n\nclass\n \nCFingerprintViewer\n \n:\n \npublic\n \nCStatic\n\n\n{\n\n\n    \n// \u2026\n\n\nPrivate\n:\n\n\n    \nUFImage\n*\n \nm_Image\n;\n\n\n    \nHBITMAP\n \nm_Bitmap\n;\n\n\n};\n\n\n\nvoid\n \nCFingerprintViewer::OnPaint\n()\n\n\n{\n\n\n    \nCPaintDC\n \ndc\n(\n \nthis\n \n);\n\n\n    \nCBitmap\n \nbmp\n;\n\n\n\n    \nif\n(\n \nm_Bitmap\n \n)\n\n\n    \n{\n\n\n        \nDeleteObject\n(\n \nm_Bitmap\n \n);\n\n\n    \n}\n\n\n\n    \nif\n(\n \nm_Image\n \n)\n\n\n    \n{\n\n\n        \nm_Bitmap\n \n=\n \nUF_ConvertToBitmap\n(\n \nm_Image\n \n);\n\n\n        \nbmp\n.\nAttach\n(\n \nm_Bitmap\n \n);\n\n\n    \n}\n\n\n    \nelse\n\n\n    \n{\n\n\n        \nbmp\n.\nLoadBitmap\n(\n \nIDB_LOGO\n \n);\n\n\n    \n}\n\n\n    \nCDC\n \nbmDC\n;\n\n\n    \nbmDC\n.\nCreateCompatibleDC\n(\n&\ndc\n);\n\n\n    \nCBitmap\n \n*\npOldbmp\n \n=\n \nbmDC\n.\nSelectObject\n(\n&\nbmp\n);\n\n\n\n    \nBITMAP\n \nbi\n;\n\n\n    \nbmp\n.\nGetBitmap\n(\n&\nbi\n);\n\n\n\n    \nCRect\n \nrect\n;\n\n\n    \nthis\n->\nGetClientRect\n(\n&\nrect\n);\n\n\n\n    \ndc\n.\nSetStretchBltMode\n(\n \nHALFTONE\n \n);\n\n\n    \ndc\n.\nStretchBlt\n(\n \n1\n,\n \n1\n,\n \nrect\n.\nWidth\n()\n \n-\n \n2\n,\n \nrect\n.\nHeight\n()\n \n-\n \n2\n,\n \n&\nbmDC\n,\n \n0\n,\n \n0\n,\n \nbi\n.\nbmWidth\n,\n \nbi\n.\nbmHeight\n,\n \nSRCCOPY\n \n);\n\n\n    \nbmDC\n.\nSelectObject\n(\npOldbmp\n);\n\n\n}\n\n\n\n\n\n\n\n\nUF_SaveImage\n\u00b6\n\n\nConverts a UFImage into a bitmap and save it into the specified file.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SaveImage\n(\n \nconst\n \nchar\n*\n \nfileName\n,\n \nUFImage\n*\n \nimage\n \n)\n\n\n\n\nParameters\n\n\nfileName\n \n\nNull-terminated string that specifies the file name.\n\n\nimage\n\nPointer to the UFImage to be saved.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_LoadImage\n\u00b6\n\n\nLoads a bmp file into a UFImage structure.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_LoadImage\n(\n \nconst\n \nchar\n*\n \nfileName\n,\n \nUFImage\n*\n \nimage\n \n)\n\n\n\n\nParameters\n\n\nfileName\n\nNull-terminated string that specifies the file name.\n\n\nimage\n\nPointer to the UFImage structure.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadImage\n\u00b6\n\n\nReads the last scanned fingerprint image.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadImage\n(\n \nUFImage\n*\n \nimage\n \n)\n\n\n\n\nParameters\n\n\nimage\n\nPointer to the UFImage structure.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\nUFImage\n*\n \nimage\n \n=\n \n(\nUFImage\n*\n)\nmalloc\n(\n \nUF_IMAGE_HEADER_SIZE\n \n+\n\n\n                \nUF_MAX_IMAGE_SIZE\n \n);\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_ReadImage\n(\n \nimage\n \n);\n\n\n\n\n\n\n\n\nUF_ScanImage\n\u00b6\n\n\nScans a fingerprint input on the sensor and retrieves the image of it.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ScanImage\n(\n \nUFImage\n*\n \nimage\n \n)\n\n\n\n\nParameters\n\n\nimage\n\nPointer to the UFImage structure.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.10. Enroll API\n\u00b6\n\n\nThere are three ways to enroll fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere. The enrollment process varies according to \nUF_SYS_ENROLL_MODE\n parameter. Users can also fine tune the enrollment process by selecting enroll options.\n\n\n\n\nUF_Enroll\n: enrolls fingerprint inputs on the sensor.\n\n\nUF_EnrollContinue\n: continues the enrollment process when the enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2.\n\n\nUF_EnrollAfterVerification\n: enrolls after an administrator is verified.\n\n\nUF_EnrollTemplate\n: enrolls a template.\n\n\nUF_EnrollMultipleTemplates\n: enrolls multiple templates to the specified ID.\n\n\nUF_EnrollImage\n: enrolls a fingerprint image.\n\n\nUF_SetEnrollCallback\n: sets the callback function for enrollment process.\n\n\n\n\n\n\nUF_Enroll\n\u00b6\n\n\nEnrolls fingerprint inputs on the sensor. The enrollment process varies according to the \nUF_SYS_ENROLL_MODE\n system parameter.\n\n\n\n\n\n\n\n\nEnroll Mode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_ENROLL_ONE_TIME\n\n\nScans a fingerprint and enrolls it.\n\n\n\n\n\n\nUF_ENROLL_TWO_TIMES1\n\n\nScans two fingerprints and enrolls the better one of the two. The scanning of the second fingerprint starts automatically.\n\n\n\n\n\n\nUF_ENROLL_TWO_TIMES2\n\n\nSame as UF_ENROLL_TWO_TIMES1, but the scanning of the second fingerprint should be initiated by another request packet.\n\n\n\n\n\n\nUF_ENROLL_TWO_TEMPLATES1\n\n\nScans two fingerprints and enrolls both of them. The scanning of the second fingerprint starts automatically.\n\n\n\n\n\n\nUF_ENROLL_TWO_TEMPLATES2\n\n\nSame as UF_ENROLL_TWO_TEMPLATES1, but the scanning of the second fingerprint should be initiated by another request packet.\n\n\n\n\n\n\n\n\nUsers can also fine tune the enrollment process by selecting one of the following UF_ENROLL_OPTIONs.\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_ENROLL_NONE\n\n\nOverwrites existing templates of the same ID.\n\n\n\n\n\n\nUF_ENROLL_ADD_NEW\n\n\nAdds templates to the same user ID. The maximum number of templates per user is 10.\n\n\n\n\n\n\nUF_ENROLL_AUTO_ID\n\n\nThe user ID will be assigned automatically by the module.\n\n\n\n\n\n\nUF_ENROLL_CHECK_ID\n\n\nBefore enrolling, checks if the user ID has already some templates. If it does, UF_ERR_EXIST_ID will be returned. This option is useful when users do not want to overwrite existing templates.\n\n\n\n\n\n\nUF_ENROLL_CHECK_FINGER\n\n\nBefore enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_ADD_NEW option.\n\n\n\n\n\n\nUF_ENROLL_CHECK_FINGER_AUTO_ID\n\n\nBefore enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_AUTO_ID option.\n\n\n\n\n\n\nUF_ENROLL_DURESS\n\n\nAdds another fingerprint as duress finger to the specified user ID. Under duress, users can authenticate with duress finger to notify the threat. When duress finger is matched, the module will return UF_ERR_DURESS_FINGER error code and write a log. Users can also setup output signals for duress events. When enrolling, the duress finger should not match with nonduress fingerprints of the same ID. If it is the case, UF_ERR_EXIST_FINGER error will be returned.\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Enroll\n(\n \nUINT32\n \nuserID\n,\n \nUF_ENROLL_OPTION\n \noption\n,\n \nUINT32\n*\n \nenrollID\n,\n \nUINT32\n*\n \nimageQuality\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\noption\n\nEnroll option.\n\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when \nAUTO_ID\n option is used.\n\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  \n\n\nReturn Values\n\nIf enroll succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_EnrollContinue\n\u00b6\n\n\nContinues the enrollment process when the enroll mode is \nUF_ENROLL_TWO_TIMES2\n or \nUF_ENROLL_TWO_TEMPLATES2\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_EnrollContinue\n(\n \nUINT32\n \nuserID\n,\n \nUINT32\n*\n \nenrollID\n,\n \nUINT32\n*\n \nimageQuality\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when \nAUTO_ID\n option is used.\n\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  \n\n\nReturn Values\n\nIf enroll succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n  \n\n\n// To enroll user ID 10 with enroll option of ADD_NEW,\n\n\nUINT32\n \nmode\n;\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetSysParameter\n(\n \nUF_SYS_ENROLL_MODE\n,\n \n&\nmode\n \n);\n\n\n\nUINT32\n \nuserID\n,\n \nimageQuality\n;\n\n\nresult\n \n=\n \nUF_Enroll\n(\n \n10\n,\n \nUF_ENROLL_ADD_NEW\n,\n \n&\nuserID\n,\n \n&\nimageQuality\n \n);\n\n\n\n// If enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2\n\n\nIf\n(\n \nresult\n \n==\n \nUF_RET_SUCCESS\n \n&&\n \n(\nmode\n \n==\n \nUF_ENROLL_TWO_TEMPLATES2\n \n||\n \nmode\n \n==\n \nUF_ENROLL_TWO_TIMES2\n \n)\n \n)\n\n\n{\n\n\n    \nresult\n \n=\n \nUF_EnrollContinue\n(\n \n10\n,\n \n&\nuserID\n,\n \n&\nimageQuality\n \n);\n\n\n}\n\n\n\n\n\n\n\n\nUF_EnrollAfterVerification\n\u00b6\n\n\nEnroll and Delete functions change the fingerprint DB stored in the module. For some applications, it might be necessary to obtain administrator\u2019s permission before enrolling or deleting fingerprints. To process these functions, a user with proper administration level should verify himself first. If there is no user with co1rresponding administration level, these commands will fail with \nUF_ERR_UNSUPPORTED\n error code. If the verification fails, \nUF_ERR_NOT_MATCH\n error code will be returned. The only exception is that \nUF_EnrollAfterVerification\n will succeed when the fingerprint DB is empty. In that case, the first user enrolled by \nUF_EnrollAfterVerification\n will have \nUF_ADMIN_LEVEL_ALL\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_EnrollAfterVerification\n(\n \nUINT32\n \nuserID\n,\n \nUF_ENROLL_OPTION\n \noption\n,\n \nUINT32\n*\n \nenrollID\n,\n \nUINT32\n*\n \nimageQuality\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\noption\n\nEnroll option.\n\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when \nAUTO_ID\n option is used.\n\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  \n\n\nReturn Values\n\nIf enroll succeeds, return \nUF_RET_SUCCESS\n. If there is no user with corresponding administration level, return \nUF_ERR_UNSUPPORTED\n. If administrator\u2019s verification fails, return \nUF_ERR_NOT_MATCH\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_EnrollTemplate\n\u00b6\n\n\nEnrolls a fingerprint template.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_EnrollTemplate\n(\n \nUINT32\n \nuserID\n,\n \nUF_ENROLL_OPTION\n \noption\n,\n \nUINT32\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplateData\n,\n \nUINT32\n*\n \nenrollID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\noption\n\nEnroll option.\n\n\ntemplateSize\n\nSize of the template data.\n\n\ntemplateData\n\nPointer to the template data.\n\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when \nAUTO_ID\n option is used.  \n\n\nReturn Values\n\nIf enroll succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_EnrollMultipleTemplates\n\u00b6\n\n\nEnrolls multiple templates to the specified ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_EnrollMultipleTemplates\n(\n \nUINT32\n \nuserID\n,\n \nUF_ENROLL_OPTION\n \noption\n,\n \nint\n \nnumOfTemplate\n,\n \nUINT32\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplateData\n,\n \nUINT32\n*\n \nenrollID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n \n\nUser ID.\n\n\noption\n\nEnroll option.\n\n\nnumOfTemplate\n\nNumber of templates to be enrolled.\n\n\ntemplateSize\n\nSize of one template data. For example, when enroll 3 templates of 384 byte, this parameter is 384 not 1152.\n\n\ntemplateData\n\nPointer to the template data.\n\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when \nAUTO_ID\n option is used.  \n\n\nReturn Values\n\nIf enroll succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_EnrollImage\n\u00b6\n\n\nEnrolls a fingerprint image.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_EnrollImage\n(\n \nUINT32\n \nuserID\n,\n \nUF_ENROLL_OPTION\n \noption\n,\n \nUINT32\n \nimageSize\n,\n \nBYTE\n*\n \nimageData\n,\n \nUINT32\n*\n \nenrollID\n,\n \nUINT32\n*\n \nimageQuality\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\noption\n\nEnroll option.\n\n\nimageSize\n\nSize of the image data.\n\n\nimageData\n\nPointer to the raw image data. Note that it is not the pointer to \nUFImage\n, but the pointer to the raw pixel data without the \nUFImage\n header.\n\n\nenrollID\n\nPointer to the enrolled user ID. This parameter can be different from userID when \nAUTO_ID\n option is used..\n\n\nimageQuality\n\nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.  \n\n\nReturn Values\n\nIf enroll succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_SetEnrollCallback\n\u00b6\n\n\nSets the callback function for enrollment process. This callback is called after receiving response packets with \nUF_PROTO_RET_SCAN_SUCCESS\n, \nUF_PROTO_RET_SUCCESS\n, or \nUF_PROTO_RET_CONTINUE\n messages.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetEnrollCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n \nerrCode\n,\n \nUF_ENROLL_MODE\n \nenrollMode\n,\n \nint\n \nnumOfSuccess\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone\n\n\n\n\n\n\n3.11. Identify API\n\u00b6\n\n\nChecks if a fingerprint input is among the enrolled user ids. While verification checks only the fingerprints of a specified user id, identification searches all the enrolled fingerprints until a match is found. As in enrollment, there are three ways to identify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.\n\n\n\n\nUF_Identify\n: identifies the fingerprint input on the sensor.\n\n\nUF_IdentifyTemplate\n: identifies a template.\n\n\nUF_IdentifyImage\n: identifies a fingerprint image.\n\n\nUF_SetIdentifyCallback\n: sets the callback function for identification.\n\n\n\n\n\n\nUF_Identify\n\u00b6\n\n\nIdentifies the fingerprint input on the sensor.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Identify\n(\n \nUINT32\n*\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nPointer to the user ID to be returned.\n\n\nsubID\n\nPointer to the index of the template to be returned.  \n\n\nReturn Values\n\nIf matching succeeds, return \nUF_RET_SUCCESS\n. If matching fails, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_IdentifyTemplate\n\u00b6\n\n\nIdentifies a template.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_IdentifyTemplate\n(\n \nUINT32\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplateData\n,\n \nUINT32\n*\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n\n\nParameters\n\n\ntemplateSize\n\nSize of the template data.\n\n\ntemplateData\n\nPointer to the template data.\n\n\nuserID\n\nPointer to the user ID to be returned.\n\n\nsubID\n\nPointer to the index of the template to be returned. \n\n\nReturn Values\n\nIf matching succeeds, return \nUF_RET_SUCCESS\n. If matching fails, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_IdentifyImage\n\u00b6\n\n\nIdentifies a fingerprint image.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_IdentifyImage\n(\n \nUINT32\n \nimageSize\n,\n \nBYTE\n*\n \nimageData\n,\n \nUINT32\n*\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n\n\nParameters\n\n\nimageSize\n\nSize of the image data.\n\n\nimageData\n\nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header.\n\n\nuserID\n\nPointer to the user ID to be returned.\n\n\nsubID\n\nPointer to the index of the template to be returned.  \n\n\nReturn Values\n\nIf matching succeeds, return \nUF_RET_SUCCESS\n. If matching fails, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetIdentifyCallback\n\u00b6\n\n\nSets the callback function for identification process. This callback is called after receiving \nUF_PROTO_RET_SCAN_SUCCESS\n message.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetIdentifyCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone  \n\n\n\n\n\n\n3.12. Verify API\n\u00b6\n\n\nVerifies if a fingerprint input matches the enrolled fingerprints of the specified user id. As in enroll process, there are three ways to verify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.\n\n\n\n\nUF_Verify\n: verifies the fingerprint input on the sensor.\n\n\nUF_VerifyTemplate\n: verifies a template.\n\n\nUF_VerifyHostTemplate\n: verifies the fingerprint input on the sensor with the templates sent by the host.\n\n\nUF_VerifyImage\n: verifies a fingerprint image.\n\n\nUF_SetVerifyCallback\n: sets the callback function for verification process.\n\n\n\n\n\n\nUF_Verify\n\u00b6\n\n\nVerifies if a fingerprint input on the sensor matches the enrolled fingerprints of the specified user id.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Verify\n(\n \nUINT32\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsubID\n\nPointer to the index of the template to be returned.  \n\n\nReturn Values\n\nIf matching succeeds, return \nUF_RET_SUCCESS\n. If matching fails, return \nUF_ERR_NOT_MATCH\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_VerifyTemplate\n\u00b6\n\n\nVerifies a template.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_VerifyTemplate\n(\n \nUINT32\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplateData\n,\n \nUINT32\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n\n\nParameters\n\n\ntemplateSize\n\nSize of the template data.\n\n\ntemplateData\n\nPointer to the template data to be sent.\n\n\nuserID\n\nUser ID.\n\n\nsubID\n\nPointer to the index of the template to be returned.  \n\n\nReturn Values\n\nIf matching succeeds, return \nUF_RET_SUCCESS\n. If matching fails, return \nUF_ERR_NOT_MATCH\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_VerifyHostTemplate\n\u00b6\n\n\nTransmits fingerprint templates from the host to the module and verifies if they match the live fingerprint input on the sensor.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_VerifyHostTemplate\n(\n \nUINT32\n \nnumOfTemplate\n,\n \nUINT32\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplateData\n \n)\n\n\n\n\nParameters\n\n\nnumOfTemplate\n\nNumber of templates to be transferred to the module.\n\n\ntemplateSize\n\nSize of a template.\n\n\ntemplateData\n\nPointer to the template data to be transferred to the module.  \n\n\nReturn Values\n\nIf matching succeeds, return \nUF_RET_SUCCESS\n. If matching fails, return \nUF_ERR_NOT_MATCH\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_VerifyImage\n\u00b6\n\n\nVerifies a fingerprint image.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_VerifyImage\n(\n \nUINT32\n \nimageSize\n,\n \nBYTE\n*\n \nimageData\n,\n \nUINT32\n \nuserID\n,\n \nBYTE\n*\n \nsubID\n \n)\n\n\n\n\nParameters\n\n\nimageSize\n\nSize of the fingerprint image.\n\n\nimageData\n\nPointer to the raw image data. Note that it is not the pointer to \nUFImage\n, but the pointer to the raw pixel data without the \nUFImage\n header.\n\n\nuserID\n\nUser ID.\n\n\nsubID\n\nPointer to the index of the template to be returned.  \n\n\nReturn Values\n\nIf matching succeeds, return \nUF_RET_SUCCESS\n. If matching fails, return \nUF_ERR_NOT_MATCH\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetVerifyCallback\n\u00b6\n\n\nSets the callback function for verification process. The callback function is called after receiving \nUF_PROTO_RET_SCAN_SUCCESS\n message.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetVerifyCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone\n\n\n\n\n\n\n3.13. Delete API\n\u00b6\n\n\nProvides functions for deleting stored templates.\n\n\n\n\nUF_Delete\n: deletes the templates of the specified user ID.\n\n\nUF_DeleteOneTemplate\n: deletes one template of the specified user ID.\n\n\nUF_DeleteMultipleTemplates\n: deletes the template of multiple user IDs.\n\n\nUF_DeleteAll\n: deletes all the templates.\n\n\nUF_DeleteAllAfterVerification\n: deletes templates after administrator\u2019s verification.\n\n\nUF_SetDeleteCallback\n: sets the callback function for delete process.\n\n\n\n\n\n\nUF_Delete\n\u00b6\n\n\nDeletes the enrolled templates of the specified user ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_Delete\n(\n \nUINT32\n \nuserID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.  \n\n\nReturn Values\n\nIf delete succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteOneTemplate\n\u00b6\n\n\nDeletes one template of the specified user ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteOneTemplate\n(\n \nUINT32\n \nuserID\n,\n \nint\n \nsubID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsubID\n\nSub index of the template. It is between 0 and 9.  \n\n\nReturn Values\n\nIf delete succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteMultipleTemplates\n\u00b6\n\n\nDeletes the enrolled templates of multiple user IDs.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteMultipleTemplates\n(\n \nUINT32\n \nstartUserID\n,\n \nUINT32\n \nlastUserID\n,\n \nint\n*\n \ndeletedUserID\n \n)\n\n\n\n\nParameters\n \n\n\nstartUserID\n\nFirst user ID to be deleted.\n\n\nlastUserID\n\nLast user ID to be deleted.\n\n\ndeletedUserID\n\nPointer to the number of IDs to be actually deleted by the module.  \n\n\nReturn Values\n\nIf delete succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n  \n\n\n// Delete templates of ID 10 ~ ID 20\n\n\nint\n \nnumOfDeleted\n;\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_DeleteMultipleTemplates\n(\n \n10\n,\n \n20\n,\n \n&\nnumOfDeleted\n \n);\n\n\n\n\n\n\n\n\nUF_DeleteAll\n\u00b6\n\n\nDeletes all the templates stored in a module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAll\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf delete succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteAllAfterVerification\n\u00b6\n\n\nDeletes all the templates after administrator\u2019s verification.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAllAfterVerification\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf delete succeeds, return \nUF_RET_SUCCESS\n. If there is no user with corresponding administration level, return \nUF_ERR_UNSUPPORTED\n. If administrator\u2019s verification fails, return \nUF_ERR_NOT_MATCH\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetDeleteCallback\n\u00b6\n\n\nSets the callback function for delete process. This callback is called after receiving \nUF_PROTO_RET_SCAN_SUCCESS\n or \nUF_PROTO_RET_CONTINUE\n.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetDeleteCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nNone\n\n\n\n\n\n\n3.14. IO API for SFM3500\n\u00b6\n\n\nSFM3500 modules have three input ports, three output ports, and three LED ports which are configurable for specific functions. For BioEntry Smart and Pass, there are two input ports, two output ports, and 2 LED ports. These functions are provided to configure these IO ports.\n\n\n\n\nUF_InitIO\n: clears the output event caches.\n\n\nUF_SetInputFunction\n: sets the function of an input port.\n\n\nUF_GetInputFunction\n: gets the function of an input port.\n\n\nUF_GetInputStatus\n: gets the status of an input port.\n\n\nUF_GetOutputEventList\n: gets the output events list assigned to an output port.\n\n\nUF_ClearAllOutputEvent\n: clears all the output events assigned to an output port.\n\n\nUF_ClearOutputEvent\n: clears an output event assigned to an output port.\n\n\nUF_SetOutputEvent\n: adds an output event to an output port.\n\n\nUF_GetOutputEvent\n: gets the signal data of an output event.\n\n\nUF_SetOutputStatus\n: sets the status of an output port.\n\n\nUF_SetLegacyWiegandConfig\n: sets the Wiegand format.\n\n\nUF_GetLegacyWiegandConfig\n: gets the Wiegand format.\n\n\nUF_MakeIOConfiguration\n: makes IO configuration data to be saved into a file.\n\n\n\n\n\n\nUF_InitIO\n\u00b6\n\n\nTo prevent redundant communication, the SFM SDK caches the output events previously read or written. \nUF_InitIO\n clears the cache. It is called in \nUF_Reconnect\n.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_InitIO\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nNone\n\n\n\n\n\n\nUF_SetInputFunction\n\u00b6\n\n\nSets the function of an input port. Available functions are as follows;\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_INPUT_NO_ACTION\n\n\nNo action\n\n\n\n\n\n\nUF_INPUT_ENROLL\n\n\nEnroll\n\n\n\n\n\n\nUF_INPUT_IDENTIFY\n\n\nIdentify\n\n\n\n\n\n\nUF_INPUT_DELETE\n\n\nDelete\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL\n\n\nDelete all\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND\n\n\nEnroll by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_VERIFY_BY_WIEGAND\n\n\nVerify by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND\n\n\nDelete by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_ENROLL_VERIFICATION\n\n\nEnroll after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION\n\n\nEnroll by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_VERIFICATION\n\n\nDelete after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND_VERIFICATION\n\n\nDelete by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL_VERIFICATION\n\n\nDelete all after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_CANCEL\n\n\nCancel\n\n\n\n\n\n\nUF_INPUT_TAMPER_SWITCH_IN\n\n\nTamper switch. When the tamper switch is on, Tamper Switch On(0x64) event occurred. When it gets off, Tamper Switch Off(0x65) event occurred. Both events are recorded in log, too. In BioEntry Smart and Pass, UF_INPUT_PORT2 is assigned to Tamper SW.\n\n\n\n\n\n\nUF_INPUT_RESET\n\n\nReset the module\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetInputFunction\n(\n \nUF_INPUT_PORT\n \nport\n,\n \nUF_INPUT_FUNC\n \ninputFunction\n,\n \nUINT32\n \nminimumTime\n \n)\n\n\n\n\nParameters\n\n\nport\n\nOne of the three input ports \u2013 \nUF_INPUT_PORT0\n, \nUF_INPUT_PORT1\n, and \nUF_INPUT_PORT2\n. For BioEntry Smart and Pass, \nUF_INPUT_PORT2\n is assigned to Tamper SW and not configurable.\n\n\ninputFunction\n\nInput function.\n\n\nminimumTime\n  \n\nMinimum duration after which the input signal is acknowledged as active.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetInputFunction\n\u00b6\n\n\nGets the function assigned to an input port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetInputFunction\n(\n \nUF_INPUT_PORT\n \nport\n,\n \nUF_INPUT_FUNC\n*\n \ninputFunction\n,\n \nUINT32\n*\n \nminimumTime\n \n)\n\n\n\n\nParameters\n\n\nport\n\nInput port.\n\n\ninputFunction\n\nPointer to the input function to be returned.\n\n\nminimumTime\n\nPointer to the minimum duration of input signal to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetInputStatus\n\u00b6\n\n\nGets the status of an input port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetInputStatus\n(\n \nUF_INPUT_PORT\n \nport\n,\n \nBOOL\n \nremainStatus\n,\n \nUINT32\n*\n \nstatus\n \n)\n\n\n\n\nParameters\n\n\nport\n\nInput port.\n\n\nremainStatus\n\nIf \nTRUE\n, don\u2019t change the status of the input port after reading. If \nFALSE\n, clear the status of the input port.\n\n\nstatus\n\nPointer to the status of the input port to be read. 0 for inactive and 1 for active status.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetOutputEventList\n\u00b6\n\n\nGets the list of output events assigned to an output/LED port. Available output events are as follows;\n\n\n\n\n\n\n\n\nCategory\n\n\nEvent\n\n\n\n\n\n\n\n\n\n\nEnroll\n\n\nUF_OUTPUT_ENROLL_WAIT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_ENROLL_FAIL\n\n\n\n\n\n\nVerify\n\n\nUF_OUTPUT_VERIFY_WAIT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_VERIFY_FAIL\n\n\n\n\n\n\nIdentify\n\n\nUF_OUTPUT_IDENTIFY_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_FAIL\n\n\n\n\n\n\nDelete\n\n\nUF_OUTPUT_DELETE_WAIT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_WAIT_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_PROCESSING\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_BAD_FINGER\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_SUCCESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_DELETE_FAIL\n\n\n\n\n\n\nDetect\n\n\nUF_OUTPUT_DETECT_INPUT0\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_INPUT1\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_INPUT2\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_WIEGAND\n\n\n\n\n\n\n\n\nUF_OUTPUT_DETECT_FINGER\n\n\n\n\n\n\nEnd Processing\n\n\nUF_OUTPUT_END_PROCESSING\n\n\n\n\n\n\nDuress\n\n\nUF_OUTPUT_VERIFY_DURESS\n\n\n\n\n\n\n\n\nUF_OUTPUT_IDENTIFY_DURESS\n\n\n\n\n\n\nTamper SW\n\n\nUF_OUTPUT_TAMPER_SWITCH_ON\n\n\n\n\n\n\n\n\nUF_OUTPUT_TAMPER_SWITCH_OFF\n\n\n\n\n\n\nSystem\n\n\nUF_OUTPUT_SYS_STARTED\n\n\n\n\n\n\nSmartCard (Available only for BioEntry Smart)\n\n\nUF_OUTPUT_DETECT_SMARTCARD   \n UF_OUTPUT_BAD_SMARTCARD   \n UF_OUTPUT_WAIT_SMARTCARD\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetOutputEventList\n(\n \nUF_OUTPUT_PORT\n \nport\n,\n \nUF_OUTPUT_EVENT\n*\n \nevents\n,\n \nint\n*\n \nnumOfEvent\n \n)\n\n\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\n\nevents\n\nArray of output events to be returned.\n\n\nnumOfEvent\n\nPointer to the number of output events to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\n// To read the output events assigned to OUT0\n\n\nUF_OUTPUT_EVENT\n \nevents\n[\nUF_MAX_OUTPUT_PER_PORT\n];\n\n\nint\n \nnumOfEvent\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetOutputEventList\n(\n \nUF_OUTPUT_PORT0\n,\n \nevents\n,\n\n\n&\nnumOfEvent\n \n);\n\n\n\n\n\n\n\n\nUF_ClearAllOutputEvent\n\u00b6\n\n\nClears all the output events assigned to an output/LED port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearAllOutputEvent\n(\n \nUF_OUTPUT_PORT\n \nport\n \n)\n\n\n\n\nParameters\n \n\n\nport\n\nOutput/LED port.  \n\n\nReturn Values\n \n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ClearOutputEvent\n\u00b6\n\n\nClears the specified output event from the output port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearOutputEvent\n(\n \nUF_OUTPUT_PORT\n \nport\n,\n \nUF_OUTPUT_EVENT\n \nevent\n \n)\n\n\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\n\nevent\n\nOutput event to be deleted from the output/LED port.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_SetOutputEvent\n\u00b6\n\n\nAdds an output event to the specified output/LED port. The characteristics of output signal is also specified.\n\n\n \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nshort\n \ndelay\n;\n \n// t_delay\n\n\n    \nunsigned\n \nshort\n \ncount\n;\n \n// t_count\n\n\n    \nunsigned\n \nshort\n \nactive\n;\n \n// t_high\n\n\n    \nunsigned\n \nshort\n \ninactive\n;\n \n// t_low\n\n\n}\n \nUFOutputSignal\n;\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetOutputEvent\n(\n \nUF_OUTPUT_PORT\n \nport\n,\n \nUF_OUTPUT_EVENT\n \nevent\n,\n \nUFOutputSignal\n \nsignal\n \n)\n\n\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\n\nevent\n\nOutput event to be added.\n\n\nsignal\n\nSignal specification of the output event.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n  \n\n\n// To turn on the LED0 for 500ms when verification succeeds,\n\n\nUFOutputSignal\n \nsignal\n;\n\n\nsignal\n.\ndelay\n \n=\n \n0\n;\n\n\nsignal\n.\ncount\n \n=\n \n1\n;\n\n\nsignal\n.\nactive\n \n=\n \n500\n;\n\n\nsignal\n.\ninactive\n \n=\n \n0\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SetOutputEvent\n(\n \nUF_OUTPUT_LED0\n,\n \nUF_OUTPUT_VERIFY_SUCCESS\n,\n \nsignal\n \n);\n\n\n\n\n\n\n\n\nUF_GetOutputEvent\n\u00b6\n\n\nGets the signal data of an output event on the specified output/LED port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetOutputEvent\n(\n \nUF_OUTPUT_PORT\n \nport\n,\n \nUF_OUTPUT_EVENT\n \nevent\n,\n \nUFOutputSignal\n*\n \nsignal\n \n)\n\n\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\n\nevent\n\nOutput event.\n\n\nsignal\n\nPointer to the signal data to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetOutputStatus\n\u00b6\n\n\nSets the status of an output/LED port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetOutputStatus\n(\n \nUF_OUTPUT_PORT\n \nport\n,\n \nBOOL\n \nstatus\n \n)\n\n\n\n\nParameters\n\n\nport\n\nOutput/LED port.\n\n\nstatus\n\nTRUE for active and FALSE for inactive status.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetLegacyWiegandConfig(Deprecated)\n\u00b6\n\n\nUntil the firmware V1.3, SFM 3500 modules only support 26 bit Wiegand format. Since the firmware V1.4, Extended Wiegand Interface is provided, which is much more powerful and flexible. \nUF_SetLegacyWiegandConfig\n configures the legacy 26 bit Wiegand format and is provided only for firmwares older than V1.4.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetLegacyWiegandConfig\n(\n \nBOOL\n \nenableInput\n,\n \nBOOL\n \nenableOutput\n,\n \nUINT32\n \nfcBits\n,\n \nUINT32\n \nfcCode\n \n)\n\n\n\n\nParameters\n\n\nenableInput\n\nIf TRUE, the module starts verification process when receiving Wiegand inputs.\n\n\nenableOutput\n\nIf TURE, the module outputs the user ID when verification or identification succeeds.\n\n\nfcBits\n\nSpecifies the number of facility bits.\n\n\nfcCode\n\nSpecifies the facility code.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetLegacyWiegandConfig(Deprecated)\n\u00b6\n\n\nGets the configuration of the 26 bit Wiegand format.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetLegacyWiegandConfig\n(\n \nBOOL\n*\n \nenableInput\n,\n \nBOOL\n*\n \nenableOutput\n,\n \nUINT32\n*\n \nfcBits\n,\n \nUINT32\n*\n \nfcCode\n \n)\n\n\n\n\nParameters\n\n\nenableInput\n\nPointer to the input enable status.\n\n\nenableOutput\n\nPointer to the output enable status.\n\n\nfcBits\n\nPointer to the number of facility bits to be returned.\n\n\nfcCode\n\nPointer to the facility code to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_MakeIOConfiguration\n\u00b6\n\n\nMakes IO configuration data to be saved into a file. See the example of \nUF_SaveConfiguration\n for the usage of this function.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_MakeIOConfiguration\n(\n \nUFConfigComponentHeader\n*\n \nconfigHeader\n,\n \nBYTE\n*\n \nconfigData\n \n)\n\n\n\n\nParameters\n\n\nconfigHeader\n\nPointer to the configuration header to be returned.\n\n\nconfigData\n\nPointer to the configuration data to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.15. GPIO API for SFM3000/4000/5000/6000\n\u00b6\n\n\nSFM3000 series modules have 8 GPIO ports, which are configurable for specific functions. The function of each GPIO can be read and programmed via these APIs. . GPIO port can be configured as input, output, shared I/O, Wiegand input, or Wiegand output. In the input mode, enroll, identify, and delete functions are supported. In the output mode, the port can send output patterns corresponding to the various events such as match success, enroll fail, and so on.\n\n\n\n\nUF_GetGPIOConfiguration\n: gets the configuration data of a GPIO port.\n\n\nUF_SetInputGPIO\n: configures an input GPIO port.\n\n\nUF_SetOutputGPIO\n: configures an output GPIO port.\n\n\nUF_SetSharedGPIO\n: configures a shared I/O port.\n\n\nUF_DisableGPIO\n: disables a GPIO port.\n\n\nUF_ClearAllGPIO\n: clears all the GPIO configurations.\n\n\nUF_SetDefaultGPIO\n: resets to default GPIO configurations.\n\n\nUF_EnableWiegandInput\n: enables Wiegand input.\n\n\nUF_EnableWiegandOutput\n: enables Wiegand output.\n\n\nUF_DisableWiegandInput\n: disables Wiegand input.\n\n\nUF_DisableWiegandOutput\n: disables Wiegand output.\n\n\nUF_MakeGPIOConfiguration\n: makes GPIO configuration data to be saved into a file.\n\n\n\n\n\n\nUF_GetGPIOConfiguration\n\u00b6\n\n\nGets the configuration data of a GPIO port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetGPIOConfiguration\n(\n \nUF_GPIO_PORT\n \nport\n,\n \nUF_GPIO_MODE\n*\n \nmode\n,\n \nint\n*\n \nnumOfData\n,\n \nUFGPIOData\n*\n \ndata\n \n)\n\n\n\n\nParameters\n \n\n\nport\n\nGPIO port from \nUF_GPIO_0\n to \nUF_GPIO_7\n.\n\n\nmode\n\nPointer to the GPIO mode to be returned. Available GPIO modes are as follows;  \n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_GPIO_INPUT\n\n\nInput port\n\n\n\n\n\n\nUF_GPIO_OUTPUT\n\n\nOutput port\n\n\n\n\n\n\nUF_GPIO_SHARED_IO\n\n\nShared IO port\n\n\n\n\n\n\nUF_GPIO_WIEGAND_INPUT\n\n\nWiegand input port\n\n\n\n\n\n\nUF_GPIO_WIEGAND_OUTPUT\n\n\nWiegand output port\n\n\n\n\n\n\n\n\nnumOfData\n\nNumber of configuration data assigned to the port.\n\n\ndata\n\nArray of GPIO configuration data to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n  \n\n\n// To retrieve the configuration data of GPIO 0\n\n\nUFGPIOData\n \nconfigData\n[\nUF_MAX_GPIO_OUTPUT_EVENT\n];\n\n\nUF_GPIO_MODE\n \nmode\n;\n\n\nint\n \nnumOfData\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_GetGPIOConfiguration\n(\n \nUF_GPIO_0\n,\n \n&\nmode\n,\n \n&\nnumOfData\n,\n \nconfigData\n \n);\n\n\n\n\n\n\n\n\nUF_SetInputGPIO\n\u00b6\n\n\nConfigures an input GPIO port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetInputGPIO\n(\n \nUF_GPIO_PORT\n \nport\n,\n \nUFGPIOInputData\n \ndata\n \n)\n\n\n\n\nParameters\n\n\nport\n\nGPIO port. Only GPIO 0 to GPIO 3 can be an input port.\n\n\ndata\n\n\nUFGPIOInputData\n is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nshort\n \ninputFunction\n;\n \n// See UF_GPIO_INPUT_FUNC\n\n\n                                \n// in UF_3000IO.h\n\n\n    \nunsigned\n \nshort\n \nactivationLevel\n;\n \n// See UF_GPIO_INPUT_ACTIVATION\n\n\n                                \n// in UF_3000IO.h\n\n\n    \nunsigned\n \nshort\n \ntimeout\n;\n \n// valid only if inputFUnction is\n\n\n                            \n// UF_GPIO_IN_DELETE_ALL or\n\n\n                            \n// UF_GPIO_IN_DELETE_ALL_VERIFICATION\n\n\n    \nunsigned\n \nshort\n \nreserved\n;\n\n\n}\n \nUFGPIOInputData\n;\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\n\n// To assign identify to GPIO 0 with ACTIVE_HIGH signal\n\n\nUFGPIOInputData\n \ninputData\n;\n\n\ninputData\n.\ninputFunction\n \n=\n \nUF_GPIO_IN_IDENTIFY\n;\n\n\ninputData\n.\nactivationLevel\n \n=\n \nUF_GPIO_IN_ACTIVE_HIGH\n;\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_SetInputGPIO\n(\n \nUF_GPIO_0\n,\n \ninputData\n \n);\n\n\n\n\n\n\n\n\nUF_SetOutputGPIO\n\u00b6\n\n\nConfigures an output GPIO port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetOutputGPIO\n(\n \nUF_GPIO_PORT\n \nport\n,\n \nint\n \nnumOfData\n,\n \nUFGPIOOutputData\n*\n \ndata\n \n)\n\n\n\n\nParameters\n\n\nport\n\nGPIO port.\n\n\nnumOfData\n\nNumber of UFGPIOOutputData to be assigned to the GPIO port.\n\n\ndata\n\nArray of UFGPIOOutputData to be assigned to the GPIO port.\n\n\nUFGPIOOutputData\n is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nshort\n \nevent\n;\n \n// see UF_GPIO_OUTPUT_EVENT\n\n\n                        \n// in UF_3000IO.h\n\n\n    \nunsigned\n \nshort\n \nlevel\n;\n \n// see UF_GPIO_OUTPUT_LEVEL\n\n\n    \nunsigned\n \nshort\n \ninterval\n;\n \n// in milliseconds\n\n\n    \nunsigned\n \nshort\n \nblinkingPeriod\n;\n \n// valid only if the level is\n\n\n                \n// UF_GPIO_OUT_HIGH_BLINK or UF_GPIO_OUT_LOW_BLINK\n\n\n}\n \nUFGPIOOutputData\n;\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetSharedGPIO\n\u00b6\n\n\nConfigures the shared I/O GPIO port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetSharedGPIO\n(\n \nUF_GPIO_PORT\n \nport\n,\n \nUFGPIOInputData\n \ninputData\n,\n \nint\n \nnumOfOutputData\n,\n \nUFGPIOOutputData\n*\n \noutputData\n \n)\n\n\n\n\nParameters\n\n\nport\n\nGPIO port. Only GPIO 0 to GPIO 3 can be a shared I/O port.\n\n\ninputData\n\nInput data to be assigned.\n\n\nnumOfOutputData\n\nNumber of UFGPIOOutputData to be assigned.\n\n\noutputData\n\nArray of UFGPIOOutputData to be assigned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DisableGPIO\n\u00b6\n\n\nDisables a GPIO port.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DisableGPIO\n(\n \nUF_GPIO_PORT\n \nport\n \n)\n\n\n\n\nParameters\n\n\nport\n\nGPIO port.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ClearAllGPIO\n\u00b6\n\n\nClears all the configurations of GPIO ports.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearAllGPIO\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetDefaultGPIO\n\u00b6\n\n\nResets the configurations of GPIO ports to default.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetDefaultGPIO\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_EnableWiegandInput\n\u00b6\n\n\nEnables Wiegand input. Wiegand input uses GPIO 2 and GPIO 3 as input signal.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_EnableWiegandInput\n(\n \nUFGPIOWiegandData\n \ndata\n \n)\n\n\n\n\nParameters\n\n\ndata\n\n\nUFGPIOWiegandData\n is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nshort\n \ntotalBits\n;\n \n// fixed at 26 bit\n\n\n    \nunsigned\n \nshort\n \nfcBits\n;\n \n// number of facility bits\n\n\n    \nunsigned\n \nshort\n \nidBits\n;\n \n// number of id bits\n\n\n    \nunsigned\n \nshort\n \nfcCode\n;\n \n// facility code\n\n\n}\n \nUFGPIOWiegandData\n;\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_EnableWiegandOutput\n\u00b6\n\n\nEnables Wiegand output. Wiegand output use GPIO 4 and GPIO 5 as output signal.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_EnableWiegandOutput\n(\n \nUFGPIOWiegandData\n \ndata\n \n)\n\n\n\n\nParameters\n\n\ndata\n\nWiegand configuration data.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DisableWiegandInput\n\u00b6\n\n\nDisables Wiegand input.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DisableWiegandInput\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DisableWiegandOutput\n\u00b6\n\n\nDisables Wiegand output.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DisableWiegandOutput\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_MakeGPIOConfiguration\n\u00b6\n\n\nMakes GPIO configuration data to be saved into a file.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_MakeGPIOConfiguration\n(\n \nUFConfigComponentHeader\n*\n \nconfigHeader\n,\n \nBYTE\n*\n \nconfigData\n \n)\n\n\n\n\nParameters\n\n\nconfigHeader\n\nPointer to the configuration header.\n\n\nconfigData\n\nPointer to the configuration data.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n\nSee CUniFingerUI3000IOView::OnGpioSaveFile in UniFingerUI source codes.\n\n\n\n\n\n\n3.16. User Memory API\n\u00b6\n\n\nSFM modules reserve 256 bytes for user data. This area can be read and written by these APIs.\n- \nUF_WriteUserMemory\n: writes data to the user memory.\n- \nUF_ReadUserMemory\n: reads the contents of the user memory.\n\n\n\n\nUF_WriteUserMemory\n\u00b6\n\n\nWrites data into the user memory.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_WriteUserMemory\n(\n \nBYTE\n*\n \nmemory\n \n)\n\n\n\n\nParameters\n\n\nmemory\n\nPointer to the 256 byte array to be written.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadUserMemory\n\u00b6\n\n\nReads the contents of the user memory.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadUserMemory\n(\n \nBYTE\n*\n \nmemory\n \n)\n\n\n\n\nParameters\n\n\nmemory\n\nPointer to the 256 byte array to be read.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.17. Log Management API\n\u00b6\n\n\nSFM3500 modules provide logging facility for recording important events. Users can receive logs from the module and delete unwanted ones. The format of a log record is as follows;\n\n\n\n\n\n\n\n\nItem\n\n\nDescription\n\n\nSize\n\n\n\n\n\n\n\n\n\n\nSource\n\n\nUF_LOG_SOURCE_HOST_PORT\n\n\n1 byte\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_AUX_PORT\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_WIEGAND_INPUT\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_IN0\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_IN1\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_IN2\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_FREESCAN\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_SMARTCARD\n\n\n\n\n\n\n\n\nEvent ID\n\n\nOne of the UF_OUTPUT_EVENT\n\n\n1 byte\n\n\n\n\n\n\nDate\n\n\n(DD << 16) / (MM << 8) / YY\n\n\n3 bytes\n\n\n\n\n\n\nTime\n\n\n(ss << 16) / (mm << 8) / hh\n\n\n3 bytes\n\n\n\n\n\n\nUser ID\n\n\nUser ID\n\n\n4 bytes\n\n\n\n\n\n\nCustom Field\n\n\nCustomizable by user\n\n\n4 bytes\n\n\n\n\n\n\n\n\nIn V1.6 firmware, there are two enhancements for logging functions. First, 4 byte custom field is added to log records. Making use of this field, users can add customized events to log records. Second, the log cache is added for real-time monitoring.\n\n\n\n\nUF_SetTime\n: sets the time of the module.\n\n\nUF_GetTime\n: gets the time of the module.\n\n\nUF_GetNumOfLog\n: gets the number of log records.\n\n\nUF_ReadLog\n: reads log records.\n\n\nUF_ReadLatestLog\n: reads latest log records.\n\n\nUF_DeleteOldestLog\n: deletes oldest log records.\n\n\nUF_DeleteAllLog\n: deletes all the log records.\n\n\nUF_ClearLogCache\n: clears the log cache.\n\n\nUF_ReadLogCache\n: reads the log records in the cache.\n\n\nUF_SetCustomLogField\n: sets the custom field of log records.\n\n\nUF_GetCustomLogField\n: gets the custom field of log records.\n\n\n\n\n\n\nUF_SetTime\n\u00b6\n\n\nSets the time of the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetTime\n(\n \ntime_t\n \ntimeVal\n \n)\n\n\n\n\nParameters\n\n\ntimeVal\n\nNumber of seconds elapsed since midnight (00:00:00), January 1, 1970.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetTime\n\u00b6\n\n\nGets the time of the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetTime\n(\n \ntime_t\n*\n \ntimeVal\n \n)\n\n\n\n\nParameters\n\n\ntimeVal\n\nPointer to the time value to be returned by the module.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_GetNumOfLog\n\u00b6\n\n\nRetrieves the number of log records.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetNumOfLog\n(\n \nint\n*\n \nnumOfLog\n,\n \nint\n*\n \nnumOfTotalLog\n \n)\n\n\n\n\nParameters\n\n\nnumOfLog\n\nPointer to the number of log records to be returned.\n\n\nnumOfTotalLog\n\nPointer to the maximum log records to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_ReadLog\n\u00b6\n\n\nReads log records.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadLog\n(\n \nint\n \nstartIndex\n,\n \nint\n \ncount\n,\n \nUFLogRecord\n*\n \nlogRecord\n,\n \nint\n*\n \nreadCount\n \n)\n\n\n\n\nParameters\n\n\nstartIndex\n\nStart index of log records to be read.\n\n\ncount\n\nNumber of log records to be read.\n\n\nlogRecord\n\nPointer to the log records to be read.\n\n\nreadCount\n\nPointer to the number of log records actually read.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadLatestLog\n\u00b6\n\n\nReads latest log records.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadLatestLog\n(\n \nint\n \ncount\n,\n \nUFLogRecord\n*\n \nlogRecord\n,\n \nint\n*\n \nreadCount\n \n)\n\n\n\n\nParameters\n\n\ncount\n\nNumber of latest log records to be read.\n\n\nlogRecord\n\nPointer to the log records to be read.\n\n\nreadCount\n\nPointer to the number of log records actually read.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteOldestLog\n\u00b6\n\n\nDeletes oldest log records.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteOldestLog\n(\n \nint\n \ncount\n,\n \nint\n*\n \ndeletedCount\n \n)\n\n\n\n\nParameters\n\n\ncount\n\nNumber of oldest log records to be deleted. It should be a multiple of 256.\n\n\ndeletedCount\n\nPointer to the number of log records actually deleted.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteAllLog\n\u00b6\n\n\nDeletes all the log records.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAllLog\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ClearLogCache\n\u00b6\n\n\nClears the log cache.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearLogCache\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadLogCache\n\u00b6\n\n\nReads the log records in the cache. After reading, the cache will be cleared. The maximum number of log records in the cache is 256.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadLogCache\n(\n \nint\n \ndataPacketSize\n,\n \nint\n*\n \nnumOfLog\n,\n \nUFLogRecord\n*\n \nlogRecord\n \n)\n\n\n\n\nParameters\n\n\ndataPacketSize\n\nData packet size used in Extended Data Transfer protocol.\n\n\nnumOfLog\n\nPointer to the number of log records to be returned.\n\n\nlogRecord\n\nPointer to the log records to be returned. This pointer should be preallocated large enough to store the log records.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetCustomLogField\n\u00b6\n\n\nThere is a 4 byte reserved field in each log record. This function is used for setting this custom value. If the custom field is not set, it will be filled with NULL.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetCustomLogField\n(\n \nUF_LOG_SOURCE\n \nsource\n,\n \nunsigned\n \ncustomField\n \n)\n\n\n\n\nParameters\n\n\nsource\n\nUsers can set 4 different custom values according to the source of log records.  \n\n\n\n\n\n\n\n\nSource\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_LOG_SOURCE_OTHER\n\n\nIf the log is generated by Packet Protocol commands or freescan, this value will be used.\n\n\n\n\n\n\nUF_LOG_SOURCE_IN0   \n UF_LOG_SOURCE_IN1   \n UF_LOG_SOURCE_IN2\n\n\nIf the log is generated by an Input port, the respective values will be used.\n\n\n\n\n\n\n\n\ncustomField\n\n4 byte custom value.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetCustomLogField\n\u00b6\n\n\nReads the custom value of the specified log source.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetCustomLogField\n(\n \nUF_LOG_SOURCE\n \nsource\n,\n \nunsigned\n*\n \ncustomField\n \n)\n\n\n\n\nParameters\n  \n\n\nsource\n\nLog source.\n\n\ncustomField\n\nPointer to the 4 byte custom value to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.18. Extended Wiegand API\n\u00b6\n\n\nExtended Wiegand Interface supports up to 64 bit Wiegand formats. The only constraint is that the ID field is limited to 32 bits. It also supports advanced options such as Fail ID and Inverse Parity on Fail.\n\n\n\n\nUF_SetWiegandFormat\n: configures the Wiegand format.\n\n\nUF_GetWiegandFormat\n: gets the Wiegand format information.\n\n\nUF_SetWiegandIO\n: configures the Wiegand IO ports.\n\n\nUF_GetWiegandIO\n: gets the configurations of the Wiegand IO ports.\n\n\nUF_SetWiegandOption\n: sets the advanced options.\n\n\nUF_GetWiegandOption\n: gets the advanced options.\n\n\nUF_SetAltValue\n: sets the alternative value of a field.\n\n\nUF_ClearAltValue\n: clears the alternative value of a field.\n\n\nUF_GetAltValue\n: gets the alternative value of a field.\n\n\nUF_MakeWiegandConfiguration\n: makes Wiegand configuration data to be saved into a file.\n\n\n\n\n\n\nUF_SetWiegandFormat\n\u00b6\n\n\nConfigures the Wiegand format.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetWiegandFormat\n(\n \nUFWiegandFormatHeader\n*\n \nheader\n,\n \nUFWiegandFormatData\n*\n \ndata\n,\n \nint\n \npulseWidth\n,\n \nint\n \npulseInterval\n \n)\n\n\n\n\nParameters\n\n\nheader\n\nUFWiegandFormatHeader is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUF_WIEGAND_FORMAT\n \nformat\n;\n \n// UF_WIEGAND_26BIT,\n\n\n                            \n// UF_WIEGAND_PASS_THRU,\n\n\n                            \n// UF_WIEGAND_CUSTOM\n\n\n    \nint\n             \ntotalBits\n;\n\n\n}\n \nUFWiegandFormatHeader\n;\n\n\n\n\ndata\n\nWiegand format data. If the format is UF_WIEGAND_26BIT, there is no format data and this parameter will be ignored. UFWiegandFormatData is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nint\n                \nnumOfIDField\n;\n\n\n    \nUFWiegandField\n     \nfield\n[\nMAX_WIEGAND_FIELD\n];\n\n\n}\n \nUFWiegandPassThruData\n;\n\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nint\n                \nnumOfField\n;\n\n\n    \nUINT32\n             \nidFieldMask\n;\n\n\n    \nUFWiegandField\n     \nfield\n[\nMAX_WIEGAND_FIELD\n];\n\n\n    \nint\n                \nnumOfParity\n;\n\n\n    \nUFWiegandParity\n    \nparity\n[\nMAX_WIEGAND_PARITY\n];\n\n\n}\n \nUFWiegandCustomData\n;\n\n\n\ntypedef\n \nunion\n \n{\n\n\n    \nUFWiegandPassThruData\n   \npassThruData\n;\n\n\n    \nUFWiegandCustomData\n     \ncustomData\n;\n\n\n}\n \nUFWiegandFormatData\n;\n\n\n\n\npulseWidth\n\nSpecifies the width of Wiegand signal.\n\n\npulseInterval\n\nSpecifies the interval of Wiegand signal.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetWiegandFormat\n\u00b6\n\n\nGets the Wiegand format data.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetWiegandFormat\n(\n \nUFWiegandFormatHeader\n*\n \nheader\n,\n \nUFWiegandFormatData\n*\n \ndata\n,\n \nint\n*\n \npulseWidth\n,\n \nint\n*\n \npulseInterval\n \n)\n\n\n\n\nParameters\n\n\nheader\n\nPointer to the format header to be returned.\n\n\ndata\n\nPointer to the format data to be returned.\n\n\npulseWidth\n\nPointer to the width of Wiegand signal.\n\n\npulseInterval\n\nPointer to the interval of Wiegand signal.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetWiegandIO\n\u00b6\n\n\nConfigures the Wiegand IO ports.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetWiegandIO\n(\n \nUF_WIEGAND_INPUT_MODE\n \ninputMode\n,\n \nUF_WIEGAND_OUTPUT_MODE\n \noutputMode\n,\n \nint\n \nnumOfChar\n \n)\n\n\n\n\nParameters\n\n\ninputMode\n   \n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_WIEGAND_INPUT_DISABLE\n\n\nIgnores Wiegand inputs.\n\n\n\n\n\n\nUF_WIEGAND_INPUT_VERIFY\n\n\nStarts verification after receiving Wiegand inputs.\n\n\n\n\n\n\n\n\noutputMode\n   \n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_DISABLE\n\n\nDisables Wiegand output.\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_WIEGAND_ONLY\n\n\nOutputs Wiegand signal only if the verification is initiated by Wiegand input.\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_ALL\n\n\nOutputs Wiegand signal if matching succeeds.\n\n\n\n\n\n\nUF_WIEGAND_OUTPUT_ABA_TRACK_II\n\n\nOutputs ABA Track II characters instead of Wiegand signal.\n\n\n\n\n\n\n\n\nnumOfChar\n\nNumber of characters in ABA Track II output format. It is ignored if outputMode is not \nUF_WIEGAND_OUTPUT_ABA_TRACK_II\n.\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetWiegandIO\n\u00b6\n\n\nGets the configurations of Wiegand IO ports.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetWiegandIO\n(\n \nUF_WIEGAND_INPUT_MODE\n*\n \ninputMode\n,\n \nUF_WIEGAND_OUTPUT_MODE\n*\n \noutputMode\n,\n \nint\n*\n \nnumOfChar\n \n)\n\n\n\n\nParameters\n\n\ninputMode\n\nPointer to Wiegand input mode to be returned.\n\n\noutputMode\n\nPointer to Wiegand output mode to be returned.\n\n\nnumOfChar\n\nPointer to the number of characters in ABA Track II output format. It is ignored if outputMode is not \nUF_WIEGAND_OUTPUT_ABA_TRACK_II\n.\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetWiegandOption\n\u00b6\n\n\nSets advanced options.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetWiegandOption\n(\n \nBOOL\n \nuseFailID\n,\n \nUINT32\n \nfailID\n,\n \nBOOL\n \ninverseParityOnFail\n \n)\n\n\n\n\nParameters\n\n\nuseFailID\n\nNormally the module outputs Wiegand signal only if matching succeeds. If this option is TRUE, the module outputs the fail ID when matching fails.\n\n\nfailID\n\nID to be output if useFailID is \nTRUE\n.\n\n\ninverseParityOnFail\n\nIf this option is \nTRUE\n, the module outputs Wiegand signals with inverted parities when matching fails.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetWiegandOption\n\u00b6\n\n\nGets the advanced options.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetWiegandOption\n(\n \nBOOL\n*\n \nuseFailID\n,\n \nUINT32\n*\n \nfailID\n,\n \nBOOL\n*\n \ninverseParityOnFail\n \n)\n\n\n\n\nParameters\n\n\nuserFailID\n\nPointer to the useFailID option to be returned.\n\n\nfailID\n\nPointer to the fail ID to be returned.\n\n\ninverseParityOnFail\n\nPointer to the inverseParityOnFail option to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetAltValue\n\u00b6\n\n\nIf the Wiegand format is UF_WIEGAND_26BIT or UF_WIEGAND_CUSTOM, users can set alternative values for non-ID fields. If an alternative value is set for a non-ID field, the module will replace the field with the alternative value before outputting the signal.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetAltValue\n(\n \nint\n \nfieldIndex\n,\n \nUINT32\n \nvalue\n \n)\n\n\n\n\nParameters\n\n\nfieldIndex\n\nIndex of the field.\n\n\nvalue\n\nAlternative value of the field.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ClearAltValue\n\u00b6\n\n\nClears the alternative value of a field.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearAltValue\n(\n \nint\n \nfieldIndex\n \n)\n\n\n\n\nParameters\n\n\nfieldIndex\n\nIndex of the field.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetAltValue\n\u00b6\n\n\nGets the alternative value of a field.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetAltValue\n(\n \nint\n \nfieldIndex\n,\n \nUINT32\n*\n \nvalue\n \n)\n\n\n\n\nParameters\n\n\nfieldIndex\n\nIndex of the field.\n\n\nvalue\n\nAlternative value of the field to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. If alternative value is not set to the field, return \nUF_ERR_NOT_FOUND\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_MakeWiegandConfiguration\n\u00b6\n\n\nMakes Wiegand configuration data to be saved into a file.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_MakeWiegandConfiguration\n(\n \nUFConfigComponentHeader\n*\n \nconfigHeader\n,\n \nBYTE\n*\n \nconfigData\n \n)\n\n\n\n\nParameters\n\n\nconfigHeader\n\nPointer to the configuration header to be returned.\n\n\nconfigData\n\nPointer to the configuration data to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\nExample\n\nSee CUniFingerUIWiegandView::OnWiegandSaveFile in UniFingerUI source codes.\n\n\n\n\n\n\n3.19. Wiegand Command Card API\n\u00b6\n\n\nUsers can map an input function to a Wiegand ID. When the module detects the mapped IDs in Wiegand input port, it will execute the corresponding input function.\n\n\n\n\nUF_AddWiegandCommandCard\n: adds a mapping of input function to the specified ID.\n\n\nUF_GetWiegandCommandCardList\n: gets all the mapping data.\n\n\nUF_ClearAllWiegandCommandCard\n: clears all the mappings.\n\n\n\n\n\n\nUF_AddWiegandCommandCard\n\u00b6\n\n\nMaps the input function to the specified ID.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_AddWiegandCommandCard\n(\n \nUINT32\n \nuserID\n,\n \nUF_INPUT_FUNC\n \nfunction\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nfunction\n\nAmong the input functions, the followings can be assigned to command cards.  \n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_INPUT_ENROLL\n\n\nEnroll\n\n\n\n\n\n\nUF_INPUT_IDENTIFY\n\n\nIdentify\n\n\n\n\n\n\nUF_INPUT_DELETE\n\n\nDelete\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL\n\n\nDelete all\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND\n\n\nEnroll by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND\n\n\nDelete by Wiegand ID\n\n\n\n\n\n\nUF_INPUT_ENROLL_VERIFICATION\n\n\nEnroll after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION\n\n\nEnroll by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_VERIFICATION\n\n\nDelete after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_BY_WIEGAND_VERIFICATION\n\n\nDelete by Wiegand ID after administrator\u2019s verification\n\n\n\n\n\n\nUF_INPUT_DELETE_ALL_VERIFICATION\n\n\nDelete all after administrator\u2019s verification\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetWiegandCommandCardList\n\u00b6\n\n\nGets the list of all the command cards.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetWiegandCommandCardList\n(\n \nint\n*\n \nnumOfCard\n,\n \nUFWiegandCommandCard\n*\n \ncommandCard\n \n)\n\n\n\n\nParameters\n\n\nnumOfCard\n\nNumber of command cards to be returned.\n\n\ncommandCard\n\nArray of command card information to be returned. UFWiegandCommandCard is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUINT32\n          \nuserID\n;\n\n\n    \nUF_INPUT_FUNC\n   \nfunction\n;\n\n\n}\n \nUFWiegandCommandCard\n;\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\nUF_ClearAllWiegandCommandCard\n\u00b6\n\n\nClears all the command card mappings.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ClearAllWiegandCommandCard\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.20. SmartCard API\n\u00b6\n\n\nBioEntry Smart readers support MIFARE types of smartcards. These functions provide basic functionalities such as read, write, and format smartcards.\n\n\n\n\nUF_ReadSmartCard\n: reads a smartcard.\n\n\nUF_ReadSmartCardWithAG\n: reads a smartcard with access group information.\n\n\nUF_WriteSmartCard\n: writes templates into a smartcard.\n\n\nUF_WriteSmartCardWithAG\n: writes templates and access group information into a smartcard.\n\n\nUF_WriteSmartCardWithEntranceLimit\n: writes templates, access group information, and entrance limit into a smartcard.\n\n\nUF_FormatSmartCard\n: formats a smartcard.\n\n\nUF_SetSmartCardMode\n: sets the operation mode.\n\n\nUF_GetSmartCardMode\n: gets the operation mode.\n\n\nUF_ChangePrimaryKey\n: changes the primary key.\n\n\nUF_ChangeSecondaryKey\n: changes the secondary key.\n\n\nUF_SetKeyOption\n: sets the site key options.\n\n\nUF_GetKeyOption\n: gets the site key options.\n\n\nUF_SetCardLayout\n: sets the layout of smartcard.\n\n\nUF_GetCardLayout\n: gets the layout of smartcard.\n\n\nUF_SetSmartCardCallback\n: sets the callback function for smartcard operation.\n\n\n\n\n\n\nUF_ReadSmartCard\n\u00b6\n\n\nReads a smart card.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadSmartCard\n(\n \nUFCardHeader\n*\n \nheader\n,\n \nBYTE\n*\n \ntemplate1\n,\n \nBYTE\n*\n \ntemplate2\n \n)\n\n\n\n\nParameters\n\n\nheader\n\n\nUFCardHeader\n is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUINT32\n \ncsn\n;\n \n// 4 byte card serial number\n\n\n    \nUINT32\n \nwiegandLower\n;\n \n// lower 4 bytes of Wiegand string\n\n\n    \nUINT32\n \nwiegandHigher\n;\n// higher 4 bytes of Wiegand string\n\n\n    \nBYTE\n \nversion\n;\n\n\n    \nBYTE\n \ncommandType\n;\n \n// reserved for command cards. In V1.7 or\n\n\n                \n// later firmware, this field is used for\n\n\n                \n// storing entrance limit for non-command cards.\n\n\n    \nBYTE\n \nsecurityLevel\n;\n \n// security level of the user\n\n\n    \nBYTE\n \nnumOfTemplate\n;\n \n// number of templates stored\n\n\n                        \n// in the card\n\n\n    \nBYTE\n \ntemplate1Duress\n;\n \n// 1 if the template1 is\n\n\n                        \n// of duress finger\n\n\n    \nBYTE\n \ntemplate1Length\n[\n2\n];\n \n// length of template1\n\n\n    \nBYTE\n \ntemplate2Duress\n;\n\n\n    \nBYTE\n \ntemplate2Length\n[\n2\n];\n\n\n}\n \nUFCardHeader\n;\n\n\n\n\ntemplate1\n\nPointer to the first template data read from the smartcard.\n\n\ntemplate2\n\nPointer to the second template data read from the smartcard.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadSmartCardWithAG\n\u00b6\n\n\nReads a smart card with access group information. As for access group, see \nUF_AddAccessGroup\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadSmartCardWithAG\n(\n \nUFCardHeader\n*\n \nheader\n,\n \nBYTE\n*\n \ntemplate1\n,\n \nBYTE\n*\n \ntemplate2\n,\n \nint\n*\n \nnumOfAccessGroup\n,\n \nBYTE\n*\n \naccessGroup\n \n)\n\n\n\n\nParameters\n\n\nheader\n\nPointer to the UFCardHeader to be returned.\n\n\ntemplate1\n\nPointer to the first template data read from the smartcard.\n\n\ntemplate2\n\nPointer to the second template data read from the smartcard.\n\n\nnumOfAccessGroup\n\nPointer to the number of access groups assigned to the smartcard.\n\n\naccessGroup\n\nPointer to the IDs of access groups assigned to the smartcard. The length of each ID is 1 byte.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_WriteSmartCard\n\u00b6\n\n\nWrites template data and header information into a smartcard.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_WriteSmartCard\n(\n \nUINT32\n \nuserID\n,\n \nUF_CARD_SECURITY_LEVEL\n \nsecurityLevel\n,\n \nint\n \nnumOfTemplate\n,\n \nint\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplate1\n,\n \nBOOL\n \nduress1\n,\n \nBYTE\n*\n \ntemplate2\n,\n \nBOOL\n \nduress2\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsecurityLevel\n\nSecurity level. If it is set to \nUF_SECURITY_READER_DEFAULT\n, the security level is same as defined in the BioEntry reader. If it is set to \nUF_SECURITY_BYPASS\n, the BioEntry reader will bypass the fingerprint authentication.\n\n\nnumOfTemplate\n\nNumber of templates to be written.\n\n\ntemplateSize\n\nSize of a template.\n\n\ntemplate1\n\nPointer to the first template data.\n\n\nduress1\n\nSpecifies if the first template is of a duress finger.\n\n\ntemplate2\n\nPointer to the second template data.\n\n\nduress2\n\nSpecifies if the second template is of a duress finger.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_WriteSmartCardWithAG\n\u00b6\n\n\nWrites template data and access group information into a smartcard.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_WriteSmartCardWithAG\n(\n \nUINT32\n \nuserID\n,\n \nUF_CARD_SECURITY_LEVEL\n \nsecurityLevel\n,\n \nint\n \nnumOfTemplate\n,\n \nint\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplate1\n,\n \nBOOL\n \nduress1\n,\n \nBYTE\n*\n \ntemplate2\n,\n \nBOOL\n \nduress2\n,\n \nint\n \nnumOfAccessGroup\n,\n \nBYTE\n*\n \naccessGroup\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsecurityLevel\n\nSecurity level. If it is set to \nUF_SECURITY_READER_DEFAULT\n, the security level is same as defined in the BioEntry reader. If it is set to \nUF_SECURITY_BYPASS\n, the BioEntry reader will bypass the fingerprint authentication.\n\n\nnumOfTemplate\n\nNumber of templates to be written.\n\n\ntemplateSize\n\nSize of a template.\n\n\ntemplate1\n\nPointer to the first template data.\n\n\nduress1\n\nSpecifies if the first template is of a duress finger.\n\n\ntemplate2\n\nPointer to the second template data.\n\n\nduress2\n\nSpecifies if the second template is of a duress finger.\n\n\nnumOfAccessGroup\n\nNumber of access groups assigned to the smartcard.\n\n\naccessGroup\n\nPointer to the IDs of access group to be written.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_WriteSmartCardWithEntranceLimit\n\u00b6\n\n\nWrites template data, access group, and entrance limit information into a smartcard.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_WriteSmartCardWithEntranceLimit\n(\n \nUINT32\n \nuserID\n,\n \nUF_CARD_SECURITY_LEVEL\n \nsecurityLevel\n,\n \nint\n \nentranceLimit\n,\n \nint\n \nnumOfTemplate\n,\n \nint\n \ntemplateSize\n,\n \nBYTE\n*\n \ntemplate1\n,\n \nBOOL\n \nduress1\n,\n \nBYTE\n*\n \ntemplate2\n,\n \nBOOL\n \nduress2\n,\n \nint\n \nnumOfAccessGroup\n,\n \nBYTE\n*\n \naccessGroup\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nsecurityLevel\n\nSecurity level. If it is set to \nUF_SECURITY_READER_DEFAULT\n, the security level is same as defined in the BioEntry reader. If it is set to \nUF_SECURITY_BYPASS\n, the BioEntry reader will bypass the fingerprint authentication.\n\nentranceLimit\n\nEntrance limit between 0 and 7.\n\n\nnumOfTemplate\n\nNumber of templates to be written.\n\n\ntemplateSize\n\nSize of a template.\n\n\ntemplate1\n\nPointer to the first template data.\n\n\nduress1\n\nSpecifies if the first template is of a duress finger.\n\n\ntemplate2\n\nPointer to the second template data.\n\n\nduress2\n\nSpecifies if the second template is of a duress finger.\n\n\nnumOfAccessGroup\n\nNumber of access groups assigned to the smartcard.\n\n\naccessGroup\n\nPointer to the IDs of access group to be written.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_FormatSmartCard\n\u00b6\n\n\nFormats a smartcard.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_FormatSmartCard\n(\n \nBOOL\n \ntemplateOnly\n \n)\n\n\n\n\nParameters\n\n\ntemplateOnly\n\nIf \nTRUE\n, erases only the template area and don\u2019t change the header\n\ninformation. If \nFALSE\n, erase the header information, too.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetSmartCardMode\n\u00b6\n\n\nSets the operation mode of the BioEntry Smart reader.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetSmartCardMode\n(\n \nUF_CARD_MODE\n \nmode\n \n)\n\n\n\n\nParameters\n\n\nmode\n\nOperation mode.  \n\n\n\n\n\n\n\n\nMode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUF_CARD_DISABLE\n\n\nDisables the smartcard operation.\n\n\n\n\n\n\nUF_CARD_VERIFY_ID\n\n\nAfter detecting a smartcard, verifies the fingerprint input with the templates stored in the BioEntry reader.\n\n\n\n\n\n\nUF_CARD_VERIFY_TEMPLATE\n\n\nAfter detecting a smartcard, verifies the fingerprint input with the templates stored in the card.\n\n\n\n\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetSmartCardMode\n\u00b6\n\n\nGets the operation mode.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetSmartCardMode\n(\n \nUF_CARD_MODE\n*\n \nmode\n \n)\n\n\n\n\nParameters\n\n\nmode\n\nPointer to the operation mode to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ChangePrimaryKey\n\u00b6\n\n\nTo prevent illegal access, MIFARE card is encrypted using 48bit site key. The site key should be handled with utmost caution. If it is disclosed, the data on the smartcard will not be secure any more. \nUF_ChangePrimaryKey\n is used to change the primary site key.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ChangePrimaryKey\n(\n \nBYTE\n*\n \noldPrimaryKey\n,\n \nBYTE\n*\n \nnewPrimaryKey\n \n)\n\n\n\n\nParameters\n\n\noldPrimaryKey\n\nPointer to the old site key.\n\n\nnewPrimaryKey\n\nPointer to the new site key.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ChangeSecondaryKey\n\u00b6\n\n\nChanges the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by \nUF_SetKeyOption\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ChangeSecondaryKey\n(\n \nBYTE\n*\n \nprimaryKey\n,\n \nBYTE\n*\n \nnewSecondaryKey\n \n)\n\n\n\n\nParameters\n\n\nprimaryKey\n\nPointer to the primary key.\n\n\nnewSecondaryKey\n\nPointer to the new secondary key.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ChangeSecondaryKey\n\u00b6\n\n\nChanges the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by \nUF_SetKeyOption\n.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ChangeSecondaryKey\n(\n \nBYTE\n*\n \nprimaryKey\n,\n \nBYTE\n*\n \nnewSecondaryKey\n \n)\n\n\n\n\nParameters\n\n\nprimaryKey\n\nPointer to the primary key.\n\n\nnewSecondaryKey\n\nPointer to the new secondary key.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetKeyOption\n\u00b6\n\n\nWhen changing the site key, BioEntry readers have to handle cards with new site key and cards with old site key at the same time. In that case, useSecondaryKey option can be used. If the secondary key is set to old site key, the reader will handle both types of cards. If autoUpdate option is on, the reader automatically replaces the old site key with new one whenever detecting a smartcard with old key.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetKeyOption\n(\n \nBYTE\n*\n \nprimaryKey\n,\n \nBOOL\n \nuseSecondaryKey\n,\n \nBOOL\n \nautoUpdate\n \n)\n\n\n\n\nParameters\n\n\nprimaryKey\n\nPointer to the primary key.\n\n\nuseSecondaryKey\n\nIf TRUE, process the cards encrypted with the secondary key.\n\n\nautoUpdate\n\nIf TRUE, replace the secondary key with primary key when detecting a smartcard encrypted with the secondary key.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetKeyOption\n\u00b6\n\n\nGets the site key options.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetKeyOption\n(\n \nBOOL\n*\n \nuseSecondaryKey\n,\n \nBOOL\n*\n \nautoUpdate\n \n)\n\n\n\n\nParameters\n\n\nuseSecondaryKey\n\nPointer to userSecondaryKey option.\n\n\nautoUpdate\n\nPointer to autoUpdate option.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_SetCardLayout\n\u00b6\n\n\nChanges the layout of the smartcard. By default, a smartcard stores two fingerprint templates. If there are not sufficient spaces on the card, or some blocks of it are reserved for other data, users can change the layout using this function. Changing card layout should be handled with utmost caution. If you aren\u2019t sure what to do, contact to \nsupport@supremainc.com\n first before trying yourself.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetCardLayout\n(\n \nUFCardLayout\n*\n \nlayout\n \n)\n\n\n\n\nParameters\n\n\nlayout\n\nPointer to the layout information. \nUFCardLayout\n is defined as follows;  \n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nshort\n    \ntemplateSize\n;\n\n\n    \nBYTE\n              \nheaderBlock\n;\n\n\n    \nBYTE\n              \ntemplate1StartBlock\n;\n\n\n    \nBYTE\n              \ntemplate1BlockSize\n;\n\n\n    \nBYTE\n              \ntemplate2StartBlock\n;\n\n\n    \nBYTE\n              \ntemplate2BlockSize\n;\n\n\n}\n \nUFCardLayout\n;\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetCardLayout\n\u00b6\n\n\nGets the card layout information.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetCardLayout\n(\n \nUFCardLayout\n*\n \nlayout\n \n)\n\n\n\n\nParameters\n\n\nlayout\n\nPointer to \nUFCardLayout\n.\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetSmartCardCallback\n\u00b6\n\n\nSets the callback function for smartcard operation. This callback is called after scanning a smartcard successfully.\n\n\n\n\nDescription\n\n\nvoid\n \nUF_SetSmartCardCallback\n(\n \nvoid\n \n(\n*\ncallback\n)(\n \nBYTE\n \n)\n \n)\n\n\n\n\nParameters\n\n\ncallback\n\nPointer to the callback function.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.21. Access Control API\n\u00b6\n\n\nSince V1.6 firmware, BioEntry readers provide access control features such as time schedule and access group. By using these functions, user\u2019s access can be controlled in finer detail.\n\n\n\n\nUF_AddTimeSchedule\n: adds a time schedule.\n\n\nUF_GetTimeSchedule\n: reads the specified time schedule.\n\n\nUF_DeleteTimeSchedule\n: deletes a time schedule.\n\n\nUF_DeleteAllTimeSchedule\n: deletes all time schedules.\n\n\nUF_AddHoliday\n: adds a holiday schedule.\n\n\nUF_GetHoliday\n: reads the specified holiday schedule.\n\n\nUF_DeleteHoliday\n: deletes a holiday schedule.\n\n\nUF_DeleteAllHoliday\n: deletes all holiday schedules.\n\n\nUF_AddAccessGroup\n: adds an access group.\n\n\nUF_GetAccessGroup\n: reads the specified access group.\n\n\nUF_DeleteAccessGroup\n: deletes an access group.\n\n\nUF_DeleteAllAccessGroup\n: deletes all access groups.\n\n\nUF_SetUserAccessGroup\n: assigns access groups to a user.\n\n\nUF_GetUserAccessGroup\n: gets the access groups of a user.\n\n\n\n\n\n\nUF_AddTimeSchedule\n\u00b6\n\n\nA BioEntry reader can store up to 64 time schedules. Each time schedule consists of 7 daily schedules and an optional holiday schedule. And each daily schedule may have up to 5 time segments.\n\n\n#define UF_TIMECODE_PER_DAY       5\n\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nshort\n \nstartTime\n;\n \n// start time in minutes\n\n\n    \nunsigned\n \nshort\n \nendTime\n;\n \n// end time in minutes\n\n\n}\n \nUFTimeCodeElem\n;\n\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nUFTimeCodeElem\n \ncodeElement\n[\nUF_TIMECODE_PER_DAY\n];\n\n\n}\n \nUFTimeCode\n;\n\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nint\n \nscheduleID\n;\n\n\n    \nUFTimeCode\n \ntimeCode\n[\n7\n];\n \n// 0 - Sunday, 1 - Monday, ...\n\n\n    \nint\n \nholidayID\n;\n\n\n}\n \nUFTimeSchedule\n;\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_AddTimeSchedule\n(\n \nUFTimeSchedule\n*\n \nschedule\n \n)\n\n\n\n\nParameters\n\n\nschedule\n\nPointer to the time schedule to be added.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n  \n\n\nUFTimeSchedule\n \ntimeSchedule\n;\n\n\n\nmemset\n(\n \n&\ntimeSchedule\n,\n \n0\n,\n \nsizeof\n(\nUFTimeSchedule\n)\n \n);\n \n// clear the structure\n\n\n\ntimeSchedule\n.\nscheduleID\n \n=\n \n1\n;\n\n\ntimeSchedule\n.\nholidayID\n \n=\n \n1\n;\n\n\n\n// Monday- 09:00 ~ 18:00\n\n\ntimeSchedule\n.\ntimeCode\n[\n1\n].\ncodeElement\n[\n0\n].\nstartTime\n \n=\n \n9\n \n*\n \n60\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n1\n].\ncodeElement\n[\n0\n].\nendTime\n \n=\n \n18\n \n*\n \n60\n;\n\n\n\n// Tuesday- 08:00 ~ 12:00 and 14:30 ~ 20:00\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n0\n].\nstartTime\n \n=\n \n8\n \n*\n \n60\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n0\n].\nendTime\n \n=\n \n12\n \n*\n \n60\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n1\n].\nstartTime\n \n=\n \n14\n \n*\n \n60\n \n+\n \n30\n;\n\n\ntimeSchedule\n.\ntimeCode\n[\n2\n].\ncodeElement\n[\n1\n].\nendTime\n \n=\n \n20\n \n*\n \n60\n;\n\n\n\n// \u2026\n\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_AddTimeSchedule\n(\n \n&\ntimeSchedule\n \n);\n\n\n\n\n\n\n\n\nUF_GetTimeSchedule\n\u00b6\n\n\nReads the specified time schedule.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetTimeSchedule\n(\n \nint\n \nID\n,\n \nUFTimeSchedule\n*\n \nschedule\n \n)\n\n\n\n\nParameters\n\n\nID\n\nID of the time schedule.\n\n\nschedule\n\nPointer to the time schedule to be read.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteTimeSchedule\n\u00b6\n\n\nDeletes the specified time schedule.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteTimeSchedule\n(\n \nint\n \nID\n \n)\n\n\n\n\nParameters\n\n\nID\n\nID of the time schedule.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteAllTimeSchedule\n\u00b6\n\n\nDeletes all the time schedules stored in a BioEntry reader.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAllTimeSchedule\n()\n\n\n\n\nParameters\n\nNone\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_AddHoliday\n\u00b6\n\n\nEach time schedule may have an optional holiday schedule. A holiday schedule consists of a holiday list and a daily schedule for it.\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nint\n \nholidayID\n;\n\n\n    \nint\n \nnumOfHoliday\n;\n\n\n    \nunsigned\n \nshort\n \nholiday\n[\n32\n];\n \n// (month << 8) | day\n\n\n    \nUFTimeCode\n \ntimeCode\n;\n\n\n}\n \nUFHoliday\n;\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_AddHoliday\n(\n \nUFHoliday\n*\n \nholiday\n \n)\n\n\n\n\nParameters\n\n\nholiday\n\nPointer to the holiday schedule to be added.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\nExample\n  \n\n\nUFHoliday\n \nholiday\n;\n\n\n\nmemset\n(\n \n&\nholiday\n,\n \n0\n,\n \nsizeof\n(\nUFHoliday\n)\n \n);\n \n// clear the structure\n\n\n\nholiday\n.\nholidayID\n \n=\n \n1\n;\n\n\nholiday\n.\nnumOfHoliday\n \n=\n \n10\n;\n\n\n\n// Jan. 1 is holiday\n\n\nholiday\n.\nholiday\n[\n0\n]\n \n=\n \n(\n1\n \n<<\n \n8\n)\n \n|\n \n1\n;\n\n\n\n// Mar. 5 is holiday\n\n\nholiday\n.\nholiday\n[\n1\n]\n \n=\n \n(\n3\n \n<<\n \n8\n)\n \n|\n \n5\n;\n\n\n\n// \u2026\n\n\n\n// Access is granted during 09:00 ~ 10:00 on holideys\n\n\nholiday\n.\ntimeCode\n.\ncodeElement\n[\n0\n].\nstartTime\n \n=\n \n9\n \n*\n \n60\n;\n\n\nholiday\n.\ntimeCode\n.\ncodeElement\n[\n0\n].\nendTime\n \n=\n \n10\n \n*\n \n60\n;\n\n\nUF_RET_CODE\n \nresult\n \n=\n \nUF_AddHoliday\n(\n \n&\nholiday\n \n);\n\n\n\n\n\n\n\n\nUF_GetHoliday\n\u00b6\n\n\nReads the specified holiday schedule.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetHoliday\n(\n \nint\n \nID\n,\n \nUFHoliday\n*\n \nholiday\n \n)\n\n\n\n\nParameters\n\n\nID\n\nID of the holiday schedule.\n\n\nholiday\n\nPointer to the holiday schedule to be read.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteHoliday\n\u00b6\n\n\nDeletes the specified holiday schedule.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteHoliday\n(\n \nint\n \nID\n \n)\n\n\n\n\nParameters\n\n\nID\n\nID of the holiday schedule.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteAllHoliday\n\u00b6\n\n\nDeletes all the holiday schedules stored in a BioEntry reader.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAllHoliday\n()\n\n\n\n\nParameters\n\nNone  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_AddAccessGroup\n\u00b6\n\n\nEach access group may have up to 16 time schedules. The access of members is granted only when the time belongs to the time schedules of the group.\n\n\n#define UF_SCHEDULE_PER_GROUP    16\n\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nint\n \ngroupID\n;\n\n\n    \nint\n \nnumOfSchedule\n;\n\n\n    \nint\n \nscheduleID\n[\nUF_SCHEDULE_PER_GROUP\n];\n\n\n}\n \nUFAccessGroup\n;\n\n\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_AddAccessGroup\n(\n \nUFAccessGroup\n*\n \ngroup\n \n)\n\n\n\n\nParameters\n\n\ngroup\n\nPointer to the access group to be added.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetAccessGroup\n\u00b6\n\n\nReads the specified access group.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetAccessGroup\n(\n \nint\n \nID\n,\n \nUFAccessGroup\n*\n \ngroup\n \n)\n\n\n\n\nParameters\n\n\nID\n\nID of the access group.\n\n\ngroup\n\nPointer to the access group to be read.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteAccessGroup\n\u00b6\n\n\nDeletes the specified access group.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAccessGroup\n(\n \nint\n \nID\n \n)\n\n\n\n\nParameters\n\n\nID\n\nID of the access group.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteAllAccessGroup\n\u00b6\n\n\nDeletes all the access groups stored in a BioEntry reader.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAllAccessGroup\n()\n\n\n\n\nParameters\n\nNone  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_SetUserAccessGroup\n\u00b6\n\n\nAssigns access groups to a user. A user can be a member of up to 4 access groups.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_SetUserAccessGroup\n(\n \nUINT32\n \nuserID\n,\n \nint\n \nnumOfGroup\n,\n \nint\n*\n \ngroupID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nnumOfGroup\n\nNumber of access groups to be assigned.\n\n\ngroupID\n\nArray of access group IDs to be assigned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetUserAccessGroup\n\u00b6\n\n\nReads the IDs of access groups assigned to a user.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetUserAccessGroup\n(\n \nUINT32\n \nuserID\n,\n \nint\n*\n \nnumOfGroup\n,\n \nint\n*\n \ngroupID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nnumOfGroup\n\nPointer to the number of access groups to be returned.\n\n\ngroupID\n\nArray of access group IDs to be returned.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.22. Blacklist API\n\u00b6\n\n\nWhen a user ID is added to the blacklist, authentication will always fail regardless of fingerprint matching result. The blacklist takes precedence over the authentication type of a user. For example, though the authentication mode of a user is UF_AUTH_BYPASS, the authentication would fail if it is in the blacklist. The blacklist can store up to 1022 user IDs.\n\n\n\n\nUF_AddBlacklist\n: adds an ID to the blacklist.\n\n\nUF_DeleteBlacklist\n: deletes an ID from the blacklist.\n\n\nUF_GetBlacklist\n: reads the IDs in the blacklist.\n\n\nUF_DeleteAllBlacklist\n: clears the blacklist.\n\n\n\n\n\n\nUF_AddBlacklist\n\u00b6\n\n\nAdds a user ID to the blacklist.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_AddBlacklist\n(\n \nUINT32\n \nuserID\n,\n \nint\n*\n \nnumOfBlacklistedID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nnumOfBlacklistedID\n\nNumber of IDs in the blacklist after adding.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.  \n\n\n\n\n\n\nUF_DeleteBlacklist\n\u00b6\n\n\nDeletes an ID from the blacklist.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteBlacklist\n(\n \nUINT32\n \nuserID\n,\n \nint\n*\n \nnumOfBlacklistedID\n \n)\n\n\n\n\nParameters\n\n\nuserID\n\nUser ID.\n\n\nnumOfBlacklistedID\n\nNumber of IDs in the blacklist after deleting.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_GetBlacklist\n\u00b6\n\n\nReceive user IDs in the blacklist.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_GetBlacklist\n(\n \nint\n*\n \nnumOfBlacklistedID\n,\n \nUINT32\n*\n \nuserID\n \n)\n\n\n\n\nParameters\n\n\nnumOfBlacklistedID\n\nPointer to the number of IDs in the blacklist.\n\n\nuserID\n\nArray of user IDs in the blacklist. This should be pre-allocated large enough.  \n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_DeleteAllBlacklist\n\u00b6\n\n\nClears the blacklist.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_DeleteAllBlacklist\n()\n\n\n\n\nParameters\n\nNone\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\n3.23. WSQ API\n\u00b6\n\n\nThe Wavelet Scalar Quantization (WSQ) Gray-scale Fingerprint Image Compression Algorithm is the standard for the exchange of 8-bit, \n500ppi fingerprint images within the criminal justice community. SFM5500 / SFM6000 series provide the WSQ compression feature when the module scanning an image. \n\n\n\n\nWarning\n\n\nSFM5500/6000 series are supported only.\n\n\n\n\nSuprema\u2019s WSQ algorithm is certified by FBI.\n(\nhttps://www.fbibiospecs.cjis.gov/WSQ/Implementations\n)\n\n\n\n\nUF_ScanImageEx\n: scans a fingerprint on the sensor and retrieves the image data.\n\n\nUF_ReadImageEx\n: retrieves the last scanned fingerprint image.\n\n\nUF_WSQ_Decode\n: Decode the compressed WSQ fingerprint image which is read or scaned by the module.\n\n\n\n\nUF_ScanImageEx\n and \nUF_ReadImageEx\n are extended APIs of \nUF_ScanImage\n/\nUF_ReadImage\n. These APIs are provide WSQ compression feature.\n\n\nUF_IMAGE_TYPE\n is used as an input parameter in \nUF_ScanImageEx\n/\nUF_ReadImageEX\n funtions. \n\n\nUF_IMAGE_TYPE\n is defined as bellow.  \n\n\ntypedef\n \nenum\n \n{\n\n\nUF_GRAY_IMAGE\n \n=\n \n0x30\n,\n\n\nUF_BINARY_IMAGE\n \n=\n \n0x31\n,\n\n\nUF_4BIT_GRAY_IMAGE\n \n=\n \n0x32\n,\n\n\nUF_WSQ_IMAGE\n \n=\n \n0x33\n,\n\n\nUF_WSQ_HQ_IMAGE\n \n=\n \n0x33\n,\n\n\nUF_WSQ_MQ_IMAGE\n \n=\n \n0x34\n,\n\n\nUF_WSQ_LQ_IMAGE\n \n=\n \n0x35\n,\n\n\n}\n \nUF_IMAGE_TYPE\n;\n\n\n\n\n\n\nUF_ScanImageEx\n\u00b6\n\n\nScans a fingerprint on the sensor and retrieves the image data.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ScanImageEx\n(\n \nUFImage\n*\n \nimage\n,\n \nUF_IMAGE_TYPE\n \ntype\n,\n \nint\n \nwsqBitRate\n \n)\n\n\n\n\nParameters\n\n\nimage\n\nPointer to the UFImage structure.\n\n\ntype\n\nType of an image to read or scan.\n\n\nwsqBitRate\n\nWSQ is compressed by input of wsqBitRate in the module. The value of\nwsqBitRate is recommended as below.  \n\n\n\n\nwsqBitRate = 225\n, High quality compressing (compressing rate approx. 1:5)  \n\n\nwsqBitRate = 150\n, Midium quality compressing (compressing rate approx. 1:10)  \n\n\nwsqBitRate = 75\n, Low quality compressing (compressing rate approx. 1:15)  \n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_ReadImageEx\n\u00b6\n\n\nRetrieves the last scanned fingerprint image.  \n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_ReadImageEx\n(\n \nUFImage\n*\n \nimage\n,\n \nUF_IMAGE_TYPE\n \ntype\n,\n \nint\n \nwsqBitRate\n \n)\n\n\n\n\nParameters\n \n\n\nimage\n\nPointer to the UFImage structure.\n\n\ntype\n\nType of an image to read or scan.\n\n\nwsqBitRate\n\nWSQ is compressed by input of wsqBitRate in the module. The value of wsqBitRate is recommended as below.  \n\n\n\n\nwsqBitRate = 225\n, High quality compressing (compressing rate approx. 1:5)  \n\n\nwsqBitRate = 150\n, Midium quality compressing (compressing rate approx. 1:10)  \n\n\nwsqBitRate = 75\n, Low quality compressing (compressing rate approx. 1:15)  \n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nUF_WSQ_Decode\n\u00b6\n\n\nDecode the compressed WSQ fingerprint image which is read or scaned by the module.\n\n\n\n\nDescription\n\n\nUF_RET_CODE\n \nUF_WSQ_Decode\n(\nunsigned\n \nchar\n \n**\nodata\n,\n \nint\n \n*\now\n,\n \nint\n \n*\noh\n,\n \nint\n \n*\nod\n,\n \nint\n \n*\noppi\n,\nint\n \n*\nlossyflag\n,\n \nunsigned\n \nchar\n \n*\nidata\n,\n \nconst\n \nint\n \nilen\n)\n\n\n\n\nParameters\n\n\nodata\n\nPointer to the decoded image data.\n\n\now\n\nPointer to the width of decoded image data.\n\n\noh\n\nPointer to the height of decoded image data.\n\n\nod\n\nPointer to the bit depth of decoded image data. (Always returns 8)\n\n\nlossyflag\n\nPointer to the lossy flag. (Always returns 1)\n\n\nidata\n\nPointer to the read or scaned WSQ fingerprint image data by the module.\n\n\nilen\n\nPointer to the length of idata  \n\n\n\n\nWarning\n\n\nodata\n is dynamic allocated by the \nUF_WSQ_Decode\n function. You should free\nmemory of odata after use it.\n\n\n\n\nReturn Values\n\nIf the function succeeds, return \nUF_RET_SUCCESS\n. Otherwise, return the corresponding error code.\n\n\n\n\n\n\nContact Info\n\u00b6\n\n\n\n\nHeadquarters\n  \n\n\nSuprema, Inc. (\nhttp://www.supremainc.com\n)\n\n16F Parkview Office Tower,\n\nJoengja-dong, Bundang-gu,\n\nSeongnam, Gyeonggi, 463-863 Korea\n\nTel: +82-31-783-4505\n\nFax:+82-31-783-4506\n\nEmail: \nsales@supremainc.com\n, \nsupport@supremainc.com",
            "title": "API Specification"
        },
        {
            "location": "/documents/API_Specification/#3-api-specification",
            "text": "",
            "title": "3. API Specification"
        },
        {
            "location": "/documents/API_Specification/#31-return-codes",
            "text": "Most APIs in the SDK return UF_RET_CODE. The return codes and their meanings are as follows;     Category  Code  Description      Success  UF_RET_SUCCESS  The function succeeds.    Serial Comm.  UF_ERR_CANNOT_OPEN_SEREIAL  Cannot open the specified serial port.     UF_ERR_CANNOT_SETUP_SERIAL  Cannot set the baud rate.     UF_ERR_CANNOT_WRITE_SERIAL  Cannot write data to the serial port.     UF_ERR_WRITE_SERIAL_TIMEOUT  Write timeout.     UF_ERR_CANNOT_READ_SERIAL  Cannot read data from the serial port.     UF_ERR_READ_SERIAL_TIMEOUT  Read timeout.     UF_ERR_CHECKSUM_ERROR  Received packet has wrong checksum.     UF_ERR_CANNOT_SET_TIMEOUT  Cannot set communication timeout.    Socket  UF_ERR_CANNOT_START_SOCKET  Cannot initialize the socket interface.     UF_ERR_CANNOT_OPEN_SOCKET  Cannot open the socket.     UF_ERR_CANNOT_CONNECT_SOCKET  Cannot connect to the socket.     UF_ERR_CANNOT_READ_SOCKET  Cannot read data from the socket.     UF_ERR_READ_SOCKET_TIMEOUT  Read timeout.     UF_ERR_CANNOT_WRITE_SOCKET  Cannot write data to the socket.     UF_ERR_WRITE_SOCKET_TIMEOUT  Write timeout.    Protocol  UF_ERR_SCAN_FAIL  Sensor or fingerprint input has failed.     UF_ERR_NOT_FOUND  Identification failed, or the requested data is not found.     UF_ERR_NOT_MATCH  Fingerprint does not match.     UF_ERR_TRY_AGAIN  Fingerprint image is not good.     UF_ERR_TIME_OUT  Timeout for fingerprint input.     UF_ERR_MEM_FULL  No more templates are allowed.     UF_ERR_EXIST_ID  The specified user ID already exists.     UF_ERR_FINGER_LIMIT  The number of fingerprints enrolled in same ID exceeds its limit.     UF_ERR_UNSUPPORTED  The command is not supported.     UF_ERR_INVALID_ID  The requested user ID is invalid or missing.     UF_ERR_TIMEOUT_MATCH  Timeout for fingerprint identification.     UF_ERR_BUSY  Module is processing another command.     UF_ERR_CANCELED  The command is canceled.     UF_ERR_DATA_ERROR  The checksum of a data packet is incorrect.     UF_ERR_EXIST_FINGER  The finger is already enrolled.     UF_ERR_DURESS_FINGER  A duress finger is detected.     UF_ERR_CARD_ERROR  Cannot read a smart card.     UF_ERR_LOCKED  Module is locked.     UF_ERR_ACCESS_NOT_GRANTED  Access is not granted by time schedule and access group.     UF_ERR_REJECTED_ID  Authentication type of the user is UF_AUTH_REJECT or the ID is in the blacklist.     UF_ERR_FAKE_DETECTED  Scanned finger is determined as a fake finger.     UF_ERR_EXCEED_ENTRANCE_LIMIT  Entrance limit is exceeded.    Application  UF_ERR_OUT_OF_MEMORY  Out of memory.     UF_ERR_INVALID_PARAMETER  Invalid parameter.     UF_ERR_FILE_IO  File I/O failed     UF_ERR_INVALID_FILE  The configuration or DB file is invalid.",
            "title": "3.1. Return Codes"
        },
        {
            "location": "/documents/API_Specification/#32-serial-communication-api",
            "text": "To communicate with SFM modules, users should configure the serial port first.   UF_InitCommPort : configures serial port parameters.  UF_CloseCommPort : closes the serial port.  UF_Reconnect : resets system parameters and IO settings.  UF_SetBaudrate : changes the baud rate.  UF_SetAsciiMode : changes the packet translation mode.",
            "title": "3.2. Serial Communication API"
        },
        {
            "location": "/documents/API_Specification/#uf_initcommport",
            "text": "Opens a serial port and configures communication parameters. This function should be called first before calling any other APIs.   Description  UF_RET_CODE   UF_InitCommPort (   const   char *   commPort ,   int   baudrate ,   BOOL   asciiMode   )   Parameters  commPort \nPointer to a null-terminated string that specifies the name of the serial port.  baudrate \nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps (230400bps and 460800bps are available in later version of 5.0). The default setting of SFM modules is 115200bps.  asciiMode \nDetermines the packet translation mode. If it is set to TRUE, the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.    Example  UF_RET_CODE   result   =   UF_InitCommPort (   \u201c COM1 \u201d ,   115200 ,   FALSE   );",
            "title": "UF_InitCommPort"
        },
        {
            "location": "/documents/API_Specification/#uf_closecommport",
            "text": "Closes the serial port opened by  UF_InitCommPort .   Description  UF_RET_CODE   UF_CloseCommPort ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_CloseCommPort"
        },
        {
            "location": "/documents/API_Specification/#uf_reconnect",
            "text": "To improve communication efficiency, the SDK caches basic information of a module such as system parameters and I/O settings.  UF_Reconnect  clears this cached information. When changing the modules connected to the serial port, this function should be called.   Description  void   UF_Reconnect ()   Parameters   \nNone    Return Values \nNone",
            "title": "UF_Reconnect"
        },
        {
            "location": "/documents/API_Specification/#uf_setbaudrate",
            "text": "Changes the baud rate.     Description  UF_RET_CODE   UF_SetBaudrate (   int   baudrate   )   Parameters  baudrate \nSpecifies the baud rate at which the serial port operates. Available baud rates are 9600, 19200, 38400, 57600, 115200bps. The default setting of SFM modules is 115200bps.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetBaudrate"
        },
        {
            "location": "/documents/API_Specification/#uf_setasciimode",
            "text": "Changes the packet translation mode.   Description  void   UF_SetAsciiMode (   BOOL   asciiMode   )   Parameters  asciiMode \nTRUE for ascii format, FALSE for binary format.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetAsciiMode"
        },
        {
            "location": "/documents/API_Specification/#33-socket-api",
            "text": "In addition to serial ports, users can connect to the module by Ethernet-to-Serial converters. In this case, socket API should be used in place of serial API.   UF_InitSocket : opens a socket and connects to the specified IP address.  UF_CloseSocket : closes the socket.",
            "title": "3.3. Socket API"
        },
        {
            "location": "/documents/API_Specification/#uf_initsocket",
            "text": "Initializes the socket interface and connects to the module with specified IP address.   Description  UF_RET_CODE   UF_InitSocket (   const   char *   inetAddr ,   int   port ,   BOOL   asciiMode   )     Parameters  inetAddr \nIP address of the Ethernet-to-Serial converter.  port \nTCP port of the socket interface.  asciiMode \nDetermines the packet translation mode. If it is set to  TRUE , the binary packet is converted to ASCII format first before being sent to the module. Response packets are in ASCII format, too. The default setting of SFM modules is binary mode.  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example  UF_RET_CODE   result   =   UF_InitSocket (   \u201c 192.168.1.41 \u201d ,   1470 ,   FALSE   );",
            "title": "UF_InitSocket"
        },
        {
            "location": "/documents/API_Specification/#uf_closesocket",
            "text": "Closes the socket interface.   Description  UF_RET_CODE   UF_CloseSocket ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_CloseSocket"
        },
        {
            "location": "/documents/API_Specification/#34-low-level-packet-api",
            "text": "These functions provide direct interface to the low-level packet exchanges. In most cases, users need not to call these functions directly. Command API and other high level APIs are implemented on top of this API.\nPacket API also let users set callback functions for data transfer. Examples of using these callback functions for GUI application can be found in UniFingerUI V4.0 source codes.   UF_SendPacket : sends a 13 byte packet.  UF_SendNetworkPacket : sends a 15 byte network packet.  UF_ReceivePacket : receives a 13 byte packet.  UF_ReceiveNetworkPacket : receives a 15 byte network packet.  UF_SendRawData : sends raw data.  UF_ReceiveRawData : receives raw data.  UF_SendDataPacket : sends data using Extended Data Transfer Protocol.  UF_ReceiveDataPacket : receives data using Extended Data Transfer Protocol.  UF_SetSendPacketCallback : sets the callback function of sending packets.  UF_SetReceivePacketCallback : sets the callback function of receiving packets.  UF_SetSendDataPacketCallback : sets the callback function of sending data packets.  UF_SetReceiveDataPacketCallback : sets the callback function of receiving data packets.  UF_SetSendRawDataCallback : sets the callback function of sending raw data.  UF_SetReceiveRawDataCallback : sets the callback function of receiving raw data.  UF_SetDefaultPacketSize : sets the size of data packets.  UF_GetDefaultPacketSize : gets the size of data packets.",
            "title": "3.4. Low-Level Packet API"
        },
        {
            "location": "/documents/API_Specification/#uf_sendpacket",
            "text": "Sends a 13 byte packet to the module. The packet is composed as follows;     Start code  Command  Param  Size  Flag/Error  Checksum  End code      1byte  1byte  4bytes  4bytes  1byte  1byte  1byte      Start code : 1 byte. Indicates the beginning of a packet. It always should be 0x40.  Command : 1 byte. Refer to the Packet Protocol Manual for available commands.  Param : 4 bytes. The meaning of this field varies according to each command.  Size : 4 bytes. The meaning of this field varies according to each command.  Flag/Error : 1 byte. Indicates flag data in the request packet, and error code in the response packet.  Checksum : 1 byte. Checks the validity of a packet. Checksum is a remainder of the sum of each field, from the Start code to Flag/Error, divided by 256 (0x100).  End code : 1 byte. Indicates the end of a packet. It always should be 0x0A. It is also used as a code indicating the end of binary data such as fingerprint templates.      Description  UF_RET_CODE   UF_SendPacket (   BYTE   command ,   UINT32   param ,   UINT32   size ,   BYTE   flag ,   int   timeout   )   Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.  param \nParam field of a packet.  size \nSize field of a packet.  flag \nFlag field of a packet.  timeout \nSets the timeout in milliseconds. If sending does not complete within this limit,  UF_ERR_WRITE_SERIAL_TIMEOUT  will be returned.  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example  // To send ES command with user ID 10 and ADD_NEW(0x79) option,  UF_RET_CODE   result   =   UF_SendPacket (   UF_COM_ES ,   10 ,   0 ,   0x79 ,   2000   );  If (   result   !=   UF_RET_SUCCESS   )  {       Return   result ;  }",
            "title": "UF_SendPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_sendnetworkpacket",
            "text": "Sends a 15 byte network packet to the specified module. In order to support RS422 or RS485 network interfaces, SFM modules support Network Packet Protocol. Network packet is composed of 15 bytes, whose start code is different from the standard packet, and includes 2 bytes for terminal ID. The terminal ID is equal to the lower 2 bytes of Module ID of system parameter.     Field  Start code  Terminal ID  Command  Param  Size  Flag / Error  Checksum  End code      Bytes  1  2  1  4  4  1  1  1    Value  0x41  1 ~ 0xFFFF    Same as standard protocol   Checksum of 13 bytes  0x0A      Description  UF_SendNetworkPacket (   BYTE   command ,   USHORT   terminalID ,   UINT32   param ,   UINT32   size ,   BYTE   flag ,   int   timeout   )   Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.  terminalID \nSpecifies the terminal ID of the receiving module.  param \nParam field of a packet.  size \nSize field of a packet.  flag \nFlag field of a packet.  timeout \nSets the timeout in milliseconds. If sending does not complete within this limit,  UF_ERR_WRITE_SERIAL_TIMEOUT  will be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SendNetworkPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_receivepacket",
            "text": "Receives a 13 byte packet from the module. Most commands of Packet Protocol can be implemented by a pair of  UF_SendPacket / UF_ReceivePacket  or  UF_SendNetworkPacket / UF_ReceiveNetworkPacket .   Description  UF_RET_CODE   UF_ReceivePacket (   BYTE *   packet ,   int   timeout   )   Parameters  packet \nPointer to the 13 byte packet.  timeout \nSets the timeout in milliseconds. If receiving does not complete within this limit,  UF_ERR_READ_SERIAL_TIMEOUT  will be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReceivePacket"
        },
        {
            "location": "/documents/API_Specification/#uf_receivenetworkpacket",
            "text": "Receives a 15 byte network packet from the specified module.   Description  UF_ReceiveNetworkPacket (   BYTE *   packet ,   int   timeout   )   Parameters  packet \nPointer to the 15 byte packet.  timeout \nSets the timeout in milliseconds. If receiving does not complete within this limit, UF_ERR_READ_SERIAL_TIMEOUT will be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReceiveNetworkPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_sendrawdata",
            "text": "Some commands such as  ET (Enroll Template) and  IT (Identify Template) send additional data after the 13/15 byte request packet.  UF_SendRawData  is used in these cases for sending the data.   Description  UF_RET_CODE   UF_SendRawData (   BYTE *   buf ,   UINT32   size ,   int   timeout   )   Parameters  buf \nPointer to a data buffer.  size \nNumber of bytes to be sent.  timeout \nSets the timeout in milliseconds. If sending does not complete within this limit,  UF_ERR_WRITE_SERIAL_TIMEOUT  will be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SendRawData"
        },
        {
            "location": "/documents/API_Specification/#uf_receiverawdata",
            "text": "Some commands such as  ST (Scan Template) and  RT (Read Template) return additional data after the 13/15 byte response packet.  UF_ReceiveRawData  is used in these cases for receiving the data.   Description  UF_RET_CODE   UF_ReceiveRawData (   BYTE *   buf ,   UINT32   size ,   int   timeout ,   BOOL   checkEndCode   )   Parameters  buf \nPointer to a data buffer.  size \nNumber of bytes to be received.  timeout \nSets the timeout in milliseconds. If receiving does not complete within this limit,  UF_ERR_READ_SERIAL_TIMEOUT  will be returned.  checkEndCode \nData transfer ends with \u20180x0a\u2019. If this parameter is FALSE, the function returns without checking the end code.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReceiveRawData"
        },
        {
            "location": "/documents/API_Specification/#uf_senddatapacket",
            "text": "Sends data using Extended Data Transfer Protocol. Dividing large data into small blocks can reduce communication errors between the host and the module. Extended Data Transfer Protocol is an extension of Packet Protocol to provide a reliable and customizable communication for large data. In Extended Data Transfer Protocol, data is divided into multiple data packets. And a data packet consists of fixed-length header, variable-length data body, and 4 byte checksum. Commands which use the Extended Data Transfer Protocols are  EIX ,  VIX ,  IIX ,  RIX ,  SIX , and  UG .   Description  UF_SendDataPacket (   BYTE   command ,   BYTE *   buf ,   UINT32   dataSize ,   UINT32   dataPacketSize   )   Parameters  command \nCommand field of a packet. Valid commands are  EIX ,  VIX ,  IIX ,  RIX ,  SIX , and  UG .  buf \nPointer to a data buffer.  dataSize \nNumber of bytes to be sent.  dataPacketSize \nSize of data packet. For example, if dataSize is 16384 bytes and dataPacketSize is 4096 bytes, the data will be divided into 4 data packets.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SendDataPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_receivedatapacket",
            "text": "Receives data using Extended Data Transfer Protocol. The size of data packet should be specified before calling this function.   Description  UF_ReceiveDataPacket (   BYTE   command ,   BYTE *   buf ,   UINT32   dataSize   )   Parameters  command \nCommand field of a packet. Valid commands are  EIX ,  VIX ,  IIX ,  RIX ,  SIX , and  UG .  buf \nPointer to a data buffer.  dataSize \nNumber of bytes to be received.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReceiveDataPacket"
        },
        {
            "location": "/documents/API_Specification/#uf_setsendpacketcallback",
            "text": "If  SendPacketCallback  is specified, it is called after sending a packet successfully. The argument of the callback is the pointer to the packet.   Description  void   UF_SetSendPacketCallback (   void   ( * callback )(   BYTE *   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone    Example \nSee CMainFrame::SendPacketCallback in UniFingerUI source codes.",
            "title": "UF_SetSendPacketCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_setreceivepacketcallback",
            "text": "If  ReceivePacketCallback  is specified, it is called after receiving a packet successfully. The argument of the callback is the pointer to the received packet.   Description  void   UF_SetReceivePacketCallback (   void   ( * callback )(   BYTE *   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone  Example \nSee CMainFrame::ReceivePacketCallback in UniFingerUI source codes.",
            "title": "UF_SetReceivePacketCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_setsenddatapacketcallback",
            "text": "If  SendDataPacketCallback  is specified, it is called after sending a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.   Description  UF_SetSendDataPacketCallback (   void   ( * callback )(   int   index ,   int   numOfPacket   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone    Example \nSee CMainFrame::DataPacketCallback in UniFingerUI source codes.",
            "title": "UF_SetSendDataPacketCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_setreceivedatapacketcallback",
            "text": "If  ReceiveDataPacketCallback  is specified, it is called after receiving a data packet successfully. The argument of the callback is the index of the data packet and the number of total data packets.   Description  void   UF_SetReceiveDataPacketCallback (   void   ( * callback )(   int   index ,   int   numOfPacket   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone  Example \nSee CMainFrame::DataPacketCallback in UniFingerUI source codes.",
            "title": "UF_SetReceiveDataPacketCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_setsendrawdatacallback",
            "text": "If  SendRawDataCallback  is specified, it is called during sending raw data. The argument of the callback is the written length and the total length of data.   Description  void   UF_SetSendRawDataCallback (   void   ( * callback )(   int   writtenLen ,   int   totalSize   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone  Example \nSee CMainFrame::RawDataCallback in UniFingerUI source codes.",
            "title": "UF_SetSendRawDataCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_setreceiverawdatacallback",
            "text": "If  ReceiveRawDataCallback  is specified, it is called during receiving data. The argument of the callback is the read length and the total length of data.   Description  void   UF_SetReceiveRawDataCallback (   void   ( * callback )(   int   readLen ,   int   totalSize   )   )   Parameters  callback \nPointer to the callback function.  Return Values \nNone  Example \nSee CMainFrame::RawDataCallback in UniFingerUI source codes.",
            "title": "UF_SetReceiveRawDataCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_setdefaultpacketsize",
            "text": "Sets the size of data packets used in Extended Data Transfer protocol. The default value is 4096. When BEACon is used as an Ethernet-to-Serial converter, this value should not be larger than 256.   Description  void   UF_SetDefaultPacketSize (   int   defaultSize   )   Parameters  defaultSize \nSize of data packet.  Return Values \nNone",
            "title": "UF_SetDefaultPacketSize"
        },
        {
            "location": "/documents/API_Specification/#uf_getdefaultpacketsize",
            "text": "Returns the size of data packet used in Extended Data Transfer protocol.   Description  int   UF_GetDefaultPacketSize ()   Parameters \nNone  Return Values \nThe size of data packet.",
            "title": "UF_GetDefaultPacketSize"
        },
        {
            "location": "/documents/API_Specification/#35-generic-command-api",
            "text": "The commands defined in the Packet Protocol Manual can be classified into several categories according to the types of packet exchange. Generic Command API provides functions which encapsulate these categories. Like low-level Packet API, users need not to call these functions directly. Most commands have corresponding high-level API in the SDK.   UF_Command : encapsulates the commands composed of one request packet and one response packet.  UF_CommandEx : encapsulates the commands composed of one request packet and multiple response packets.  UF_CommandSendData : encapsulates the commands which send additional data after a request packet.  UF_CommandSendDataEx : encapsulates the commands which send additional data and have multiple response packets.  UF_Cancel : cancels the previously issued command.  UF_SetProtocol : sets the type of packet protocol.  UF_GetProtocol : gets the type of packet protocol.  UF_GetModuleID : gets the module ID.  UF_SetGenericCommandTimeout : sets the timeout for generic commands.  UF_SetInputCommandTimeout : sets the timeout for commands which require user inputs.  UF_GetGenericCommandTimeout : gets the timeout for generic commands.  'UF_GetInputCommandTimeout`: gets the timeout for commands which require user inputs.  UF_SetNetworkDelay : sets the delay for the Network Packet Protocol.  UF_GetNetworKDelay : gets the delay for the Network Packet Protocol.",
            "title": "3.5. Generic Command API"
        },
        {
            "location": "/documents/API_Specification/#uf_command",
            "text": "Encapsulates the commands composed of one request packet and one response packet. The majority of commands can be implemented using  UF_Command .   Description  UF_RET_CODE   UF_Command (   BYTE   command ,   UINT32 *   param ,   UINT32 *   size ,   BYTE *   flag   )   Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.  param \nParam field of a packet. This parameter is used both for input and output.  size \nSize field of a packet. This parameter is used both for input and output.  flag \nFlag field of a packet. This parameter is used both for input and output.    Return Values \nIf packets are transferred successfully, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  UF_RET_SUCCESS  only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.  Example  // To read Timeout(0x62) system parameter,  UINT32   param   =   0 ;  UINT32   size   =   0 ;  BYTE   flag   =   0x62 ;  UINT32   timeout ;  UF_RET_CODE   result   =   UF_Command (   UF_COM_SR ,   & param ,   & size ,   & flag   );  If (   result   !=   UF_RET_SUCCESS   )   // communication error  {       return   result ;  }  If (   flag   !=   UF_PROTO_RET_SUCCESS   )   // protocol error  {       return   UF_GetErrorCode (   result   );  }  // succeed  timeout   =   size ;",
            "title": "UF_Command"
        },
        {
            "location": "/documents/API_Specification/#uf_commandex",
            "text": "Encapsulates the commands composed of one request packet and multiple response packets. Command such as  ES (Enroll) and  IS (Identify) can have more than one response packet. To handle these cases,  UF_CommandEx  requires a message callback function, which should return TRUE when the received packet is the last one.   Description  UF_RET_CODE   UF_CommandEx (   BYTE   command ,   UINT32 *   param ,   UINT32 *   size ,   BYTE *   flag ,   BOOL   ( * msgCallback )( BYTE )   )   Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.  param \nParam field of a packet. This parameter is used both for input and output.  size \nSize field of a packet. This parameter is used both for input and output.  flag \nFlag field of a packet. This parameter is used both for input and output.  msgCallback \nPointer to the callback function. This callback is called when a response packet is received. If the callback return  TRUE ,  UF_CommandEx  will return immediately. If the callback return  FALSE ,  UF_CommandEx  will wait for another response packet.  Return Values \nIf packets are transferred successfully, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.  Example     // UF_Identify() is implemented as follows;  /**  * Message callback for identification  */  BOOL   UF_IdentifyMsgCallback (   BYTE   errCode   )  {       if (   errCode   ==   UF_PROTO_RET_SCAN_SUCCESS   )       {           if (   s_IdentifyCallback   )           {               ( * s_IdentifyCallback )(   errCode   );           }           return   FALSE ;       }       else       {           return   TRUE ;       }  }  /**  * Identify  */  UF_RET_CODE   UF_Identify (   UINT32 *   userID ,   BYTE *   subID   )  {       UINT32   param   =   0 ;       UINT32   size   =   0 ;       BYTE   flag   =   0 ;       int   result   =   UF_CommandEx (   UF_COM_IS ,   & param ,   & size ,   & flag ,       UF_IdentifyMsgCallback   );       if (   result   !=   UF_RET_SUCCESS   )       {           return   result ;       }       else   if (   flag   !=   UF_PROTO_RET_SUCCESS   )       {           return   UF_GetErrorCode (   flag   );       }       * userID   =   param ;       * subID   =   size ;       return   UF_RET_SUCCESS ;  }",
            "title": "UF_CommandEx"
        },
        {
            "location": "/documents/API_Specification/#uf_commandsenddata",
            "text": "Encapsulates the commands which send additional data after a request packet. For example,  GW (Write GPIO Configuration) command should send configuration data after the request packet.   Description  UF_RET_CODE   UF_CommandSendData (   BYTE   command ,   UINT32 *   param ,   UINT32 *   size ,   BYTE *   flag ,   BYTE *   data ,   UINT32   dataSize   )   Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.  param \nParam field of a packet. This parameter is used both for input and output.  size \nSize field of a packet. This parameter is used both for input and output.  flag \nFlag field of a packet. This parameter is used both for input and output.  data \nPointer to the data buffer to be sent.  dataSize \nNumber of bytes to be sent.    Return Values \nIf packets are transferred successfully, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  UF_RET_SUCCESS  only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.",
            "title": "UF_CommandSendData"
        },
        {
            "location": "/documents/API_Specification/#uf_commandsenddataex",
            "text": "Encapsulates the commands which send additional data and have multiple response packets. For example,  ET (Enroll Template) command sends template data after request packet and can have multiple response packets.   Description  UF_RET_CODE   UF_CommandSendDataEx (   BYTE   command ,   UINT32 *   param ,   UINT32 *   size ,   BYTE *   flag ,   BYTE *   data ,   UINT32   dataSize ,   BOOL   ( * msgCallback )( BYTE ),   BOOL   waitUserInput   )   Parameters  command \nCommand field of a packet. Refer to the Packet Protocol Manual for available commands.  param \nParam field of a packet. This parameter is used both for input and output.  size \nSize field of a packet. This parameter is used both for input and output.  flag \nFlag field of a packet. This parameter is used both for input and output.  data \nPointer to the data buffer to be sent.  dataSize \nNumber of bytes to be sent.  msgCallback \nPointer to the callback function. This callback is called when a response packet is received. If the callback return  TRUE ,  UF_CommandSendDataEx  will return immediately. If the callback return  FALSE ,  UF_CommandSendDataEx  will wait for another response packet.  waitUserInput  TRUE  if the command needs user input. Otherwise,  FALSE .    Return Values \nIf packets are transferred successfully, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code. UF_RET_SUCCESS only means that request packet is received successfully. To know if the operation succeeds, the flag field should be checked.",
            "title": "UF_CommandSendDataEx"
        },
        {
            "location": "/documents/API_Specification/#uf_cancel",
            "text": "Cancels the command which is being processed by the module. When the module is executing a command which needs user input to proceed, the status of the module will be changed to  UF_SYS_BUSY . If users want to execute another command before finishing the current one, they can explicitly cancel it by this function.   Description  UF_RET_CODE   UF_Cancel (   BOOL   receivePacket   )   Parameters  receivePacket \nIf TRUE,  UF_Cancel  waits until the response packet is received. If  FALSE ,  UF_Cancel  returns immediately after sending the request packet.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_Cancel"
        },
        {
            "location": "/documents/API_Specification/#uf_setprotocol",
            "text": "Selects packet protocol. If the host connects to the single module through RS232 interface, use UF_SINGLE_PROTOCOL. If there are multiple modules in RS422/485 networks, use UF_NETWORK_PROTOCOL. The protocol should also be compatible with the Network Mode system parameter.     Network Mode   Supported Protocol       13 byte Packet Protocol  15 byte Network Packet Protocol    Single(0x30)  O  O    Network (0x31/0x32)  X  O      Description  void   UF_SetProtocol (   UF_PROTOCOL   protocol ,   UINT32   moduleID   )   Parameters  protocol  UF_SINGLE_PROTOCOL  for 13 byte packet protocol,  UF_NETWORK_PROTOCOL  for 15 byte network packet protocol.  moduleID \nSpecifies the ID of the module. This parameter is applicable when the protocol is set to  UF_NETWORK_PROTOCOL .  Return Values \nNone",
            "title": "UF_SetProtocol"
        },
        {
            "location": "/documents/API_Specification/#uf_getprotocol",
            "text": "Gets the selected protocol.   Description  UF_PROTOCOL   UF_GetProtocol ()   Parameters \nNone  Return Values  UF_SINGLE_PROTOCOL  or  UF_NETWORK_PROTOCOL .",
            "title": "UF_GetProtocol"
        },
        {
            "location": "/documents/API_Specification/#uf_getmoduleid",
            "text": "Gets the ID of the module.   Description  UINT32   UF_GetModuleID ()   Parameters \nNone  Return Values \nID of the module.",
            "title": "UF_GetModuleID"
        },
        {
            "location": "/documents/API_Specification/#uf_setgenericcommandtimeout",
            "text": "Sets the timeout for generic commands. The default timeout is 2,000ms.   Description  void   UF_SetGenericCommandTimeout (   int   timeout   )   Parameters  timeout \nSpecifies the timeout period in milliseconds.    Return Values \nNone",
            "title": "UF_SetGenericCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_setinputcommandtimeout",
            "text": "Sets the timeout for commands which need user input. The default timeout is 10,000ms.   Description  void   UF_SetInputCommandTimeout (   int   timeout   )   Parameters  timeout \nSpecifies the timeout period in milliseconds.  Return Values \nNone",
            "title": "UF_SetInputCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_getgenericcommandtimeout",
            "text": "Gets the timeout for generic commands.   Description  int   UF_GetGenericCommandTimeout ()   Parameters \nNone  Return Values \nTimeout for generic commands.",
            "title": "UF_GetGenericCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_getinputcommandtimeout",
            "text": "Gets the timeout for commands which need user input.   Description  int   UF_GetInputCommandTimeout ()   Parameters \nNone  Return Values \nTimeout for commands which need user input.",
            "title": "UF_GetInputCommandTimeout"
        },
        {
            "location": "/documents/API_Specification/#uf_setnetworkdelay",
            "text": "In half duplex mode, the same communication lines are shared for sending and receiving data. To prevent packet collisions on the shared line, there should be some delay between receiving and sending data. The default delay is set to 40ms. This value can be optimized for specific environments.   Description  void   UF_SetNetworkDelay (   int   delay   )   Parameters  delay \nSpecified the delay in milliseconds.  Return Values \nNone",
            "title": "UF_SetNetworkDelay"
        },
        {
            "location": "/documents/API_Specification/#uf_getnetworkdelay",
            "text": "Gets the network delay.   Description  int   UF_GetNetworkDelay ()   Parameters \nNone  Return Values \nDelay in milliseconds.",
            "title": "UF_GetNetworkDelay"
        },
        {
            "location": "/documents/API_Specification/#36-module-api",
            "text": "These functions provide basic information about the module.   UF_GetModuleInfo : gets the basic module information.  UF_GetModuleString : gets a string describing the module.  UF_SearchModule : searches a module and find out communication parameters.  UF_SearchModuleID : searches an ID of a module.  UF_SearchModuleBySocket : searches a module through socket interface.  UF_SearchModuleIDEx : searches multiple models in a network.  UF_CalibrateSensor : calibrates a sensor.  UF_Upgrade : upgrades firmware.  UF_Reset : resets the module.  UF_Lock : locks the module.  UF_Unlock : unlocks the module.  UF_ChangePassword : changes the master password of a module.  UF_PowerOff  : Programmatically turns off a module (SFM4000 only).",
            "title": "3.6. Module API"
        },
        {
            "location": "/documents/API_Specification/#uf_getmoduleinfo",
            "text": "Retrieves the type, version and sensor information of the module.   Description  UF_RET_CODE   UF_GetModuleInfo (   UF_MODULE_TYPE *   type ,   UF_MODULE_VERSION *   version ,   UF_MODULE_SENSOR *   sensorType   )   Parameters  type \nAvailable types are as follows;     Value  Description      UF_MODULE_3000  SFM 3000 series modules    UF_MODULE_3500  SFM 3500 series modules    UF_MODULE_4000  SFM 4000 series modules    UF_MODULE_5000  SFM_5000 series modules    UF_BIOENTRY_SMART  BioEntry Smart    UF_BIOENTRY_PASS  BioEntry Pass     version \nVersion number of the module.  sensorType \nSensor type of the module.     Value  Sensor Type      UF_SENSOR_FL  Authentec AF-S2    UF_SENSOR_FC  Atmel FingerChip    UF_SENSOR_OP  Optical Sensor I (OP2/OP3/OP4)    UF_SENSOR_TC  UPEK TouchChip (TC1/TC2/TC2S)    UF_SENSOR_OC2  Optical Sensor II (OC2/OD)    UF_SENSOR_TS  UPEK TouchStrip (TS4)    UF_SENSOR_OL  Optical Sensor III (OL)    UF_SENSOR_OH  Optical Sensor IV (OH)     Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetModuleInfo"
        },
        {
            "location": "/documents/API_Specification/#uf_getmodulestring",
            "text": "Retrieves a string that describes the module information. This function should be called after  UF_GetModuleInfo .   Description  char *   UF_GetModuleString (   UF_MODULE_TYPE   type ,   UF_MODULE_VERSION   version ,   UF_MODULE_SENSOR   sensorType   )   Parameters  type \nSpecifies the type of the module.  version \nSpecifies the version number of the module.  sensorType \nSpecifies the sensor type of the module.    Return Values \nNull-terminated string that describes the module information. This pointer is a static data in the SDK. So, it should not be shared or freed by applications.",
            "title": "UF_GetModuleString"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmodule",
            "text": "Search a module connected to the specified serial port.  UF_SearchModule  tries all combinations of communication parameters. If it finds any module on the serial port, it returns the communication parameters and its module ID.   Description  UF_RET_CODE   UF_SearchModule (   const   char *   port ,   int *   baudrate ,   BOOL *   asciiMode ,   UF_PROTOCOL *   protocol ,   UINT32 *   moduleID ,   void   ( * callback )(   const   char *   comPort ,   int   baudrate   )   )   Parameters  port \nSerial port.  baudrate \nPointer to the baud rate to be returned.  asciiMode   \nPointer to the packet translation mode to be returned.  protocol \nPointer to the protocol type to be returned.  moduleID \nPointer to the module ID to be returned.  callback \nPointer to the callback function. The callback function can be used for displaying the progress of the search. This parameter can be NULL.    Return Values \nIf it finds a module, return  UF_RET_SUCCESS . If the search fails, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_SearchModule"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmoduleid",
            "text": "Until firmware V1.3, SFM modules respond both standard and network packets regardless of Network Mode system parameter. However, since firmware V1.4, the modules only respond to 15 byte network packets if Network Mode system parameter is not Single(0x30). So, if users don\u2019t know ID of the module, they cannot communicate with it in network environments.  UF_SerachModuleID  can be used to retrieve the ID of the module in these cases. Refer to ID command section in the Packet Protocol Manual for details.   Description  UF_RET_CODE   UF_SearchModuleID (   UINT32 *   moduleID   )   Parameters  moduleID \nPointer to the module ID to be returned.  Return Values \nIf it finds a module, return  UF_RET_SUCCESS . If the search fails, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_SearchModuleID"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmodulebysocket",
            "text": "Search a module connected to the specified IP address. If it finds any module, it will return the communication parameters and the module ID.   Description  UF_RET_CODE   UF_SearchModuleBySocket (   const   char *   inetAddr ,   int   tcpPort ,   BOOL *   asciiMode ,   UF_PROTOCOL *   protocol ,   UINT32 *   moduleID   )   Parameters  inetAddr \nIP address.  tcpPort \nTCP port.  asciiMode \nPointer to the packet translation mode to be returned.  protocol \nPointer to the protocol type to be returned.  moduleID \nPointer to the module ID to be returned.    Return Values \nIf it finds a module, return  UF_RET_SUCCESS . If the search fails, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_SearchModuleBySocket"
        },
        {
            "location": "/documents/API_Specification/#uf_searchmoduleidex",
            "text": "UF_SearchModuleID  is used for searching a module. To search multiple modules in a RS422/485 network,  UF_SearchModuleIDEx  should be used instead. By calling this function repetitively, users can search all the modules connected to a network.   Description  UF_RET_CODE   UF_SearchModuleIDEx (   unsigned   short *   foundModuleID ,   int   numOfFoundID ,   unsigned   short *   moduleID ,   int *   numOfID   )   Parameters  foundModuleID \nPointer to the array of module IDs, which are already found. When the ID of a module is in this array, the module will ignore the search command.  numOfFoundID \nNumber of module IDs, which are already found.  moduleID \nPointer to the array of module IDs, which will be filled with newly found IDs.  numOfID \nPointer to the number of module IDs to be returned.    Return Values \nIf it finds one or more modules, return  UF_RET_SUCCESS . If the search fails, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.  Example  int   numOfModuleID ;  unsigned   short   moduleID [ 32 ];  int   numOfFoundID   =   0 ;  BOOL   foundNewID   =   FALSE ;  do   {       result   =   UF_SearchModuleIDEx (   moduleID ,   numOfFoundID ,   moduleID   +  numOfFoundID ,   & numOfModuleID   );       if (   result   ==   UF_RET_SUCCESS   )       {           foundNewID   =   TRUE ;           numOfFoundID   +=   numOfModuleID ;       }       else       {           foundNewID   =   FALSE ;       }  }   while (   foundNewID   &&   numOfFoundID   <   32   );",
            "title": "UF_SearchModuleIDEx"
        },
        {
            "location": "/documents/API_Specification/#uf_calibratesensor",
            "text": "Calibrates fingerprint sensor. This function is supported for AuthenTec\u2019s FingerLoc AF-S2 and UPEK\u2019s TouchChip. After using the  UF_CalibrateSensor ,  UF_Save  should be called to save calibration data into flash memory.   Description  UF_RET_CODE   UF_CalibrateSensor ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_CalibrateSensor"
        },
        {
            "location": "/documents/API_Specification/#uf_upgrade",
            "text": "Upgrades the firmware of the module. Users should not turn off the module when upgrade is in progress.   Description  UF_RET_CODE   UF_Upgrade (   const   char *   firmwareFilename ,   int   dataPacketSize )   Parameters  firmwareFilename \nNull-terminated string that specifies the firmware file name.  dataPacketSize \nThe packet size of firmware data. If it is 16384, the firmware is divided into 16384 byte packets before transferring to the module.    Return Values \nIf upgrade succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_Upgrade"
        },
        {
            "location": "/documents/API_Specification/#uf_reset",
            "text": "Resets the module.   Description  UF_RET_CODE   UF_Reset ()   Parameters \nNone  Return Values  UF_RET_SUCCESS",
            "title": "UF_Reset"
        },
        {
            "location": "/documents/API_Specification/#uf_lock",
            "text": "Locks the module. When the module is locked, it returns  UF_ERR_LOCKED  to functions other than  UF_Unlock .   Description  UF_RET_CODE   UF_Lock ()   Parameters \nNone  Return Values \nIf the module is locked successfully, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_Lock"
        },
        {
            "location": "/documents/API_Specification/#uf_unlock",
            "text": "Unlocks a locked module.   Description  UF_RET_CODE   UF_Unlock (   const   unsigned   char *   password   )   Parameters  password \n16 byte master password. The default password is a string of 16 NULL characters.  Return Values \nIf the password is wrong, return UF_ERR_NOT_MATCH. If it is successful, return UF_RET_SUCCESS.",
            "title": "UF_Unlock"
        },
        {
            "location": "/documents/API_Specification/#uf_changepassword",
            "text": "Changes the master password.   Description  UF_RET_CODE   UF_ChangePassword (   const   unsigned   char *   newPassword ,   const   unsigned   char *   oldPassword   )   Parameters  newPassword \n16 byte new password.  oldPassword \n16 byte old password.    Return Values \nIf the old password is wrong, return  UF_ERR_NOT_MATCH . If it is successful, return  UF_RET_SUCCESS .",
            "title": "UF_ChangePassword"
        },
        {
            "location": "/documents/API_Specification/#uf_poweroff",
            "text": "Programmatically turns off a module. This function is only available with SFM4000 series.   Description  UF_RET_CODE   UF_PowerOff ()   Parameters \nNone  Return Values \nThe module is powered off successfully, return  UF_RET_SUCCESS .",
            "title": "UF_PowerOff"
        },
        {
            "location": "/documents/API_Specification/#37-system-parameters-api",
            "text": "Functions for managing system parameters. Available system parameters are defined in UF_SysParameter.h. See the Packet Protocol Manual for available values for each parameter.\nThis API also provides functions for saving and loading system configurations.   UF_InitSysParameter : clears the system parameter cache.  UF_GetSysParameter : gets the value of a system parameter.  UF_SetSysParameter : sets the value of a system parameter.  UF_GetMultiSysParameter : gets the values of multiple system parameters.  UF_SetMultiSysParameter : sets the values of multiple system parameters.  UF_Save : saves system parameters into the flash memory.  UF_SaveConfiguration : saves system configurations into the specified file.  UF_ReadConfigurationHeader : reads configuration information stored in a file.  UF_LoadConfiguration : loads system configurations from the specified file.  UF_MakeParameterConfiguration : makes parameter configuration data to be saved.",
            "title": "3.7. System Parameters API"
        },
        {
            "location": "/documents/API_Specification/#uf_initsysparameter",
            "text": "To prevent redundant communication, the SFM SDK caches the system parameters previously read or written.  UF_InitSysParameter  clears this cache. It is called in  UF_Reconnect .   Description  void   UF_InitSysParameter ()   Parameters \nNone  Return Values \nNone",
            "title": "UF_InitSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_getsysparameter",
            "text": "Reads the value of a system parameter.   Description  UF_RET_CODE   UF_GetSysParameter (   UF_SYS_PARAM   parameter ,   UINT32 *   value   )   Parameters  parameter \nSystem parameter to be read.  value \nPointer to the value of the specified system parameter to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . If there is no such parameter, return UF_ERR_NOT_FOUND. Otherwise, return the corresponding error code.",
            "title": "UF_GetSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_setsysparameter",
            "text": "Writes the value of a system parameter. The parameter value is changed in memory only. To make the change permanent,  UF_Save  should be called after this function. For BioEntry Smart and Pass, users cannot change the  UF_SYS_MODULE_ID  system parameter.   Description  UF_RET_CODE   UF_SetSysParameter (   UF_SYS_PARAM   parameter ,   UINT32   value   )   Parameters  parameter \nSystem parameter to be written.  value \nValue of the system parameter. Refer to the Packet Protocol Manual for available values for each parameter.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . If there is no such parameter, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_SetSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_getmultisysparameter",
            "text": "Reads the values of multiple system parameters.   Description  UF_RET_CODE   UF_GetMultiSysParameter (   int   parameterCount ,   UF_SYS_PARAM \\ *   parameters ,   UINT32 \\ *   values   )   Parameters  parameterCount \nNumber of system parameters to be read.  parameters \nArray of system parameters to be read.  values \nArray of the values of the specified system parameters to be read.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example  // To read 3 system parameters, UF_SYS_TIMEOUT, UF_SYS_ENROLL_MODE,  // UF_SYS_SECURITY_LEVEL,  UF_SYS_PARAM   parameters [ 3 ]   =   {   UF_SYS_TIMEOUT ,   UF_SYS_ENROLL_MODE ,   UF_SYS_SECURITY_LEVEL   };  UINT32   values [ 3 ];  UF_RET_CODE   result   =   UF_GetMultiSysParameter (   3 ,   parameters ,   values   );",
            "title": "UF_GetMultiSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_setmultisysparameter",
            "text": "Writes the values of multiple system parameters. The parameter value is changed in memory only. To make the change permanent,  UF_Save  should be called.   Description  UF_RET_CODE   UF_SetMultiSysParameter (   int   parameterCount ,   UF_SYS_PARAM \\ *   parameters ,   UINT32 \\ *   values   )   Parameters  parameterCount \nNumber of system parameters to be written.  parameters \nArray of system parameters to be written.  values \nArray of the values of the specified system parameters to be written.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetMultiSysParameter"
        },
        {
            "location": "/documents/API_Specification/#uf_save",
            "text": "Saves the system parameters into the flash memory.   Description  UF_RET_CODE   UF_Save ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_Save"
        },
        {
            "location": "/documents/API_Specification/#uf_saveconfiguration",
            "text": "Saves system configurations into the specified file. The configuration file consists of a file header and multiple configuration components. There are 5 configuration components to be saved. typedef   enum   {       UF_CONFIG_PARAMETERS    =   0x01 ,   // System parameters       UF_CONFIG_GPIO          =   0x02 ,   // GPIO configurations for                                     // SFM3000       UF_CONFIG_IO            =   0x04 ,   // IO configurations for                                     // SFM3500       UF_CONFIG_WIEGAND       =   0x08 ,   // Extended Wiegand       UF_CONFIG_USER_MEMORY   =   0x10 ,   // User memory  }   UF_CONFIG_TYPE ;    Description  UF_RET_CODE   UF_SaveConfiguration (   const   char *   filename ,   const   char *   description ,   int   numOfComponent ,   UFConfigComponentHeader *   componentHeader ,   void **   componentData   )   Parameters  filename \nNull-terminated string that specifies the file name.  description \nNull-terminated string describing the configuration file. The maximum length of description is 256 bytes.  numOfComponent \nNumber of components to be saved.  componentHeader \nPointer to an array of UFConfigComponentHeader structures to be saved.    typedef   struct   {       UF_CONFIG_TYPE   type ;       UINT32   dataSize ;       UINT32   checksum ;  }   UFConfigComponentHeader ;   componentData \nPointer to an array of component data to be saved.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example  // To save system parameters and IO configuration  // of a SFM 3500 module into \u201cSFM3500.cfg\u201d file,  UF_ConfigComponentHeader   configHeader [ 2 ];  void *   configData [ 2 ];  // Make system parameter component  UFConfigParameter *   parameter   =   ( UFConfigParameter * ) malloc (   sizeof ( int )   +       NUM_OF_PARAMETER   *   sizeof ( UFConfigParameterItem )   );  UF_MakeParameterConfiguration (   & configHeader [ 0 ],( BYTE * ) parameter   );  configData [ 0 ]   =   ( void * ) parameter ;  // Make IO component  UFConfigIO *   io   =   ( UFConfigIO * ) malloc (   sizeof ( UFConfigIO )   +       sizeof ( UFConfigOutputItem )   *   ( UF_MAX_OUTPUT_EVENT   -   1 )   );  UF_MakeIOConfiguration (   & configHeader [ 1 ],   ( BYTE * ) io   );  configData [ 1 ]   =   ( void * ) io ;  UF_RET_CODE   result   =   UF_SaveConfiguration (   \u201c SFM3500 . cfg \u201d ,   \u201c Configuration       file   for   SFM3500 \u201d ,   2 ,   configHeader ,   configData   );",
            "title": "UF_SaveConfiguration"
        },
        {
            "location": "/documents/API_Specification/#uf_readconfigurationheader",
            "text": "Reads the header information from a file which is saved by  UF_SaveConfiguration .   Description  UF_RET_CODE   UF_ReadConfigurationHeader (   const   char *   filename ,   UFConfigFileHeader *   header   )   Parameters  filename \nNull-terminated string that specifies the file name.  header \nPointer to the UFConfigFileHeader to be read.    typedef   struct   {       UINT32   magicNo ;   // if valid, UF_VALID_CONFIG_FILE       UINT32   numOfComponent ;       char   description [ 256 ];  }   UFConfigFileHeader ;   Return Values \nIf the header is read successfully, return  UF_RET_SUCCESS . If the file is of invalid type, return  UF_ERR_INVALID_FILE . Otherwise, return the corresponding error code.",
            "title": "UF_ReadConfigurationHeader"
        },
        {
            "location": "/documents/API_Specification/#uf_loadconfiguration",
            "text": "Loads system configurations into a module from the specified file. To make permanent the configuration changes,  UF_Save  should be called after  UF_LoadConfiguration .   Description  UF_RET_CODE   UF_LoadConfiguration (   const   char *   filename ,   int   numOfComponent ,   UF_CONFIG_TYPE *   type   )   Parameters  filename \nNull-terminated string that specifies the file name.  numOfComponent \nNumber of configuration components to be loaded.  type \nArray of component types to be loaded.    Return Values \nIf the configurations are loaded successfully, return UF_RET_SUCCESS. Otherwise, return the corresponding error code.    Example     // To load system parameters and IO configuration  // of a SFM 3500 module from \u201cSFM3500.cfg\u201d file,  UF_CONFIG_TYPE   configType [ 2 ]   =   {   UF_CONFIG_PARAMETERS ,   UF_CONFIG_IO   };  UF_RET_CODE   result   =   UF_LoadConfiguration (   \u201c SFM3500 . cfg \u201d ,   2 ,   configType   );",
            "title": "UF_LoadConfiguration"
        },
        {
            "location": "/documents/API_Specification/#uf_makeparameterconfiguration",
            "text": "Make a UFConfigComponentHeader and a UFConfigParameter structure to be used in  UF_SaveConfiguration .   Description  UF_RET_CODE   UF_MakeParameterConfiguration (   UFConfigComponentHeader *   configHeader ,   BYTE *   configData   )   Parameters  configHeader \nPointer to the UFConfigComponentHeader structure.  configData \nPointer to the UFConfigParameter structure. It should be preallocated large enough to store all the parameter information.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_MakeParameterConfiguration"
        },
        {
            "location": "/documents/API_Specification/#38-template-management-api",
            "text": "These functions provide template management interfaces such as read, delete and fix. Users can also manage user ids and administration levels associated with templates using these APIs.   UF_GetNumOfTemplate : gets the number of template stored in a module.  UF_GetMaxNumOfTemplate : gets the template capacity of a module.  UF_GetAllUserInfo : gets all the template and user information stored in a module.  UF_GetAllUserInfoEx : gets all the template and user information stored in a BioEntry reader.  UF_SortUserInfo : sorts UFUserInfo structures.  UF_SetUserInfoCallback : sets the callback function for getting user information.  UF_SetAdminLevel : sets the administration level of a user.  UF_GetAdminLevel : gets the administration level of a user.  UF_ClearAllAdminLevel : clears all the administration levels of users.  UF_SaveDB : saves templates and user information into the specified file.  UF_LoadDB : loads templates and user information from the specified file.  UF_CheckTemplate : checks if the specified ID has templates.  UF_ReadTemplate : reads the templates of the specified user ID.  UF_ReadOneTemplate : reads one template of the specified user ID.  UF_SetScanCallback : sets the callback function for scanning fingerprints.  UF_ScanTemplate : scans a fingerprint on the sensor and retrieves the fingerprint template.  UF_FixProvisionalTemplate : saves the provisional templates into the flash memory.  UF_SetSecurityLevel : sets the security level of a user.  UF_GetSecurityLevel : gets the security level of a user.  UF_SetAuthType : sets the authentication type of a user.  UF_GetAuthType : gets the authentication type of a user.  UF_GetUserIDByAuthType : gets the user IDs with specified authentication type.  UF_ResetAllAuthType : resets the authentication types of all users.  UF_SetEntranceLimit : sets the entrance limit of a user.  UF_GetEntranceLimit : gets the entrance limit of a user.  UF_ClearAllEntranceLimit : clears the entrance limits of all users.",
            "title": "3.8. Template Management API"
        },
        {
            "location": "/documents/API_Specification/#uf_getnumoftemplate",
            "text": "Gets the number of templates stored in the module.   Description  UF_RET_CODE   UF_GetNumOfTemplate (   UINT32 *   numOfTemplate   )   Parameters  numOfTemplate \nPointer to the number of templates to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetNumOfTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_getmaxnumoftemplate",
            "text": "Gets the template capacity of the module.   Description  UF_RET_CODE   UF_GetMaxNumOfTemplate (   UINT32 *   maxNumOfTemplate   )   Parameters  maxNumOfTemplate \nPointer to the template capacity to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetMaxNumOfTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_getalluserinfo",
            "text": "Retrieves all the user and template information stored in the module.   Description  UF_RET_CODE   UF_GetAllUserInfo (   UFUserInfo \\ *   userInfo ,   UINT32 \\ *   numOfUser ,   UINT32 \\ *   numOfTemplate   )   Parameters  userInfo \nArray of UFUserInfo structures, which will store all the information. This pointer should be preallocated large enough to store all the information. UFUserInfo structure is defined as follows;    typedef   struct   {       UINT32   userID ;       BYTE   numOfTemplate ;       BYTE   adminLevel ;   // See UF_SetAdminLevel       BYTE   securityLevel ;   // See UF_SetSecurityLevel       BYTE   reserved ;  }   UFUserInfo ;   numOfUser \nPointer to the number of users to be returned.  numOfTemplate \nPointer to the number of templates to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.    Example     UINT32   maxUser ;  UINT32   numOfUser ,   numOfTemplate ;  UF_RET_CODE   result   =   UF_GetSysParameter (   UF_SYS_ENROLLED_FINGER ,   & maxUser   );  UFUserInfo *   userInfo   =   ( UFUserInfo * ) malloc (   maxUser   *   sizeof ( UFUserInfo )   );  result   =   UF_GetAllUserInfo (   userInfo ,   & numOfUser ,   & numOfTemplate   );",
            "title": "UF_GetAllUserInfo"
        },
        {
            "location": "/documents/API_Specification/#uf_getalluserinfoex",
            "text": "Retrieves all the user and template information stored in the BioEntry reader.   Description  UF_RET_CODE   UF_GetAllUserInfoEx (   UFUserInfoEx *   userInfo ,   UINT32 *   numOfUser ,   UINT32 *   numOfTemplate   )   Parameters  userInfo \nArray of  UFUserInfoEx  structures, which will store all the information. This pointer should be preallocated large enough to store all the information.  UFUserInfoEx  structure is defined as follows;  typedef   struct   {       UINT32   userID ;       UINT32   checksum [ 10 ];   // checksum of each template data       BYTE   numOfTemplate ;       BYTE   adminLevel ;       BYTE   duress [ 10 ];       BYTE   securityLevel ;  }   UFUserInfoEx ;   numOfUser \nPointer to the number of users to be returned.  numOfTemplate \nPointer to the number of templates to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetAllUserInfoEx"
        },
        {
            "location": "/documents/API_Specification/#uf_sortuserinfo",
            "text": "Sorts an  UFUserInfo  array in ascending order of user ID.   Description  void   UF_SortUserInfo (   UFUserInfo *   userInfo ,   int   numOfUser   )   Parameters  userInfo \nArray of UFUserInfo structures.  numOfUser \nNumber of UFUserInfo.    Return Values \nNone",
            "title": "UF_SortUserInfo"
        },
        {
            "location": "/documents/API_Specification/#uf_setuserinfocallback",
            "text": "Sets the callback function for getting user information. It is also called when enrolling templates in  UF_LoadDB  and reading templates in  UF_SaveDB .   Description  void   UF_SetUserInfoCallback (   void   ( * callback )(   int   index ,   int   numOfTemplate   )   )   Parameters  callback \nPointer to the callback function.  Return Values \nNone  Example \nSee CMainFrame::UserInfoCallback in UniFingerUI source codes.",
            "title": "UF_SetUserInfoCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_setadminlevel",
            "text": "Sets the administration level of a user. See  UF_EnrollAfterVerification  and  UF_DeleteAllAfterVerificatoin  for usage of administration level.   Description  UF_RET_CODE   UF_SetAdminLevel (   UINT32   userID ,   UF_ADMIN_LEVEL   adminLevel   )   Parameters  userID \nUser ID.  adminLevel \nSpecifies the administration level of the user.       Value  Note      UF_ADMIN_NONE     UF_ADMIN_ENROLL  Can enroll users.    UF_ADMIN_DELETE  Can delete users.    UF_ADMIN_ALL  Can enroll and delete users.     Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetAdminLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_getadminlevel",
            "text": "Gets the administration level of a user.   Description  UF_RET_CODE   UF_GetAdminLevel (   UINT32   userID ,   UF_ADMIN_LEVEL *   adminLevel   )   Parameters  userID \nUser ID.  adminLevel \nPointer to the administration level of the user to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetAdminLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_clearalladminlevel",
            "text": "Resets administration levels of all users to UF_ADMIN_NONE.   Description  UF_RET_CODE   UF_ClearAllAdminLevel ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllAdminLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_savedb",
            "text": "Saves all the templates and user information stored in a module into the specified file.   Description  UF_RET_CODE   UF_SaveDB (   const   char *   fileName   )   Parameters  fileName \nNull-terminated string that specifies the file name.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SaveDB"
        },
        {
            "location": "/documents/API_Specification/#uf_loaddb",
            "text": "Loads templates and user information from the specified file. All the templates previously stored in the module will be erased before loading the DB.   Description  UF_RET_CODE   UF_LoadDB (   const   char *   fileName   )   Parameters  fileName \nNull-terminated string that specifies the file name.  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_LoadDB"
        },
        {
            "location": "/documents/API_Specification/#uf_checktemplate",
            "text": "Checks if the specified user ID has enrolled templates.   Description  UF_RET_CODE   UF_CheckTemplate (   UINT32   userID ,   UINT32 *   numOfTemplate   )   Parameters  userID \nUser ID.  numOfTemplate \nPointer to the number of templates of the user ID to be returned.    Return Values \nIf there are templates of the user ID, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_CheckTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_readtemplate",
            "text": "Reads  the templates of the specified user ID.   Description  UF_RET_CODE   UF_ReadTemplate (   UINT32   userID ,   UINT32 *   numOfTemplate ,   BYTE *   templateData   )   Parameters  userID \nUser ID.  numOfTemplate \nPointer to the number of templates of the user ID to be returned.  templateData \nPointer to the template data to be returned. This pointer should be preallocated large enough to store all the template data.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_readonetemplate",
            "text": "Reads one template of the specified user ID.   Description  UF_RET_CODE   UF_ReadOneTemplate (   UINT32   userID ,   int   subID ,   BYTE *   templateData   )   Parameters  userID \nUser ID.  subID \nSub index of the template. It is between 0 and 9.  templateData \nPointer to the template data to be returned. This pointer should be preallocated large enough to store all the template data.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadOneTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_setscancallback",
            "text": "Sets the callback function of scanning fingerprints. This callback is called when  SCAN_SUCCESS  message is received.   Description  void   UF_SetScanCallback (   void   ( * callback )(   BYTE   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone",
            "title": "UF_SetScanCallback"
        },
        {
            "location": "/documents/API_Specification/#uf_scantemplate",
            "text": "Scans a fingerprint on the sensor and receives the template of it.   Description  UF_RET_CODE   UF_ScanTemplate (   BYTE *   templateData ,   UINT32 *   templateSize ,   UINT32 *   imageQuality   )   Parameters  templateData \nPointer to the template data to be returned.  templateSize \nPointer to the template size to be returned.  imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ScanTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_fixprovisionaltemplate",
            "text": "UF_SYS_PROVISIONAL_ENROLL  determines if enrolled templates are saved permanently into flash memory or temporarily into DRAM. With provisional enroll, enrolled templates on DRAM will be erased if the module is turned off.  UF_FixProvisionalTemplate  saves the provisional templates into the flash memory.   Description  UF_RET_CODE   UF_FixProvisionalTemplate ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_FixProvisionalTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_setsecuritylevel",
            "text": "Since V1.6 firmware, the security level can be assigned per user basis for 1:1 matching. 1:N matching \u2013 identification \u2013 is not affected by this setting.   Description  UF_RET_CODE   UF_SetSecurityLevel (   UINT32   userID ,   UF_USER_SECURITY_LEVEL   securityLevel   )   Parameters  userID \nUser ID.  securityLevel \nSpecifies the security level of the user.       Value  Note      UF_USER_SECURITY_DEFAULT  Same as defined by Security Level system parameter    UF_USER_SECURITY_1_TO_1000     \u2026     UF_USER_SECURITY_1_TO_100000000      Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetSecurityLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_getsecuritylevel",
            "text": "Gets the security level of a user.   Description  UF_RET_CODE   UF_GetSecurityLevel (   UINT32   userID ,   UF_SECURITY_LEVEL *   securityLevel   )   Parameters  userID \nUser ID.  securityLevel \nPointer to the security level of the user to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetSecurityLevel"
        },
        {
            "location": "/documents/API_Specification/#uf_setauthtype",
            "text": "Sets the authentication type of a user.  UF_AUTH_BYPASS  can be used for 1:1 matching, when it is necessary to allow access without matching fingerprints.  UF_AUTH_REJECT  can be used for disabling some IDs temporarily. The default authentication mode is  UF_AUTH_FINGERPRINT .   Description  UF_RET_CODE   UF_SetAuthType (   UINT32   userID ,   UF_AUTH_TYPE   authType   )   Parameters  userID \nUser ID.  authType \nSpecifies the authentication type of the user.       Value  Note      UF_AUTH_FINGERPRINT  Fingerprint authentication.    UF_AUTH_BYPASS  Authentication will succeed without matching fingerprints.    UF_AUTH_REJECT  Authentication will always fail.     Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_getauthtype",
            "text": "Gets the authentication type of a user.   Description  UF_RET_CODE   UF_GetAuthType (   UINT32   userID ,   UF_AUTH_TYPE *   authType   )   Parameters  userID \nUser ID.  authType \nPointer to the authentication type of the user to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_getuseridbyauthtype",
            "text": "Receive user IDs with the specified authentication type.   Description  UF_RET_CODE   UF_GetUserIDByAuthType (   UF_AUTH_TYPE   authType ,   int *   numOfID ,   UINT32 *   userID   )   Parameters  authType \nAuthentication type.  numOfID \nPointer to the number of user IDs to be returned.  userID \nArray of user IDs which have the specified authentication type.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetUserIDByAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_resetallauthtype",
            "text": "Resets the authentication types of all users to UF_AUTH_FINGERPRINT.   Description  UF_RET_CODE   UF_ResetAllAuthType ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ResetAllAuthType"
        },
        {
            "location": "/documents/API_Specification/#uf_setentrancelimit",
            "text": "Specifies how many times the user is permitted to access per day. The available options are between 0 and 7. The default value is 0, which means that there is no limit. If the user tries to authenticate after the limit is reached,  UF_ERR_EXCEED_ENTRANCE_LIMIT  error will be returned.   Description  UF_RET_CODE   UF_SetEntranceLimit (   UINT32   userID ,   int   entranceLimit   )   Parameters  userID \nUser ID.  entranceLimit \nEntrance limit between 0 and 7.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#uf_getentrancelimit",
            "text": "Gets the entrance limit of a user.   Description  UF_RET_CODE   UF_GetEntranceLimit (   UINT32   userID ,   int *   entranceLimit ,   int *   entranceCount   )   Parameters  userID \nUser ID.  entranceLimit \nPointer to the entrance limit of the user.  entranceCount \nPointer to the number of entrance for today. This count is reset to 0 at midnight.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#uf_clearallentrancelimit",
            "text": "Resets the entrance limits of of all users to 0 \u2013 infinite.   Description  UF_RET_CODE   UF_ClearAllEntranceLimit ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#39-image-manipulation-api",
            "text": "UFImage is a data structure for exchanging image data between the host and the module. It consists of 28 byte header and raw image data. typedef   struct   {       int   width ;   // width of the fingerprint image       int   height ;   // height of the fingerprint image       int   compressed ;   // compression status \u2013 currently not used       int   encrypted ;   // encryption status \u2013 currently not used       int   format ;   // 0- gray, 1- binary, 2- 4bit gray       int   imgLen ;   // width * height       int   templateLen ;   // size of fingerprint template \u2013 currently not used       BYTE   buffer [ 1 ]; // pointer to the raw pixel data  }   UFImage ;    UF_ConvertToBitmap : converts a UFImage structure into HBITMAP.  UF_SaveImage : saves a UFImage structure into BMP file.  UF_LoadImage : loads a BMP file and convert it into a UFImage structure.  UF_ReadImage : retrieves the last scanned fingerprint image.  UF_ScanImage : scans a fingerprint on the sensor and retrieves the image data.",
            "title": "3.9. Image Manipulation API"
        },
        {
            "location": "/documents/API_Specification/#uf_converttobitmap",
            "text": "To display a UFImage on the PC screen, it should be converted to a bitmap first.  UF_ConvertToBitmap  converts a  UFImage  into a device independent bitmap and returns the handle of it. After drawing the bitmap, it should be destroyed by calling  DeleteObject() .   Description  HBITMAP   UF_ConvertToBitmap (   UFImage *   image   )   Parameters  image \nPointer to the UFImage structure to be converted.    Return Values \nIf the function succeeds, return the  HBITMAP  of the bitmap. Otherwise, return  NULL .  Example     // The following snippet is from FingerprintViewer.cpp in UniFingerUI  // source codes  class   CFingerprintViewer   :   public   CStatic  {       // \u2026  Private :       UFImage *   m_Image ;       HBITMAP   m_Bitmap ;  };  void   CFingerprintViewer::OnPaint ()  {       CPaintDC   dc (   this   );       CBitmap   bmp ;       if (   m_Bitmap   )       {           DeleteObject (   m_Bitmap   );       }       if (   m_Image   )       {           m_Bitmap   =   UF_ConvertToBitmap (   m_Image   );           bmp . Attach (   m_Bitmap   );       }       else       {           bmp . LoadBitmap (   IDB_LOGO   );       }       CDC   bmDC ;       bmDC . CreateCompatibleDC ( & dc );       CBitmap   * pOldbmp   =   bmDC . SelectObject ( & bmp );       BITMAP   bi ;       bmp . GetBitmap ( & bi );       CRect   rect ;       this -> GetClientRect ( & rect );       dc . SetStretchBltMode (   HALFTONE   );       dc . StretchBlt (   1 ,   1 ,   rect . Width ()   -   2 ,   rect . Height ()   -   2 ,   & bmDC ,   0 ,   0 ,   bi . bmWidth ,   bi . bmHeight ,   SRCCOPY   );       bmDC . SelectObject ( pOldbmp );  }",
            "title": "UF_ConvertToBitmap"
        },
        {
            "location": "/documents/API_Specification/#uf_saveimage",
            "text": "Converts a UFImage into a bitmap and save it into the specified file.   Description  UF_RET_CODE   UF_SaveImage (   const   char *   fileName ,   UFImage *   image   )   Parameters  fileName   \nNull-terminated string that specifies the file name.  image \nPointer to the UFImage to be saved.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SaveImage"
        },
        {
            "location": "/documents/API_Specification/#uf_loadimage",
            "text": "Loads a bmp file into a UFImage structure.   Description  UF_RET_CODE   UF_LoadImage (   const   char *   fileName ,   UFImage *   image   )   Parameters  fileName \nNull-terminated string that specifies the file name.  image \nPointer to the UFImage structure.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_LoadImage"
        },
        {
            "location": "/documents/API_Specification/#uf_readimage",
            "text": "Reads the last scanned fingerprint image.   Description  UF_RET_CODE   UF_ReadImage (   UFImage *   image   )   Parameters  image \nPointer to the UFImage structure.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example  UFImage *   image   =   ( UFImage * ) malloc (   UF_IMAGE_HEADER_SIZE   +                   UF_MAX_IMAGE_SIZE   );  UF_RET_CODE   result   =   UF_ReadImage (   image   );",
            "title": "UF_ReadImage"
        },
        {
            "location": "/documents/API_Specification/#uf_scanimage",
            "text": "Scans a fingerprint input on the sensor and retrieves the image of it.   Description  UF_RET_CODE   UF_ScanImage (   UFImage *   image   )   Parameters  image \nPointer to the UFImage structure.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ScanImage"
        },
        {
            "location": "/documents/API_Specification/#310-enroll-api",
            "text": "There are three ways to enroll fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere. The enrollment process varies according to  UF_SYS_ENROLL_MODE  parameter. Users can also fine tune the enrollment process by selecting enroll options.   UF_Enroll : enrolls fingerprint inputs on the sensor.  UF_EnrollContinue : continues the enrollment process when the enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2.  UF_EnrollAfterVerification : enrolls after an administrator is verified.  UF_EnrollTemplate : enrolls a template.  UF_EnrollMultipleTemplates : enrolls multiple templates to the specified ID.  UF_EnrollImage : enrolls a fingerprint image.  UF_SetEnrollCallback : sets the callback function for enrollment process.",
            "title": "3.10. Enroll API"
        },
        {
            "location": "/documents/API_Specification/#uf_enroll",
            "text": "Enrolls fingerprint inputs on the sensor. The enrollment process varies according to the  UF_SYS_ENROLL_MODE  system parameter.     Enroll Mode  Description      UF_ENROLL_ONE_TIME  Scans a fingerprint and enrolls it.    UF_ENROLL_TWO_TIMES1  Scans two fingerprints and enrolls the better one of the two. The scanning of the second fingerprint starts automatically.    UF_ENROLL_TWO_TIMES2  Same as UF_ENROLL_TWO_TIMES1, but the scanning of the second fingerprint should be initiated by another request packet.    UF_ENROLL_TWO_TEMPLATES1  Scans two fingerprints and enrolls both of them. The scanning of the second fingerprint starts automatically.    UF_ENROLL_TWO_TEMPLATES2  Same as UF_ENROLL_TWO_TEMPLATES1, but the scanning of the second fingerprint should be initiated by another request packet.     Users can also fine tune the enrollment process by selecting one of the following UF_ENROLL_OPTIONs.     Option  Description      UF_ENROLL_NONE  Overwrites existing templates of the same ID.    UF_ENROLL_ADD_NEW  Adds templates to the same user ID. The maximum number of templates per user is 10.    UF_ENROLL_AUTO_ID  The user ID will be assigned automatically by the module.    UF_ENROLL_CHECK_ID  Before enrolling, checks if the user ID has already some templates. If it does, UF_ERR_EXIST_ID will be returned. This option is useful when users do not want to overwrite existing templates.    UF_ENROLL_CHECK_FINGER  Before enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_ADD_NEW option.    UF_ENROLL_CHECK_FINGER_AUTO_ID  Before enrolling, checks if the same fingerprint is already enrolled. If the identification succeeds, return UF_ERR_EXIST_FINGER error. If the identification fails, continue enroll process with UF_ENROLL_AUTO_ID option.    UF_ENROLL_DURESS  Adds another fingerprint as duress finger to the specified user ID. Under duress, users can authenticate with duress finger to notify the threat. When duress finger is matched, the module will return UF_ERR_DURESS_FINGER error code and write a log. Users can also setup output signals for duress events. When enrolling, the duress finger should not match with nonduress fingerprints of the same ID. If it is the case, UF_ERR_EXIST_FINGER error will be returned.      Description  UF_RET_CODE   UF_Enroll (   UINT32   userID ,   UF_ENROLL_OPTION   option ,   UINT32 *   enrollID ,   UINT32 *   imageQuality   )   Parameters  userID \nUser ID.  option \nEnroll option.  enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when  AUTO_ID  option is used.  imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.    Return Values \nIf enroll succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_Enroll"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollcontinue",
            "text": "Continues the enrollment process when the enroll mode is  UF_ENROLL_TWO_TIMES2  or  UF_ENROLL_TWO_TEMPLATES2 .   Description  UF_RET_CODE   UF_EnrollContinue (   UINT32   userID ,   UINT32 *   enrollID ,   UINT32 *   imageQuality   )   Parameters  userID \nUser ID.  enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when  AUTO_ID  option is used.  imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.    Return Values \nIf enroll succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example     // To enroll user ID 10 with enroll option of ADD_NEW,  UINT32   mode ;  UF_RET_CODE   result   =   UF_GetSysParameter (   UF_SYS_ENROLL_MODE ,   & mode   );  UINT32   userID ,   imageQuality ;  result   =   UF_Enroll (   10 ,   UF_ENROLL_ADD_NEW ,   & userID ,   & imageQuality   );  // If enroll mode is UF_ENROLL_TWO_TIMES2 or UF_ENROLL_TWO_TEMPLATES2  If (   result   ==   UF_RET_SUCCESS   &&   ( mode   ==   UF_ENROLL_TWO_TEMPLATES2   ||   mode   ==   UF_ENROLL_TWO_TIMES2   )   )  {       result   =   UF_EnrollContinue (   10 ,   & userID ,   & imageQuality   );  }",
            "title": "UF_EnrollContinue"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollafterverification",
            "text": "Enroll and Delete functions change the fingerprint DB stored in the module. For some applications, it might be necessary to obtain administrator\u2019s permission before enrolling or deleting fingerprints. To process these functions, a user with proper administration level should verify himself first. If there is no user with co1rresponding administration level, these commands will fail with  UF_ERR_UNSUPPORTED  error code. If the verification fails,  UF_ERR_NOT_MATCH  error code will be returned. The only exception is that  UF_EnrollAfterVerification  will succeed when the fingerprint DB is empty. In that case, the first user enrolled by  UF_EnrollAfterVerification  will have  UF_ADMIN_LEVEL_ALL .   Description  UF_RET_CODE   UF_EnrollAfterVerification (   UINT32   userID ,   UF_ENROLL_OPTION   option ,   UINT32 *   enrollID ,   UINT32 *   imageQuality   )   Parameters  userID \nUser ID.  option \nEnroll option.  enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when  AUTO_ID  option is used.  imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.    Return Values \nIf enroll succeeds, return  UF_RET_SUCCESS . If there is no user with corresponding administration level, return  UF_ERR_UNSUPPORTED . If administrator\u2019s verification fails, return  UF_ERR_NOT_MATCH . Otherwise, return the corresponding error code.",
            "title": "UF_EnrollAfterVerification"
        },
        {
            "location": "/documents/API_Specification/#uf_enrolltemplate",
            "text": "Enrolls a fingerprint template.   Description  UF_RET_CODE   UF_EnrollTemplate (   UINT32   userID ,   UF_ENROLL_OPTION   option ,   UINT32   templateSize ,   BYTE *   templateData ,   UINT32 *   enrollID   )   Parameters  userID \nUser ID.  option \nEnroll option.  templateSize \nSize of the template data.  templateData \nPointer to the template data.  enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when  AUTO_ID  option is used.    Return Values \nIf enroll succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_EnrollTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollmultipletemplates",
            "text": "Enrolls multiple templates to the specified ID.   Description  UF_RET_CODE   UF_EnrollMultipleTemplates (   UINT32   userID ,   UF_ENROLL_OPTION   option ,   int   numOfTemplate ,   UINT32   templateSize ,   BYTE *   templateData ,   UINT32 *   enrollID   )   Parameters  userID   \nUser ID.  option \nEnroll option.  numOfTemplate \nNumber of templates to be enrolled.  templateSize \nSize of one template data. For example, when enroll 3 templates of 384 byte, this parameter is 384 not 1152.  templateData \nPointer to the template data.  enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when  AUTO_ID  option is used.    Return Values \nIf enroll succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_EnrollMultipleTemplates"
        },
        {
            "location": "/documents/API_Specification/#uf_enrollimage",
            "text": "Enrolls a fingerprint image.   Description  UF_RET_CODE   UF_EnrollImage (   UINT32   userID ,   UF_ENROLL_OPTION   option ,   UINT32   imageSize ,   BYTE *   imageData ,   UINT32 *   enrollID ,   UINT32 *   imageQuality   )   Parameters  userID \nUser ID.  option \nEnroll option.  imageSize \nSize of the image data.  imageData \nPointer to the raw image data. Note that it is not the pointer to  UFImage , but the pointer to the raw pixel data without the  UFImage  header.  enrollID \nPointer to the enrolled user ID. This parameter can be different from userID when  AUTO_ID  option is used..  imageQuality \nPointer to the image quality score to be returned. The score shows the quality of scanned fingerprint and is in the range of 0 ~ 100.    Return Values \nIf enroll succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_EnrollImage"
        },
        {
            "location": "/documents/API_Specification/#uf_setenrollcallback",
            "text": "Sets the callback function for enrollment process. This callback is called after receiving response packets with  UF_PROTO_RET_SCAN_SUCCESS ,  UF_PROTO_RET_SUCCESS , or  UF_PROTO_RET_CONTINUE  messages.   Description  void   UF_SetEnrollCallback (   void   ( * callback )(   BYTE   errCode ,   UF_ENROLL_MODE   enrollMode ,   int   numOfSuccess   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone",
            "title": "UF_SetEnrollCallback"
        },
        {
            "location": "/documents/API_Specification/#311-identify-api",
            "text": "Checks if a fingerprint input is among the enrolled user ids. While verification checks only the fingerprints of a specified user id, identification searches all the enrolled fingerprints until a match is found. As in enrollment, there are three ways to identify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.   UF_Identify : identifies the fingerprint input on the sensor.  UF_IdentifyTemplate : identifies a template.  UF_IdentifyImage : identifies a fingerprint image.  UF_SetIdentifyCallback : sets the callback function for identification.",
            "title": "3.11. Identify API"
        },
        {
            "location": "/documents/API_Specification/#uf_identify",
            "text": "Identifies the fingerprint input on the sensor.   Description  UF_RET_CODE   UF_Identify (   UINT32 *   userID ,   BYTE *   subID   )   Parameters  userID \nPointer to the user ID to be returned.  subID \nPointer to the index of the template to be returned.    Return Values \nIf matching succeeds, return  UF_RET_SUCCESS . If matching fails, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_Identify"
        },
        {
            "location": "/documents/API_Specification/#uf_identifytemplate",
            "text": "Identifies a template.   Description  UF_RET_CODE   UF_IdentifyTemplate (   UINT32   templateSize ,   BYTE *   templateData ,   UINT32 *   userID ,   BYTE *   subID   )   Parameters  templateSize \nSize of the template data.  templateData \nPointer to the template data.  userID \nPointer to the user ID to be returned.  subID \nPointer to the index of the template to be returned.   Return Values \nIf matching succeeds, return  UF_RET_SUCCESS . If matching fails, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_IdentifyTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_identifyimage",
            "text": "Identifies a fingerprint image.   Description  UF_RET_CODE   UF_IdentifyImage (   UINT32   imageSize ,   BYTE *   imageData ,   UINT32 *   userID ,   BYTE *   subID   )   Parameters  imageSize \nSize of the image data.  imageData \nPointer to the raw image data. Note that it is not the pointer to UFImage, but the pointer to the raw pixel data without the UFImage header.  userID \nPointer to the user ID to be returned.  subID \nPointer to the index of the template to be returned.    Return Values \nIf matching succeeds, return  UF_RET_SUCCESS . If matching fails, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_IdentifyImage"
        },
        {
            "location": "/documents/API_Specification/#uf_setidentifycallback",
            "text": "Sets the callback function for identification process. This callback is called after receiving  UF_PROTO_RET_SCAN_SUCCESS  message.   Description  void   UF_SetIdentifyCallback (   void   ( * callback )(   BYTE   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone",
            "title": "UF_SetIdentifyCallback"
        },
        {
            "location": "/documents/API_Specification/#312-verify-api",
            "text": "Verifies if a fingerprint input matches the enrolled fingerprints of the specified user id. As in enroll process, there are three ways to verify fingerprints; scanning live fingerprints, using scanned images, or sending templates acquired elsewhere.   UF_Verify : verifies the fingerprint input on the sensor.  UF_VerifyTemplate : verifies a template.  UF_VerifyHostTemplate : verifies the fingerprint input on the sensor with the templates sent by the host.  UF_VerifyImage : verifies a fingerprint image.  UF_SetVerifyCallback : sets the callback function for verification process.",
            "title": "3.12. Verify API"
        },
        {
            "location": "/documents/API_Specification/#uf_verify",
            "text": "Verifies if a fingerprint input on the sensor matches the enrolled fingerprints of the specified user id.   Description  UF_RET_CODE   UF_Verify (   UINT32   userID ,   BYTE *   subID   )   Parameters  userID \nUser ID.  subID \nPointer to the index of the template to be returned.    Return Values \nIf matching succeeds, return  UF_RET_SUCCESS . If matching fails, return  UF_ERR_NOT_MATCH . Otherwise, return the corresponding error code.",
            "title": "UF_Verify"
        },
        {
            "location": "/documents/API_Specification/#uf_verifytemplate",
            "text": "Verifies a template.   Description  UF_RET_CODE   UF_VerifyTemplate (   UINT32   templateSize ,   BYTE *   templateData ,   UINT32   userID ,   BYTE *   subID   )   Parameters  templateSize \nSize of the template data.  templateData \nPointer to the template data to be sent.  userID \nUser ID.  subID \nPointer to the index of the template to be returned.    Return Values \nIf matching succeeds, return  UF_RET_SUCCESS . If matching fails, return  UF_ERR_NOT_MATCH . Otherwise, return the corresponding error code.",
            "title": "UF_VerifyTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_verifyhosttemplate",
            "text": "Transmits fingerprint templates from the host to the module and verifies if they match the live fingerprint input on the sensor.   Description  UF_RET_CODE   UF_VerifyHostTemplate (   UINT32   numOfTemplate ,   UINT32   templateSize ,   BYTE *   templateData   )   Parameters  numOfTemplate \nNumber of templates to be transferred to the module.  templateSize \nSize of a template.  templateData \nPointer to the template data to be transferred to the module.    Return Values \nIf matching succeeds, return  UF_RET_SUCCESS . If matching fails, return  UF_ERR_NOT_MATCH . Otherwise, return the corresponding error code.",
            "title": "UF_VerifyHostTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_verifyimage",
            "text": "Verifies a fingerprint image.   Description  UF_RET_CODE   UF_VerifyImage (   UINT32   imageSize ,   BYTE *   imageData ,   UINT32   userID ,   BYTE *   subID   )   Parameters  imageSize \nSize of the fingerprint image.  imageData \nPointer to the raw image data. Note that it is not the pointer to  UFImage , but the pointer to the raw pixel data without the  UFImage  header.  userID \nUser ID.  subID \nPointer to the index of the template to be returned.    Return Values \nIf matching succeeds, return  UF_RET_SUCCESS . If matching fails, return  UF_ERR_NOT_MATCH . Otherwise, return the corresponding error code.",
            "title": "UF_VerifyImage"
        },
        {
            "location": "/documents/API_Specification/#uf_setverifycallback",
            "text": "Sets the callback function for verification process. The callback function is called after receiving  UF_PROTO_RET_SCAN_SUCCESS  message.   Description  void   UF_SetVerifyCallback (   void   ( * callback )(   BYTE   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone",
            "title": "UF_SetVerifyCallback"
        },
        {
            "location": "/documents/API_Specification/#313-delete-api",
            "text": "Provides functions for deleting stored templates.   UF_Delete : deletes the templates of the specified user ID.  UF_DeleteOneTemplate : deletes one template of the specified user ID.  UF_DeleteMultipleTemplates : deletes the template of multiple user IDs.  UF_DeleteAll : deletes all the templates.  UF_DeleteAllAfterVerification : deletes templates after administrator\u2019s verification.  UF_SetDeleteCallback : sets the callback function for delete process.",
            "title": "3.13. Delete API"
        },
        {
            "location": "/documents/API_Specification/#uf_delete",
            "text": "Deletes the enrolled templates of the specified user ID.   Description  UF_RET_CODE   UF_Delete (   UINT32   userID   )   Parameters  userID \nUser ID.    Return Values \nIf delete succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_Delete"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteonetemplate",
            "text": "Deletes one template of the specified user ID.   Description  UF_RET_CODE   UF_DeleteOneTemplate (   UINT32   userID ,   int   subID   )   Parameters  userID \nUser ID.  subID \nSub index of the template. It is between 0 and 9.    Return Values \nIf delete succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteOneTemplate"
        },
        {
            "location": "/documents/API_Specification/#uf_deletemultipletemplates",
            "text": "Deletes the enrolled templates of multiple user IDs.   Description  UF_RET_CODE   UF_DeleteMultipleTemplates (   UINT32   startUserID ,   UINT32   lastUserID ,   int *   deletedUserID   )   Parameters    startUserID \nFirst user ID to be deleted.  lastUserID \nLast user ID to be deleted.  deletedUserID \nPointer to the number of IDs to be actually deleted by the module.    Return Values \nIf delete succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example     // Delete templates of ID 10 ~ ID 20  int   numOfDeleted ;  UF_RET_CODE   result   =   UF_DeleteMultipleTemplates (   10 ,   20 ,   & numOfDeleted   );",
            "title": "UF_DeleteMultipleTemplates"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteall",
            "text": "Deletes all the templates stored in a module.   Description  UF_RET_CODE   UF_DeleteAll ()   Parameters \nNone  Return Values \nIf delete succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAll"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallafterverification",
            "text": "Deletes all the templates after administrator\u2019s verification.   Description  UF_RET_CODE   UF_DeleteAllAfterVerification ()   Parameters \nNone  Return Values \nIf delete succeeds, return  UF_RET_SUCCESS . If there is no user with corresponding administration level, return  UF_ERR_UNSUPPORTED . If administrator\u2019s verification fails, return  UF_ERR_NOT_MATCH . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllAfterVerification"
        },
        {
            "location": "/documents/API_Specification/#uf_setdeletecallback",
            "text": "Sets the callback function for delete process. This callback is called after receiving  UF_PROTO_RET_SCAN_SUCCESS  or  UF_PROTO_RET_CONTINUE .   Description  void   UF_SetDeleteCallback (   void   ( * callback )(   BYTE   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nNone",
            "title": "UF_SetDeleteCallback"
        },
        {
            "location": "/documents/API_Specification/#314-io-api-for-sfm3500",
            "text": "SFM3500 modules have three input ports, three output ports, and three LED ports which are configurable for specific functions. For BioEntry Smart and Pass, there are two input ports, two output ports, and 2 LED ports. These functions are provided to configure these IO ports.   UF_InitIO : clears the output event caches.  UF_SetInputFunction : sets the function of an input port.  UF_GetInputFunction : gets the function of an input port.  UF_GetInputStatus : gets the status of an input port.  UF_GetOutputEventList : gets the output events list assigned to an output port.  UF_ClearAllOutputEvent : clears all the output events assigned to an output port.  UF_ClearOutputEvent : clears an output event assigned to an output port.  UF_SetOutputEvent : adds an output event to an output port.  UF_GetOutputEvent : gets the signal data of an output event.  UF_SetOutputStatus : sets the status of an output port.  UF_SetLegacyWiegandConfig : sets the Wiegand format.  UF_GetLegacyWiegandConfig : gets the Wiegand format.  UF_MakeIOConfiguration : makes IO configuration data to be saved into a file.",
            "title": "3.14. IO API for SFM3500"
        },
        {
            "location": "/documents/API_Specification/#uf_initio",
            "text": "To prevent redundant communication, the SFM SDK caches the output events previously read or written.  UF_InitIO  clears the cache. It is called in  UF_Reconnect .   Description  void   UF_InitIO ()   Parameters \nNone  Return Values \nNone",
            "title": "UF_InitIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setinputfunction",
            "text": "Sets the function of an input port. Available functions are as follows;     Function  Description      UF_INPUT_NO_ACTION  No action    UF_INPUT_ENROLL  Enroll    UF_INPUT_IDENTIFY  Identify    UF_INPUT_DELETE  Delete    UF_INPUT_DELETE_ALL  Delete all    UF_INPUT_ENROLL_BY_WIEGAND  Enroll by Wiegand ID    UF_INPUT_VERIFY_BY_WIEGAND  Verify by Wiegand ID    UF_INPUT_DELETE_BY_WIEGAND  Delete by Wiegand ID    UF_INPUT_ENROLL_VERIFICATION  Enroll after administrator\u2019s verification    UF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION  Enroll by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_VERIFICATION  Delete after administrator\u2019s verification    UF_INPUT_DELETE_BY_WIEGAND_VERIFICATION  Delete by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_ALL_VERIFICATION  Delete all after administrator\u2019s verification    UF_INPUT_CANCEL  Cancel    UF_INPUT_TAMPER_SWITCH_IN  Tamper switch. When the tamper switch is on, Tamper Switch On(0x64) event occurred. When it gets off, Tamper Switch Off(0x65) event occurred. Both events are recorded in log, too. In BioEntry Smart and Pass, UF_INPUT_PORT2 is assigned to Tamper SW.    UF_INPUT_RESET  Reset the module      Description  UF_RET_CODE   UF_SetInputFunction (   UF_INPUT_PORT   port ,   UF_INPUT_FUNC   inputFunction ,   UINT32   minimumTime   )   Parameters  port \nOne of the three input ports \u2013  UF_INPUT_PORT0 ,  UF_INPUT_PORT1 , and  UF_INPUT_PORT2 . For BioEntry Smart and Pass,  UF_INPUT_PORT2  is assigned to Tamper SW and not configurable.  inputFunction \nInput function.  minimumTime    \nMinimum duration after which the input signal is acknowledged as active.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetInputFunction"
        },
        {
            "location": "/documents/API_Specification/#uf_getinputfunction",
            "text": "Gets the function assigned to an input port.   Description  UF_RET_CODE   UF_GetInputFunction (   UF_INPUT_PORT   port ,   UF_INPUT_FUNC *   inputFunction ,   UINT32 *   minimumTime   )   Parameters  port \nInput port.  inputFunction \nPointer to the input function to be returned.  minimumTime \nPointer to the minimum duration of input signal to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetInputFunction"
        },
        {
            "location": "/documents/API_Specification/#uf_getinputstatus",
            "text": "Gets the status of an input port.   Description  UF_RET_CODE   UF_GetInputStatus (   UF_INPUT_PORT   port ,   BOOL   remainStatus ,   UINT32 *   status   )   Parameters  port \nInput port.  remainStatus \nIf  TRUE , don\u2019t change the status of the input port after reading. If  FALSE , clear the status of the input port.  status \nPointer to the status of the input port to be read. 0 for inactive and 1 for active status.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetInputStatus"
        },
        {
            "location": "/documents/API_Specification/#uf_getoutputeventlist",
            "text": "Gets the list of output events assigned to an output/LED port. Available output events are as follows;     Category  Event      Enroll  UF_OUTPUT_ENROLL_WAIT_WIEGAND     UF_OUTPUT_ENROLL_WAIT_FINGER     UF_OUTPUT_ENROLL_PROCESSING     UF_OUTPUT_ENROLL_BAD_FINGER     UF_OUTPUT_ENROLL_SUCCESS     UF_OUTPUT_ENROLL_FAIL    Verify  UF_OUTPUT_VERIFY_WAIT_WIEGAND     UF_OUTPUT_VERIFY_WAIT_FINGER     UF_OUTPUT_VERIFY_PROCESSING     UF_OUTPUT_VERIFY_BAD_FINGER     UF_OUTPUT_VERIFY_SUCCESS     UF_OUTPUT_VERIFY_FAIL    Identify  UF_OUTPUT_IDENTIFY_WAIT_FINGER     UF_OUTPUT_IDENTIFY_PROCESSING     UF_OUTPUT_IDENTIFY_BAD_FINGER     UF_OUTPUT_IDENTIFY_SUCCESS     UF_OUTPUT_IDENTIFY_FAIL    Delete  UF_OUTPUT_DELETE_WAIT_WIEGAND     UF_OUTPUT_DELETE_WAIT_FINGER     UF_OUTPUT_DELETE_PROCESSING     UF_OUTPUT_DELETE_BAD_FINGER     UF_OUTPUT_DELETE_SUCCESS     UF_OUTPUT_DELETE_FAIL    Detect  UF_OUTPUT_DETECT_INPUT0     UF_OUTPUT_DETECT_INPUT1     UF_OUTPUT_DETECT_INPUT2     UF_OUTPUT_DETECT_WIEGAND     UF_OUTPUT_DETECT_FINGER    End Processing  UF_OUTPUT_END_PROCESSING    Duress  UF_OUTPUT_VERIFY_DURESS     UF_OUTPUT_IDENTIFY_DURESS    Tamper SW  UF_OUTPUT_TAMPER_SWITCH_ON     UF_OUTPUT_TAMPER_SWITCH_OFF    System  UF_OUTPUT_SYS_STARTED    SmartCard (Available only for BioEntry Smart)  UF_OUTPUT_DETECT_SMARTCARD     UF_OUTPUT_BAD_SMARTCARD     UF_OUTPUT_WAIT_SMARTCARD      Description  UF_RET_CODE   UF_GetOutputEventList (   UF_OUTPUT_PORT   port ,   UF_OUTPUT_EVENT *   events ,   int *   numOfEvent   )   Parameters  port \nOutput/LED port.  events \nArray of output events to be returned.  numOfEvent \nPointer to the number of output events to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example  // To read the output events assigned to OUT0  UF_OUTPUT_EVENT   events [ UF_MAX_OUTPUT_PER_PORT ];  int   numOfEvent ;  UF_RET_CODE   result   =   UF_GetOutputEventList (   UF_OUTPUT_PORT0 ,   events ,  & numOfEvent   );",
            "title": "UF_GetOutputEventList"
        },
        {
            "location": "/documents/API_Specification/#uf_clearalloutputevent",
            "text": "Clears all the output events assigned to an output/LED port.   Description  UF_RET_CODE   UF_ClearAllOutputEvent (   UF_OUTPUT_PORT   port   )   Parameters    port \nOutput/LED port.    Return Values   \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#uf_clearoutputevent",
            "text": "Clears the specified output event from the output port.   Description  UF_RET_CODE   UF_ClearOutputEvent (   UF_OUTPUT_PORT   port ,   UF_OUTPUT_EVENT   event   )   Parameters  port \nOutput/LED port.  event \nOutput event to be deleted from the output/LED port.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#uf_setoutputevent",
            "text": "Adds an output event to the specified output/LED port. The characteristics of output signal is also specified.     typedef   struct   {       unsigned   short   delay ;   // t_delay       unsigned   short   count ;   // t_count       unsigned   short   active ;   // t_high       unsigned   short   inactive ;   // t_low  }   UFOutputSignal ;    Description  UF_RET_CODE   UF_SetOutputEvent (   UF_OUTPUT_PORT   port ,   UF_OUTPUT_EVENT   event ,   UFOutputSignal   signal   )   Parameters  port \nOutput/LED port.  event \nOutput event to be added.  signal \nSignal specification of the output event.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example     // To turn on the LED0 for 500ms when verification succeeds,  UFOutputSignal   signal ;  signal . delay   =   0 ;  signal . count   =   1 ;  signal . active   =   500 ;  signal . inactive   =   0 ;  UF_RET_CODE   result   =   UF_SetOutputEvent (   UF_OUTPUT_LED0 ,   UF_OUTPUT_VERIFY_SUCCESS ,   signal   );",
            "title": "UF_SetOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#uf_getoutputevent",
            "text": "Gets the signal data of an output event on the specified output/LED port.   Description  UF_RET_CODE   UF_GetOutputEvent (   UF_OUTPUT_PORT   port ,   UF_OUTPUT_EVENT   event ,   UFOutputSignal *   signal   )   Parameters  port \nOutput/LED port.  event \nOutput event.  signal \nPointer to the signal data to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetOutputEvent"
        },
        {
            "location": "/documents/API_Specification/#uf_setoutputstatus",
            "text": "Sets the status of an output/LED port.   Description  UF_RET_CODE   UF_SetOutputStatus (   UF_OUTPUT_PORT   port ,   BOOL   status   )   Parameters  port \nOutput/LED port.  status \nTRUE for active and FALSE for inactive status.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetOutputStatus"
        },
        {
            "location": "/documents/API_Specification/#uf_setlegacywiegandconfigdeprecated",
            "text": "Until the firmware V1.3, SFM 3500 modules only support 26 bit Wiegand format. Since the firmware V1.4, Extended Wiegand Interface is provided, which is much more powerful and flexible.  UF_SetLegacyWiegandConfig  configures the legacy 26 bit Wiegand format and is provided only for firmwares older than V1.4.   Description  UF_RET_CODE   UF_SetLegacyWiegandConfig (   BOOL   enableInput ,   BOOL   enableOutput ,   UINT32   fcBits ,   UINT32   fcCode   )   Parameters  enableInput \nIf TRUE, the module starts verification process when receiving Wiegand inputs.  enableOutput \nIf TURE, the module outputs the user ID when verification or identification succeeds.  fcBits \nSpecifies the number of facility bits.  fcCode \nSpecifies the facility code.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetLegacyWiegandConfig(Deprecated)"
        },
        {
            "location": "/documents/API_Specification/#uf_getlegacywiegandconfigdeprecated",
            "text": "Gets the configuration of the 26 bit Wiegand format.   Description  UF_RET_CODE   UF_GetLegacyWiegandConfig (   BOOL *   enableInput ,   BOOL *   enableOutput ,   UINT32 *   fcBits ,   UINT32 *   fcCode   )   Parameters  enableInput \nPointer to the input enable status.  enableOutput \nPointer to the output enable status.  fcBits \nPointer to the number of facility bits to be returned.  fcCode \nPointer to the facility code to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetLegacyWiegandConfig(Deprecated)"
        },
        {
            "location": "/documents/API_Specification/#uf_makeioconfiguration",
            "text": "Makes IO configuration data to be saved into a file. See the example of  UF_SaveConfiguration  for the usage of this function.   Description  UF_RET_CODE   UF_MakeIOConfiguration (   UFConfigComponentHeader *   configHeader ,   BYTE *   configData   )   Parameters  configHeader \nPointer to the configuration header to be returned.  configData \nPointer to the configuration data to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_MakeIOConfiguration"
        },
        {
            "location": "/documents/API_Specification/#315-gpio-api-for-sfm3000400050006000",
            "text": "SFM3000 series modules have 8 GPIO ports, which are configurable for specific functions. The function of each GPIO can be read and programmed via these APIs. . GPIO port can be configured as input, output, shared I/O, Wiegand input, or Wiegand output. In the input mode, enroll, identify, and delete functions are supported. In the output mode, the port can send output patterns corresponding to the various events such as match success, enroll fail, and so on.   UF_GetGPIOConfiguration : gets the configuration data of a GPIO port.  UF_SetInputGPIO : configures an input GPIO port.  UF_SetOutputGPIO : configures an output GPIO port.  UF_SetSharedGPIO : configures a shared I/O port.  UF_DisableGPIO : disables a GPIO port.  UF_ClearAllGPIO : clears all the GPIO configurations.  UF_SetDefaultGPIO : resets to default GPIO configurations.  UF_EnableWiegandInput : enables Wiegand input.  UF_EnableWiegandOutput : enables Wiegand output.  UF_DisableWiegandInput : disables Wiegand input.  UF_DisableWiegandOutput : disables Wiegand output.  UF_MakeGPIOConfiguration : makes GPIO configuration data to be saved into a file.",
            "title": "3.15. GPIO API for SFM3000/4000/5000/6000"
        },
        {
            "location": "/documents/API_Specification/#uf_getgpioconfiguration",
            "text": "Gets the configuration data of a GPIO port.   Description  UF_RET_CODE   UF_GetGPIOConfiguration (   UF_GPIO_PORT   port ,   UF_GPIO_MODE *   mode ,   int *   numOfData ,   UFGPIOData *   data   )   Parameters    port \nGPIO port from  UF_GPIO_0  to  UF_GPIO_7 .  mode \nPointer to the GPIO mode to be returned. Available GPIO modes are as follows;       Mode  Description      UF_GPIO_INPUT  Input port    UF_GPIO_OUTPUT  Output port    UF_GPIO_SHARED_IO  Shared IO port    UF_GPIO_WIEGAND_INPUT  Wiegand input port    UF_GPIO_WIEGAND_OUTPUT  Wiegand output port     numOfData \nNumber of configuration data assigned to the port.  data \nArray of GPIO configuration data to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example     // To retrieve the configuration data of GPIO 0  UFGPIOData   configData [ UF_MAX_GPIO_OUTPUT_EVENT ];  UF_GPIO_MODE   mode ;  int   numOfData ;  UF_RET_CODE   result   =   UF_GetGPIOConfiguration (   UF_GPIO_0 ,   & mode ,   & numOfData ,   configData   );",
            "title": "UF_GetGPIOConfiguration"
        },
        {
            "location": "/documents/API_Specification/#uf_setinputgpio",
            "text": "Configures an input GPIO port.   Description  UF_RET_CODE   UF_SetInputGPIO (   UF_GPIO_PORT   port ,   UFGPIOInputData   data   )   Parameters  port \nGPIO port. Only GPIO 0 to GPIO 3 can be an input port.  data  UFGPIOInputData  is defined as follows;    typedef   struct   {       unsigned   short   inputFunction ;   // See UF_GPIO_INPUT_FUNC                                   // in UF_3000IO.h       unsigned   short   activationLevel ;   // See UF_GPIO_INPUT_ACTIVATION                                   // in UF_3000IO.h       unsigned   short   timeout ;   // valid only if inputFUnction is                               // UF_GPIO_IN_DELETE_ALL or                               // UF_GPIO_IN_DELETE_ALL_VERIFICATION       unsigned   short   reserved ;  }   UFGPIOInputData ;   Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example  // To assign identify to GPIO 0 with ACTIVE_HIGH signal  UFGPIOInputData   inputData ;  inputData . inputFunction   =   UF_GPIO_IN_IDENTIFY ;  inputData . activationLevel   =   UF_GPIO_IN_ACTIVE_HIGH ;  UF_RET_CODE   result   =   UF_SetInputGPIO (   UF_GPIO_0 ,   inputData   );",
            "title": "UF_SetInputGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setoutputgpio",
            "text": "Configures an output GPIO port.   Description  UF_RET_CODE   UF_SetOutputGPIO (   UF_GPIO_PORT   port ,   int   numOfData ,   UFGPIOOutputData *   data   )   Parameters  port \nGPIO port.  numOfData \nNumber of UFGPIOOutputData to be assigned to the GPIO port.  data \nArray of UFGPIOOutputData to be assigned to the GPIO port.  UFGPIOOutputData  is defined as follows;    typedef   struct   {       unsigned   short   event ;   // see UF_GPIO_OUTPUT_EVENT                           // in UF_3000IO.h       unsigned   short   level ;   // see UF_GPIO_OUTPUT_LEVEL       unsigned   short   interval ;   // in milliseconds       unsigned   short   blinkingPeriod ;   // valid only if the level is                   // UF_GPIO_OUT_HIGH_BLINK or UF_GPIO_OUT_LOW_BLINK  }   UFGPIOOutputData ;   Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetOutputGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setsharedgpio",
            "text": "Configures the shared I/O GPIO port.   Description  UF_RET_CODE   UF_SetSharedGPIO (   UF_GPIO_PORT   port ,   UFGPIOInputData   inputData ,   int   numOfOutputData ,   UFGPIOOutputData *   outputData   )   Parameters  port \nGPIO port. Only GPIO 0 to GPIO 3 can be a shared I/O port.  inputData \nInput data to be assigned.  numOfOutputData \nNumber of UFGPIOOutputData to be assigned.  outputData \nArray of UFGPIOOutputData to be assigned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetSharedGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_disablegpio",
            "text": "Disables a GPIO port.   Description  UF_RET_CODE   UF_DisableGPIO (   UF_GPIO_PORT   port   )   Parameters  port \nGPIO port.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DisableGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_clearallgpio",
            "text": "Clears all the configurations of GPIO ports.   Description  UF_RET_CODE   UF_ClearAllGPIO ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setdefaultgpio",
            "text": "Resets the configurations of GPIO ports to default.   Description  UF_RET_CODE   UF_SetDefaultGPIO ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetDefaultGPIO"
        },
        {
            "location": "/documents/API_Specification/#uf_enablewiegandinput",
            "text": "Enables Wiegand input. Wiegand input uses GPIO 2 and GPIO 3 as input signal.   Description  UF_RET_CODE   UF_EnableWiegandInput (   UFGPIOWiegandData   data   )   Parameters  data  UFGPIOWiegandData  is defined as follows;    typedef   struct   {       unsigned   short   totalBits ;   // fixed at 26 bit       unsigned   short   fcBits ;   // number of facility bits       unsigned   short   idBits ;   // number of id bits       unsigned   short   fcCode ;   // facility code  }   UFGPIOWiegandData ;   Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_EnableWiegandInput"
        },
        {
            "location": "/documents/API_Specification/#uf_enablewiegandoutput",
            "text": "Enables Wiegand output. Wiegand output use GPIO 4 and GPIO 5 as output signal.   Description  UF_RET_CODE   UF_EnableWiegandOutput (   UFGPIOWiegandData   data   )   Parameters  data \nWiegand configuration data.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_EnableWiegandOutput"
        },
        {
            "location": "/documents/API_Specification/#uf_disablewiegandinput",
            "text": "Disables Wiegand input.   Description  UF_RET_CODE   UF_DisableWiegandInput ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DisableWiegandInput"
        },
        {
            "location": "/documents/API_Specification/#uf_disablewiegandoutput",
            "text": "Disables Wiegand output.   Description  UF_RET_CODE   UF_DisableWiegandOutput ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DisableWiegandOutput"
        },
        {
            "location": "/documents/API_Specification/#uf_makegpioconfiguration",
            "text": "Makes GPIO configuration data to be saved into a file.   Description  UF_RET_CODE   UF_MakeGPIOConfiguration (   UFConfigComponentHeader *   configHeader ,   BYTE *   configData   )   Parameters  configHeader \nPointer to the configuration header.  configData \nPointer to the configuration data.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example \nSee CUniFingerUI3000IOView::OnGpioSaveFile in UniFingerUI source codes.",
            "title": "UF_MakeGPIOConfiguration"
        },
        {
            "location": "/documents/API_Specification/#316-user-memory-api",
            "text": "SFM modules reserve 256 bytes for user data. This area can be read and written by these APIs.\n-  UF_WriteUserMemory : writes data to the user memory.\n-  UF_ReadUserMemory : reads the contents of the user memory.",
            "title": "3.16. User Memory API"
        },
        {
            "location": "/documents/API_Specification/#uf_writeusermemory",
            "text": "Writes data into the user memory.   Description  UF_RET_CODE   UF_WriteUserMemory (   BYTE *   memory   )   Parameters  memory \nPointer to the 256 byte array to be written.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_WriteUserMemory"
        },
        {
            "location": "/documents/API_Specification/#uf_readusermemory",
            "text": "Reads the contents of the user memory.   Description  UF_RET_CODE   UF_ReadUserMemory (   BYTE *   memory   )   Parameters  memory \nPointer to the 256 byte array to be read.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadUserMemory"
        },
        {
            "location": "/documents/API_Specification/#317-log-management-api",
            "text": "SFM3500 modules provide logging facility for recording important events. Users can receive logs from the module and delete unwanted ones. The format of a log record is as follows;     Item  Description  Size      Source  UF_LOG_SOURCE_HOST_PORT  1 byte     UF_LOG_SOURCE_AUX_PORT      UF_LOG_SOURCE_WIEGAND_INPUT      UF_LOG_SOURCE_IN0      UF_LOG_SOURCE_IN1      UF_LOG_SOURCE_IN2      UF_LOG_SOURCE_FREESCAN      UF_LOG_SOURCE_SMARTCARD     Event ID  One of the UF_OUTPUT_EVENT  1 byte    Date  (DD << 16) / (MM << 8) / YY  3 bytes    Time  (ss << 16) / (mm << 8) / hh  3 bytes    User ID  User ID  4 bytes    Custom Field  Customizable by user  4 bytes     In V1.6 firmware, there are two enhancements for logging functions. First, 4 byte custom field is added to log records. Making use of this field, users can add customized events to log records. Second, the log cache is added for real-time monitoring.   UF_SetTime : sets the time of the module.  UF_GetTime : gets the time of the module.  UF_GetNumOfLog : gets the number of log records.  UF_ReadLog : reads log records.  UF_ReadLatestLog : reads latest log records.  UF_DeleteOldestLog : deletes oldest log records.  UF_DeleteAllLog : deletes all the log records.  UF_ClearLogCache : clears the log cache.  UF_ReadLogCache : reads the log records in the cache.  UF_SetCustomLogField : sets the custom field of log records.  UF_GetCustomLogField : gets the custom field of log records.",
            "title": "3.17. Log Management API"
        },
        {
            "location": "/documents/API_Specification/#uf_settime",
            "text": "Sets the time of the module.   Description  UF_RET_CODE   UF_SetTime (   time_t   timeVal   )   Parameters  timeVal \nNumber of seconds elapsed since midnight (00:00:00), January 1, 1970.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetTime"
        },
        {
            "location": "/documents/API_Specification/#uf_gettime",
            "text": "Gets the time of the module.   Description  UF_RET_CODE   UF_GetTime (   time_t *   timeVal   )   Parameters  timeVal \nPointer to the time value to be returned by the module.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetTime"
        },
        {
            "location": "/documents/API_Specification/#uf_getnumoflog",
            "text": "Retrieves the number of log records.   Description  UF_RET_CODE   UF_GetNumOfLog (   int *   numOfLog ,   int *   numOfTotalLog   )   Parameters  numOfLog \nPointer to the number of log records to be returned.  numOfTotalLog \nPointer to the maximum log records to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetNumOfLog"
        },
        {
            "location": "/documents/API_Specification/#uf_readlog",
            "text": "Reads log records.   Description  UF_RET_CODE   UF_ReadLog (   int   startIndex ,   int   count ,   UFLogRecord *   logRecord ,   int *   readCount   )   Parameters  startIndex \nStart index of log records to be read.  count \nNumber of log records to be read.  logRecord \nPointer to the log records to be read.  readCount \nPointer to the number of log records actually read.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadLog"
        },
        {
            "location": "/documents/API_Specification/#uf_readlatestlog",
            "text": "Reads latest log records.   Description  UF_RET_CODE   UF_ReadLatestLog (   int   count ,   UFLogRecord *   logRecord ,   int *   readCount   )   Parameters  count \nNumber of latest log records to be read.  logRecord \nPointer to the log records to be read.  readCount \nPointer to the number of log records actually read.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadLatestLog"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteoldestlog",
            "text": "Deletes oldest log records.   Description  UF_RET_CODE   UF_DeleteOldestLog (   int   count ,   int *   deletedCount   )   Parameters  count \nNumber of oldest log records to be deleted. It should be a multiple of 256.  deletedCount \nPointer to the number of log records actually deleted.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteOldestLog"
        },
        {
            "location": "/documents/API_Specification/#uf_deletealllog",
            "text": "Deletes all the log records.   Description  UF_RET_CODE   UF_DeleteAllLog ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllLog"
        },
        {
            "location": "/documents/API_Specification/#uf_clearlogcache",
            "text": "Clears the log cache.   Description  UF_RET_CODE   UF_ClearLogCache ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearLogCache"
        },
        {
            "location": "/documents/API_Specification/#uf_readlogcache",
            "text": "Reads the log records in the cache. After reading, the cache will be cleared. The maximum number of log records in the cache is 256.   Description  UF_RET_CODE   UF_ReadLogCache (   int   dataPacketSize ,   int *   numOfLog ,   UFLogRecord *   logRecord   )   Parameters  dataPacketSize \nData packet size used in Extended Data Transfer protocol.  numOfLog \nPointer to the number of log records to be returned.  logRecord \nPointer to the log records to be returned. This pointer should be preallocated large enough to store the log records.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadLogCache"
        },
        {
            "location": "/documents/API_Specification/#uf_setcustomlogfield",
            "text": "There is a 4 byte reserved field in each log record. This function is used for setting this custom value. If the custom field is not set, it will be filled with NULL.   Description  UF_RET_CODE   UF_SetCustomLogField (   UF_LOG_SOURCE   source ,   unsigned   customField   )   Parameters  source \nUsers can set 4 different custom values according to the source of log records.       Source  Description      UF_LOG_SOURCE_OTHER  If the log is generated by Packet Protocol commands or freescan, this value will be used.    UF_LOG_SOURCE_IN0     UF_LOG_SOURCE_IN1     UF_LOG_SOURCE_IN2  If the log is generated by an Input port, the respective values will be used.     customField \n4 byte custom value.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetCustomLogField"
        },
        {
            "location": "/documents/API_Specification/#uf_getcustomlogfield",
            "text": "Reads the custom value of the specified log source.   Description  UF_RET_CODE   UF_GetCustomLogField (   UF_LOG_SOURCE   source ,   unsigned *   customField   )   Parameters     source \nLog source.  customField \nPointer to the 4 byte custom value to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetCustomLogField"
        },
        {
            "location": "/documents/API_Specification/#318-extended-wiegand-api",
            "text": "Extended Wiegand Interface supports up to 64 bit Wiegand formats. The only constraint is that the ID field is limited to 32 bits. It also supports advanced options such as Fail ID and Inverse Parity on Fail.   UF_SetWiegandFormat : configures the Wiegand format.  UF_GetWiegandFormat : gets the Wiegand format information.  UF_SetWiegandIO : configures the Wiegand IO ports.  UF_GetWiegandIO : gets the configurations of the Wiegand IO ports.  UF_SetWiegandOption : sets the advanced options.  UF_GetWiegandOption : gets the advanced options.  UF_SetAltValue : sets the alternative value of a field.  UF_ClearAltValue : clears the alternative value of a field.  UF_GetAltValue : gets the alternative value of a field.  UF_MakeWiegandConfiguration : makes Wiegand configuration data to be saved into a file.",
            "title": "3.18. Extended Wiegand API"
        },
        {
            "location": "/documents/API_Specification/#uf_setwiegandformat",
            "text": "Configures the Wiegand format.   Description  UF_RET_CODE   UF_SetWiegandFormat (   UFWiegandFormatHeader *   header ,   UFWiegandFormatData *   data ,   int   pulseWidth ,   int   pulseInterval   )   Parameters  header \nUFWiegandFormatHeader is defined as follows;    typedef   struct   {       UF_WIEGAND_FORMAT   format ;   // UF_WIEGAND_26BIT,                               // UF_WIEGAND_PASS_THRU,                               // UF_WIEGAND_CUSTOM       int               totalBits ;  }   UFWiegandFormatHeader ;   data \nWiegand format data. If the format is UF_WIEGAND_26BIT, there is no format data and this parameter will be ignored. UFWiegandFormatData is defined as follows;    typedef   struct   {       int                  numOfIDField ;       UFWiegandField       field [ MAX_WIEGAND_FIELD ];  }   UFWiegandPassThruData ;  typedef   struct   {       int                  numOfField ;       UINT32               idFieldMask ;       UFWiegandField       field [ MAX_WIEGAND_FIELD ];       int                  numOfParity ;       UFWiegandParity      parity [ MAX_WIEGAND_PARITY ];  }   UFWiegandCustomData ;  typedef   union   {       UFWiegandPassThruData     passThruData ;       UFWiegandCustomData       customData ;  }   UFWiegandFormatData ;   pulseWidth \nSpecifies the width of Wiegand signal.  pulseInterval \nSpecifies the interval of Wiegand signal.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetWiegandFormat"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandformat",
            "text": "Gets the Wiegand format data.   Description  UF_RET_CODE   UF_GetWiegandFormat (   UFWiegandFormatHeader *   header ,   UFWiegandFormatData *   data ,   int *   pulseWidth ,   int *   pulseInterval   )   Parameters  header \nPointer to the format header to be returned.  data \nPointer to the format data to be returned.  pulseWidth \nPointer to the width of Wiegand signal.  pulseInterval \nPointer to the interval of Wiegand signal.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandFormat"
        },
        {
            "location": "/documents/API_Specification/#uf_setwiegandio",
            "text": "Configures the Wiegand IO ports.   Description  UF_RET_CODE   UF_SetWiegandIO (   UF_WIEGAND_INPUT_MODE   inputMode ,   UF_WIEGAND_OUTPUT_MODE   outputMode ,   int   numOfChar   )   Parameters  inputMode         Mode  Description      UF_WIEGAND_INPUT_DISABLE  Ignores Wiegand inputs.    UF_WIEGAND_INPUT_VERIFY  Starts verification after receiving Wiegand inputs.     outputMode         Mode  Description      UF_WIEGAND_OUTPUT_DISABLE  Disables Wiegand output.    UF_WIEGAND_OUTPUT_WIEGAND_ONLY  Outputs Wiegand signal only if the verification is initiated by Wiegand input.    UF_WIEGAND_OUTPUT_ALL  Outputs Wiegand signal if matching succeeds.    UF_WIEGAND_OUTPUT_ABA_TRACK_II  Outputs ABA Track II characters instead of Wiegand signal.     numOfChar \nNumber of characters in ABA Track II output format. It is ignored if outputMode is not  UF_WIEGAND_OUTPUT_ABA_TRACK_II .  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetWiegandIO"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandio",
            "text": "Gets the configurations of Wiegand IO ports.   Description  UF_RET_CODE   UF_GetWiegandIO (   UF_WIEGAND_INPUT_MODE *   inputMode ,   UF_WIEGAND_OUTPUT_MODE *   outputMode ,   int *   numOfChar   )   Parameters  inputMode \nPointer to Wiegand input mode to be returned.  outputMode \nPointer to Wiegand output mode to be returned.  numOfChar \nPointer to the number of characters in ABA Track II output format. It is ignored if outputMode is not  UF_WIEGAND_OUTPUT_ABA_TRACK_II .  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandIO"
        },
        {
            "location": "/documents/API_Specification/#uf_setwiegandoption",
            "text": "Sets advanced options.   Description  UF_RET_CODE   UF_SetWiegandOption (   BOOL   useFailID ,   UINT32   failID ,   BOOL   inverseParityOnFail   )   Parameters  useFailID \nNormally the module outputs Wiegand signal only if matching succeeds. If this option is TRUE, the module outputs the fail ID when matching fails.  failID \nID to be output if useFailID is  TRUE .  inverseParityOnFail \nIf this option is  TRUE , the module outputs Wiegand signals with inverted parities when matching fails.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetWiegandOption"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandoption",
            "text": "Gets the advanced options.   Description  UF_RET_CODE   UF_GetWiegandOption (   BOOL *   useFailID ,   UINT32 *   failID ,   BOOL *   inverseParityOnFail   )   Parameters  userFailID \nPointer to the useFailID option to be returned.  failID \nPointer to the fail ID to be returned.  inverseParityOnFail \nPointer to the inverseParityOnFail option to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandOption"
        },
        {
            "location": "/documents/API_Specification/#uf_setaltvalue",
            "text": "If the Wiegand format is UF_WIEGAND_26BIT or UF_WIEGAND_CUSTOM, users can set alternative values for non-ID fields. If an alternative value is set for a non-ID field, the module will replace the field with the alternative value before outputting the signal.   Description  UF_RET_CODE   UF_SetAltValue (   int   fieldIndex ,   UINT32   value   )   Parameters  fieldIndex \nIndex of the field.  value \nAlternative value of the field.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetAltValue"
        },
        {
            "location": "/documents/API_Specification/#uf_clearaltvalue",
            "text": "Clears the alternative value of a field.   Description  UF_RET_CODE   UF_ClearAltValue (   int   fieldIndex   )   Parameters  fieldIndex \nIndex of the field.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearAltValue"
        },
        {
            "location": "/documents/API_Specification/#uf_getaltvalue",
            "text": "Gets the alternative value of a field.   Description  UF_RET_CODE   UF_GetAltValue (   int   fieldIndex ,   UINT32 *   value   )   Parameters  fieldIndex \nIndex of the field.  value \nAlternative value of the field to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . If alternative value is not set to the field, return  UF_ERR_NOT_FOUND . Otherwise, return the corresponding error code.",
            "title": "UF_GetAltValue"
        },
        {
            "location": "/documents/API_Specification/#uf_makewiegandconfiguration",
            "text": "Makes Wiegand configuration data to be saved into a file.   Description  UF_RET_CODE   UF_MakeWiegandConfiguration (   UFConfigComponentHeader *   configHeader ,   BYTE *   configData   )   Parameters  configHeader \nPointer to the configuration header to be returned.  configData \nPointer to the configuration data to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.    Example \nSee CUniFingerUIWiegandView::OnWiegandSaveFile in UniFingerUI source codes.",
            "title": "UF_MakeWiegandConfiguration"
        },
        {
            "location": "/documents/API_Specification/#319-wiegand-command-card-api",
            "text": "Users can map an input function to a Wiegand ID. When the module detects the mapped IDs in Wiegand input port, it will execute the corresponding input function.   UF_AddWiegandCommandCard : adds a mapping of input function to the specified ID.  UF_GetWiegandCommandCardList : gets all the mapping data.  UF_ClearAllWiegandCommandCard : clears all the mappings.",
            "title": "3.19. Wiegand Command Card API"
        },
        {
            "location": "/documents/API_Specification/#uf_addwiegandcommandcard",
            "text": "Maps the input function to the specified ID.   Description  UF_RET_CODE   UF_AddWiegandCommandCard (   UINT32   userID ,   UF_INPUT_FUNC   function   )   Parameters  userID \nUser ID.  function \nAmong the input functions, the followings can be assigned to command cards.       Function  Description      UF_INPUT_ENROLL  Enroll    UF_INPUT_IDENTIFY  Identify    UF_INPUT_DELETE  Delete    UF_INPUT_DELETE_ALL  Delete all    UF_INPUT_ENROLL_BY_WIEGAND  Enroll by Wiegand ID    UF_INPUT_DELETE_BY_WIEGAND  Delete by Wiegand ID    UF_INPUT_ENROLL_VERIFICATION  Enroll after administrator\u2019s verification    UF_INPUT_ENROLL_BY_WIEGAND_VERIFICATION  Enroll by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_VERIFICATION  Delete after administrator\u2019s verification    UF_INPUT_DELETE_BY_WIEGAND_VERIFICATION  Delete by Wiegand ID after administrator\u2019s verification    UF_INPUT_DELETE_ALL_VERIFICATION  Delete all after administrator\u2019s verification     Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_AddWiegandCommandCard"
        },
        {
            "location": "/documents/API_Specification/#uf_getwiegandcommandcardlist",
            "text": "Gets the list of all the command cards.   Description  UF_RET_CODE   UF_GetWiegandCommandCardList (   int *   numOfCard ,   UFWiegandCommandCard *   commandCard   )   Parameters  numOfCard \nNumber of command cards to be returned.  commandCard \nArray of command card information to be returned. UFWiegandCommandCard is defined as follows;    typedef   struct   {       UINT32            userID ;       UF_INPUT_FUNC     function ;  }   UFWiegandCommandCard ;   Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetWiegandCommandCardList"
        },
        {
            "location": "/documents/API_Specification/#uf_clearallwiegandcommandcard",
            "text": "Clears all the command card mappings.   Description  UF_RET_CODE   UF_ClearAllWiegandCommandCard ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ClearAllWiegandCommandCard"
        },
        {
            "location": "/documents/API_Specification/#320-smartcard-api",
            "text": "BioEntry Smart readers support MIFARE types of smartcards. These functions provide basic functionalities such as read, write, and format smartcards.   UF_ReadSmartCard : reads a smartcard.  UF_ReadSmartCardWithAG : reads a smartcard with access group information.  UF_WriteSmartCard : writes templates into a smartcard.  UF_WriteSmartCardWithAG : writes templates and access group information into a smartcard.  UF_WriteSmartCardWithEntranceLimit : writes templates, access group information, and entrance limit into a smartcard.  UF_FormatSmartCard : formats a smartcard.  UF_SetSmartCardMode : sets the operation mode.  UF_GetSmartCardMode : gets the operation mode.  UF_ChangePrimaryKey : changes the primary key.  UF_ChangeSecondaryKey : changes the secondary key.  UF_SetKeyOption : sets the site key options.  UF_GetKeyOption : gets the site key options.  UF_SetCardLayout : sets the layout of smartcard.  UF_GetCardLayout : gets the layout of smartcard.  UF_SetSmartCardCallback : sets the callback function for smartcard operation.",
            "title": "3.20. SmartCard API"
        },
        {
            "location": "/documents/API_Specification/#uf_readsmartcard",
            "text": "Reads a smart card.   Description  UF_RET_CODE   UF_ReadSmartCard (   UFCardHeader *   header ,   BYTE *   template1 ,   BYTE *   template2   )   Parameters  header  UFCardHeader  is defined as follows;    typedef   struct   {       UINT32   csn ;   // 4 byte card serial number       UINT32   wiegandLower ;   // lower 4 bytes of Wiegand string       UINT32   wiegandHigher ; // higher 4 bytes of Wiegand string       BYTE   version ;       BYTE   commandType ;   // reserved for command cards. In V1.7 or                   // later firmware, this field is used for                   // storing entrance limit for non-command cards.       BYTE   securityLevel ;   // security level of the user       BYTE   numOfTemplate ;   // number of templates stored                           // in the card       BYTE   template1Duress ;   // 1 if the template1 is                           // of duress finger       BYTE   template1Length [ 2 ];   // length of template1       BYTE   template2Duress ;       BYTE   template2Length [ 2 ];  }   UFCardHeader ;   template1 \nPointer to the first template data read from the smartcard.  template2 \nPointer to the second template data read from the smartcard.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadSmartCard"
        },
        {
            "location": "/documents/API_Specification/#uf_readsmartcardwithag",
            "text": "Reads a smart card with access group information. As for access group, see  UF_AddAccessGroup .   Description  UF_RET_CODE   UF_ReadSmartCardWithAG (   UFCardHeader *   header ,   BYTE *   template1 ,   BYTE *   template2 ,   int *   numOfAccessGroup ,   BYTE *   accessGroup   )   Parameters  header \nPointer to the UFCardHeader to be returned.  template1 \nPointer to the first template data read from the smartcard.  template2 \nPointer to the second template data read from the smartcard.  numOfAccessGroup \nPointer to the number of access groups assigned to the smartcard.  accessGroup \nPointer to the IDs of access groups assigned to the smartcard. The length of each ID is 1 byte.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadSmartCardWithAG"
        },
        {
            "location": "/documents/API_Specification/#uf_writesmartcard",
            "text": "Writes template data and header information into a smartcard.   Description  UF_RET_CODE   UF_WriteSmartCard (   UINT32   userID ,   UF_CARD_SECURITY_LEVEL   securityLevel ,   int   numOfTemplate ,   int   templateSize ,   BYTE *   template1 ,   BOOL   duress1 ,   BYTE *   template2 ,   BOOL   duress2   )   Parameters  userID \nUser ID.  securityLevel \nSecurity level. If it is set to  UF_SECURITY_READER_DEFAULT , the security level is same as defined in the BioEntry reader. If it is set to  UF_SECURITY_BYPASS , the BioEntry reader will bypass the fingerprint authentication.  numOfTemplate \nNumber of templates to be written.  templateSize \nSize of a template.  template1 \nPointer to the first template data.  duress1 \nSpecifies if the first template is of a duress finger.  template2 \nPointer to the second template data.  duress2 \nSpecifies if the second template is of a duress finger.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_WriteSmartCard"
        },
        {
            "location": "/documents/API_Specification/#uf_writesmartcardwithag",
            "text": "Writes template data and access group information into a smartcard.   Description  UF_RET_CODE   UF_WriteSmartCardWithAG (   UINT32   userID ,   UF_CARD_SECURITY_LEVEL   securityLevel ,   int   numOfTemplate ,   int   templateSize ,   BYTE *   template1 ,   BOOL   duress1 ,   BYTE *   template2 ,   BOOL   duress2 ,   int   numOfAccessGroup ,   BYTE *   accessGroup   )   Parameters  userID \nUser ID.  securityLevel \nSecurity level. If it is set to  UF_SECURITY_READER_DEFAULT , the security level is same as defined in the BioEntry reader. If it is set to  UF_SECURITY_BYPASS , the BioEntry reader will bypass the fingerprint authentication.  numOfTemplate \nNumber of templates to be written.  templateSize \nSize of a template.  template1 \nPointer to the first template data.  duress1 \nSpecifies if the first template is of a duress finger.  template2 \nPointer to the second template data.  duress2 \nSpecifies if the second template is of a duress finger.  numOfAccessGroup \nNumber of access groups assigned to the smartcard.  accessGroup \nPointer to the IDs of access group to be written.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_WriteSmartCardWithAG"
        },
        {
            "location": "/documents/API_Specification/#uf_writesmartcardwithentrancelimit",
            "text": "Writes template data, access group, and entrance limit information into a smartcard.   Description  UF_RET_CODE   UF_WriteSmartCardWithEntranceLimit (   UINT32   userID ,   UF_CARD_SECURITY_LEVEL   securityLevel ,   int   entranceLimit ,   int   numOfTemplate ,   int   templateSize ,   BYTE *   template1 ,   BOOL   duress1 ,   BYTE *   template2 ,   BOOL   duress2 ,   int   numOfAccessGroup ,   BYTE *   accessGroup   )   Parameters  userID \nUser ID.  securityLevel \nSecurity level. If it is set to  UF_SECURITY_READER_DEFAULT , the security level is same as defined in the BioEntry reader. If it is set to  UF_SECURITY_BYPASS , the BioEntry reader will bypass the fingerprint authentication. entranceLimit \nEntrance limit between 0 and 7.  numOfTemplate \nNumber of templates to be written.  templateSize \nSize of a template.  template1 \nPointer to the first template data.  duress1 \nSpecifies if the first template is of a duress finger.  template2 \nPointer to the second template data.  duress2 \nSpecifies if the second template is of a duress finger.  numOfAccessGroup \nNumber of access groups assigned to the smartcard.  accessGroup \nPointer to the IDs of access group to be written.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_WriteSmartCardWithEntranceLimit"
        },
        {
            "location": "/documents/API_Specification/#uf_formatsmartcard",
            "text": "Formats a smartcard.   Description  UF_RET_CODE   UF_FormatSmartCard (   BOOL   templateOnly   )   Parameters  templateOnly \nIf  TRUE , erases only the template area and don\u2019t change the header \ninformation. If  FALSE , erase the header information, too.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_FormatSmartCard"
        },
        {
            "location": "/documents/API_Specification/#uf_setsmartcardmode",
            "text": "Sets the operation mode of the BioEntry Smart reader.   Description  UF_RET_CODE   UF_SetSmartCardMode (   UF_CARD_MODE   mode   )   Parameters  mode \nOperation mode.       Mode  Description      UF_CARD_DISABLE  Disables the smartcard operation.    UF_CARD_VERIFY_ID  After detecting a smartcard, verifies the fingerprint input with the templates stored in the BioEntry reader.    UF_CARD_VERIFY_TEMPLATE  After detecting a smartcard, verifies the fingerprint input with the templates stored in the card.     Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetSmartCardMode"
        },
        {
            "location": "/documents/API_Specification/#uf_getsmartcardmode",
            "text": "Gets the operation mode.   Description  UF_RET_CODE   UF_GetSmartCardMode (   UF_CARD_MODE *   mode   )   Parameters  mode \nPointer to the operation mode to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetSmartCardMode"
        },
        {
            "location": "/documents/API_Specification/#uf_changeprimarykey",
            "text": "To prevent illegal access, MIFARE card is encrypted using 48bit site key. The site key should be handled with utmost caution. If it is disclosed, the data on the smartcard will not be secure any more.  UF_ChangePrimaryKey  is used to change the primary site key.   Description  UF_RET_CODE   UF_ChangePrimaryKey (   BYTE *   oldPrimaryKey ,   BYTE *   newPrimaryKey   )   Parameters  oldPrimaryKey \nPointer to the old site key.  newPrimaryKey \nPointer to the new site key.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ChangePrimaryKey"
        },
        {
            "location": "/documents/API_Specification/#uf_changesecondarykey",
            "text": "Changes the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by  UF_SetKeyOption .   Description  UF_RET_CODE   UF_ChangeSecondaryKey (   BYTE *   primaryKey ,   BYTE *   newSecondaryKey   )   Parameters  primaryKey \nPointer to the primary key.  newSecondaryKey \nPointer to the new secondary key.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ChangeSecondaryKey"
        },
        {
            "location": "/documents/API_Specification/#uf_changesecondarykey_1",
            "text": "Changes the secondary site key. The secondary site key is used only when the useSecondaryKey option is set by  UF_SetKeyOption .   Description  UF_RET_CODE   UF_ChangeSecondaryKey (   BYTE *   primaryKey ,   BYTE *   newSecondaryKey   )   Parameters  primaryKey \nPointer to the primary key.  newSecondaryKey \nPointer to the new secondary key.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ChangeSecondaryKey"
        },
        {
            "location": "/documents/API_Specification/#uf_setkeyoption",
            "text": "When changing the site key, BioEntry readers have to handle cards with new site key and cards with old site key at the same time. In that case, useSecondaryKey option can be used. If the secondary key is set to old site key, the reader will handle both types of cards. If autoUpdate option is on, the reader automatically replaces the old site key with new one whenever detecting a smartcard with old key.   Description  UF_RET_CODE   UF_SetKeyOption (   BYTE *   primaryKey ,   BOOL   useSecondaryKey ,   BOOL   autoUpdate   )   Parameters  primaryKey \nPointer to the primary key.  useSecondaryKey \nIf TRUE, process the cards encrypted with the secondary key.  autoUpdate \nIf TRUE, replace the secondary key with primary key when detecting a smartcard encrypted with the secondary key.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetKeyOption"
        },
        {
            "location": "/documents/API_Specification/#uf_getkeyoption",
            "text": "Gets the site key options.   Description  UF_RET_CODE   UF_GetKeyOption (   BOOL *   useSecondaryKey ,   BOOL *   autoUpdate   )   Parameters  useSecondaryKey \nPointer to userSecondaryKey option.  autoUpdate \nPointer to autoUpdate option.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetKeyOption"
        },
        {
            "location": "/documents/API_Specification/#uf_setcardlayout",
            "text": "Changes the layout of the smartcard. By default, a smartcard stores two fingerprint templates. If there are not sufficient spaces on the card, or some blocks of it are reserved for other data, users can change the layout using this function. Changing card layout should be handled with utmost caution. If you aren\u2019t sure what to do, contact to  support@supremainc.com  first before trying yourself.   Description  UF_RET_CODE   UF_SetCardLayout (   UFCardLayout *   layout   )   Parameters  layout \nPointer to the layout information.  UFCardLayout  is defined as follows;    typedef   struct   {       unsigned   short      templateSize ;       BYTE                headerBlock ;       BYTE                template1StartBlock ;       BYTE                template1BlockSize ;       BYTE                template2StartBlock ;       BYTE                template2BlockSize ;  }   UFCardLayout ;   Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetCardLayout"
        },
        {
            "location": "/documents/API_Specification/#uf_getcardlayout",
            "text": "Gets the card layout information.   Description  UF_RET_CODE   UF_GetCardLayout (   UFCardLayout *   layout   )   Parameters  layout \nPointer to  UFCardLayout .  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetCardLayout"
        },
        {
            "location": "/documents/API_Specification/#uf_setsmartcardcallback",
            "text": "Sets the callback function for smartcard operation. This callback is called after scanning a smartcard successfully.   Description  void   UF_SetSmartCardCallback (   void   ( * callback )(   BYTE   )   )   Parameters  callback \nPointer to the callback function.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetSmartCardCallback"
        },
        {
            "location": "/documents/API_Specification/#321-access-control-api",
            "text": "Since V1.6 firmware, BioEntry readers provide access control features such as time schedule and access group. By using these functions, user\u2019s access can be controlled in finer detail.   UF_AddTimeSchedule : adds a time schedule.  UF_GetTimeSchedule : reads the specified time schedule.  UF_DeleteTimeSchedule : deletes a time schedule.  UF_DeleteAllTimeSchedule : deletes all time schedules.  UF_AddHoliday : adds a holiday schedule.  UF_GetHoliday : reads the specified holiday schedule.  UF_DeleteHoliday : deletes a holiday schedule.  UF_DeleteAllHoliday : deletes all holiday schedules.  UF_AddAccessGroup : adds an access group.  UF_GetAccessGroup : reads the specified access group.  UF_DeleteAccessGroup : deletes an access group.  UF_DeleteAllAccessGroup : deletes all access groups.  UF_SetUserAccessGroup : assigns access groups to a user.  UF_GetUserAccessGroup : gets the access groups of a user.",
            "title": "3.21. Access Control API"
        },
        {
            "location": "/documents/API_Specification/#uf_addtimeschedule",
            "text": "A BioEntry reader can store up to 64 time schedules. Each time schedule consists of 7 daily schedules and an optional holiday schedule. And each daily schedule may have up to 5 time segments.  #define UF_TIMECODE_PER_DAY       5  typedef   struct   {       unsigned   short   startTime ;   // start time in minutes       unsigned   short   endTime ;   // end time in minutes  }   UFTimeCodeElem ;  typedef   struct   {       UFTimeCodeElem   codeElement [ UF_TIMECODE_PER_DAY ];  }   UFTimeCode ;  typedef   struct   {       int   scheduleID ;       UFTimeCode   timeCode [ 7 ];   // 0 - Sunday, 1 - Monday, ...       int   holidayID ;  }   UFTimeSchedule ;    Description  UF_RET_CODE   UF_AddTimeSchedule (   UFTimeSchedule *   schedule   )   Parameters  schedule \nPointer to the time schedule to be added.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example     UFTimeSchedule   timeSchedule ;  memset (   & timeSchedule ,   0 ,   sizeof ( UFTimeSchedule )   );   // clear the structure  timeSchedule . scheduleID   =   1 ;  timeSchedule . holidayID   =   1 ;  // Monday- 09:00 ~ 18:00  timeSchedule . timeCode [ 1 ]. codeElement [ 0 ]. startTime   =   9   *   60 ;  timeSchedule . timeCode [ 1 ]. codeElement [ 0 ]. endTime   =   18   *   60 ;  // Tuesday- 08:00 ~ 12:00 and 14:30 ~ 20:00  timeSchedule . timeCode [ 2 ]. codeElement [ 0 ]. startTime   =   8   *   60 ;  timeSchedule . timeCode [ 2 ]. codeElement [ 0 ]. endTime   =   12   *   60 ;  timeSchedule . timeCode [ 2 ]. codeElement [ 1 ]. startTime   =   14   *   60   +   30 ;  timeSchedule . timeCode [ 2 ]. codeElement [ 1 ]. endTime   =   20   *   60 ;  // \u2026  UF_RET_CODE   result   =   UF_AddTimeSchedule (   & timeSchedule   );",
            "title": "UF_AddTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#uf_gettimeschedule",
            "text": "Reads the specified time schedule.   Description  UF_RET_CODE   UF_GetTimeSchedule (   int   ID ,   UFTimeSchedule *   schedule   )   Parameters  ID \nID of the time schedule.  schedule \nPointer to the time schedule to be read.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#uf_deletetimeschedule",
            "text": "Deletes the specified time schedule.   Description  UF_RET_CODE   UF_DeleteTimeSchedule (   int   ID   )   Parameters  ID \nID of the time schedule.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#uf_deletealltimeschedule",
            "text": "Deletes all the time schedules stored in a BioEntry reader.   Description  UF_RET_CODE   UF_DeleteAllTimeSchedule ()   Parameters \nNone  Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllTimeSchedule"
        },
        {
            "location": "/documents/API_Specification/#uf_addholiday",
            "text": "Each time schedule may have an optional holiday schedule. A holiday schedule consists of a holiday list and a daily schedule for it.  typedef   struct   {       int   holidayID ;       int   numOfHoliday ;       unsigned   short   holiday [ 32 ];   // (month << 8) | day       UFTimeCode   timeCode ;  }   UFHoliday ;    Description  UF_RET_CODE   UF_AddHoliday (   UFHoliday *   holiday   )   Parameters  holiday \nPointer to the holiday schedule to be added.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.  Example     UFHoliday   holiday ;  memset (   & holiday ,   0 ,   sizeof ( UFHoliday )   );   // clear the structure  holiday . holidayID   =   1 ;  holiday . numOfHoliday   =   10 ;  // Jan. 1 is holiday  holiday . holiday [ 0 ]   =   ( 1   <<   8 )   |   1 ;  // Mar. 5 is holiday  holiday . holiday [ 1 ]   =   ( 3   <<   8 )   |   5 ;  // \u2026  // Access is granted during 09:00 ~ 10:00 on holideys  holiday . timeCode . codeElement [ 0 ]. startTime   =   9   *   60 ;  holiday . timeCode . codeElement [ 0 ]. endTime   =   10   *   60 ;  UF_RET_CODE   result   =   UF_AddHoliday (   & holiday   );",
            "title": "UF_AddHoliday"
        },
        {
            "location": "/documents/API_Specification/#uf_getholiday",
            "text": "Reads the specified holiday schedule.   Description  UF_RET_CODE   UF_GetHoliday (   int   ID ,   UFHoliday *   holiday   )   Parameters  ID \nID of the holiday schedule.  holiday \nPointer to the holiday schedule to be read.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetHoliday"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteholiday",
            "text": "Deletes the specified holiday schedule.   Description  UF_RET_CODE   UF_DeleteHoliday (   int   ID   )   Parameters  ID \nID of the holiday schedule.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteHoliday"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallholiday",
            "text": "Deletes all the holiday schedules stored in a BioEntry reader.   Description  UF_RET_CODE   UF_DeleteAllHoliday ()   Parameters \nNone    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllHoliday"
        },
        {
            "location": "/documents/API_Specification/#uf_addaccessgroup",
            "text": "Each access group may have up to 16 time schedules. The access of members is granted only when the time belongs to the time schedules of the group.  #define UF_SCHEDULE_PER_GROUP    16  typedef   struct   {       int   groupID ;       int   numOfSchedule ;       int   scheduleID [ UF_SCHEDULE_PER_GROUP ];  }   UFAccessGroup ;    Description  UF_RET_CODE   UF_AddAccessGroup (   UFAccessGroup *   group   )   Parameters  group \nPointer to the access group to be added.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_AddAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_getaccessgroup",
            "text": "Reads the specified access group.   Description  UF_RET_CODE   UF_GetAccessGroup (   int   ID ,   UFAccessGroup *   group   )   Parameters  ID \nID of the access group.  group \nPointer to the access group to be read.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteaccessgroup",
            "text": "Deletes the specified access group.   Description  UF_RET_CODE   UF_DeleteAccessGroup (   int   ID   )   Parameters  ID \nID of the access group.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallaccessgroup",
            "text": "Deletes all the access groups stored in a BioEntry reader.   Description  UF_RET_CODE   UF_DeleteAllAccessGroup ()   Parameters \nNone    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_setuseraccessgroup",
            "text": "Assigns access groups to a user. A user can be a member of up to 4 access groups.   Description  UF_RET_CODE   UF_SetUserAccessGroup (   UINT32   userID ,   int   numOfGroup ,   int *   groupID   )   Parameters  userID \nUser ID.  numOfGroup \nNumber of access groups to be assigned.  groupID \nArray of access group IDs to be assigned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_SetUserAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#uf_getuseraccessgroup",
            "text": "Reads the IDs of access groups assigned to a user.   Description  UF_RET_CODE   UF_GetUserAccessGroup (   UINT32   userID ,   int *   numOfGroup ,   int *   groupID   )   Parameters  userID \nUser ID.  numOfGroup \nPointer to the number of access groups to be returned.  groupID \nArray of access group IDs to be returned.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetUserAccessGroup"
        },
        {
            "location": "/documents/API_Specification/#322-blacklist-api",
            "text": "When a user ID is added to the blacklist, authentication will always fail regardless of fingerprint matching result. The blacklist takes precedence over the authentication type of a user. For example, though the authentication mode of a user is UF_AUTH_BYPASS, the authentication would fail if it is in the blacklist. The blacklist can store up to 1022 user IDs.   UF_AddBlacklist : adds an ID to the blacklist.  UF_DeleteBlacklist : deletes an ID from the blacklist.  UF_GetBlacklist : reads the IDs in the blacklist.  UF_DeleteAllBlacklist : clears the blacklist.",
            "title": "3.22. Blacklist API"
        },
        {
            "location": "/documents/API_Specification/#uf_addblacklist",
            "text": "Adds a user ID to the blacklist.   Description  UF_RET_CODE   UF_AddBlacklist (   UINT32   userID ,   int *   numOfBlacklistedID   )   Parameters  userID \nUser ID.  numOfBlacklistedID \nNumber of IDs in the blacklist after adding.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_AddBlacklist"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteblacklist",
            "text": "Deletes an ID from the blacklist.   Description  UF_RET_CODE   UF_DeleteBlacklist (   UINT32   userID ,   int *   numOfBlacklistedID   )   Parameters  userID \nUser ID.  numOfBlacklistedID \nNumber of IDs in the blacklist after deleting.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteBlacklist"
        },
        {
            "location": "/documents/API_Specification/#uf_getblacklist",
            "text": "Receive user IDs in the blacklist.   Description  UF_RET_CODE   UF_GetBlacklist (   int *   numOfBlacklistedID ,   UINT32 *   userID   )   Parameters  numOfBlacklistedID \nPointer to the number of IDs in the blacklist.  userID \nArray of user IDs in the blacklist. This should be pre-allocated large enough.    Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_GetBlacklist"
        },
        {
            "location": "/documents/API_Specification/#uf_deleteallblacklist",
            "text": "Clears the blacklist.   Description  UF_RET_CODE   UF_DeleteAllBlacklist ()   Parameters \nNone Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_DeleteAllBlacklist"
        },
        {
            "location": "/documents/API_Specification/#323-wsq-api",
            "text": "The Wavelet Scalar Quantization (WSQ) Gray-scale Fingerprint Image Compression Algorithm is the standard for the exchange of 8-bit, \n500ppi fingerprint images within the criminal justice community. SFM5500 / SFM6000 series provide the WSQ compression feature when the module scanning an image.    Warning  SFM5500/6000 series are supported only.   Suprema\u2019s WSQ algorithm is certified by FBI.\n( https://www.fbibiospecs.cjis.gov/WSQ/Implementations )   UF_ScanImageEx : scans a fingerprint on the sensor and retrieves the image data.  UF_ReadImageEx : retrieves the last scanned fingerprint image.  UF_WSQ_Decode : Decode the compressed WSQ fingerprint image which is read or scaned by the module.   UF_ScanImageEx  and  UF_ReadImageEx  are extended APIs of  UF_ScanImage / UF_ReadImage . These APIs are provide WSQ compression feature.  UF_IMAGE_TYPE  is used as an input parameter in  UF_ScanImageEx / UF_ReadImageEX  funtions.   UF_IMAGE_TYPE  is defined as bellow.    typedef   enum   {  UF_GRAY_IMAGE   =   0x30 ,  UF_BINARY_IMAGE   =   0x31 ,  UF_4BIT_GRAY_IMAGE   =   0x32 ,  UF_WSQ_IMAGE   =   0x33 ,  UF_WSQ_HQ_IMAGE   =   0x33 ,  UF_WSQ_MQ_IMAGE   =   0x34 ,  UF_WSQ_LQ_IMAGE   =   0x35 ,  }   UF_IMAGE_TYPE ;",
            "title": "3.23. WSQ API"
        },
        {
            "location": "/documents/API_Specification/#uf_scanimageex",
            "text": "Scans a fingerprint on the sensor and retrieves the image data.   Description  UF_RET_CODE   UF_ScanImageEx (   UFImage *   image ,   UF_IMAGE_TYPE   type ,   int   wsqBitRate   )   Parameters  image \nPointer to the UFImage structure.  type \nType of an image to read or scan.  wsqBitRate \nWSQ is compressed by input of wsqBitRate in the module. The value of\nwsqBitRate is recommended as below.     wsqBitRate = 225 , High quality compressing (compressing rate approx. 1:5)    wsqBitRate = 150 , Midium quality compressing (compressing rate approx. 1:10)    wsqBitRate = 75 , Low quality compressing (compressing rate approx. 1:15)     Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ScanImageEx"
        },
        {
            "location": "/documents/API_Specification/#uf_readimageex",
            "text": "Retrieves the last scanned fingerprint image.     Description  UF_RET_CODE   UF_ReadImageEx (   UFImage *   image ,   UF_IMAGE_TYPE   type ,   int   wsqBitRate   )   Parameters    image \nPointer to the UFImage structure.  type \nType of an image to read or scan.  wsqBitRate \nWSQ is compressed by input of wsqBitRate in the module. The value of wsqBitRate is recommended as below.     wsqBitRate = 225 , High quality compressing (compressing rate approx. 1:5)    wsqBitRate = 150 , Midium quality compressing (compressing rate approx. 1:10)    wsqBitRate = 75 , Low quality compressing (compressing rate approx. 1:15)     Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_ReadImageEx"
        },
        {
            "location": "/documents/API_Specification/#uf_wsq_decode",
            "text": "Decode the compressed WSQ fingerprint image which is read or scaned by the module.   Description  UF_RET_CODE   UF_WSQ_Decode ( unsigned   char   ** odata ,   int   * ow ,   int   * oh ,   int   * od ,   int   * oppi , int   * lossyflag ,   unsigned   char   * idata ,   const   int   ilen )   Parameters  odata \nPointer to the decoded image data.  ow \nPointer to the width of decoded image data.  oh \nPointer to the height of decoded image data.  od \nPointer to the bit depth of decoded image data. (Always returns 8)  lossyflag \nPointer to the lossy flag. (Always returns 1)  idata \nPointer to the read or scaned WSQ fingerprint image data by the module.  ilen \nPointer to the length of idata     Warning  odata  is dynamic allocated by the  UF_WSQ_Decode  function. You should free\nmemory of odata after use it.   Return Values \nIf the function succeeds, return  UF_RET_SUCCESS . Otherwise, return the corresponding error code.",
            "title": "UF_WSQ_Decode"
        },
        {
            "location": "/documents/API_Specification/#contact-info",
            "text": "Headquarters     Suprema, Inc. ( http://www.supremainc.com ) \n16F Parkview Office Tower, \nJoengja-dong, Bundang-gu, \nSeongnam, Gyeonggi, 463-863 Korea \nTel: +82-31-783-4505 \nFax:+82-31-783-4506 \nEmail:  sales@supremainc.com ,  support@supremainc.com",
            "title": "Contact Info"
        },
        {
            "location": "/documents/UF_Protocol_Manual/",
            "text": "UF Protocol Manual\n\u00b6\n\n\nPacket Protocol\n\u00b6\n\n\nIn the packet protocol of UniFinger, 1 packet is \n13 bytes\n long and its structure is as follows.\n\n\n\n\n\n\n\n\nStart code\n\n\nCommand\n\n\nParam\n\n\nSize\n\n\nFlag/Error\n\n\nChecksum\n\n\nEnd code\n\n\n\n\n\n\n\n\n\n\n1byte\n\n\n1byte\n\n\n4bytes\n\n\n4bytes\n\n\n1byte\n\n\n1byte\n\n\n1byte\n\n\n\n\n\n\n\n\n\n\nStart code\n: 1 byte. Indicates the beginning of a packet. It always should be 0x40.  \n\n\nCommand\n: 1 byte. Refer to the \"Command Summary\" on page 66.  \n\n\nParam\n: 4 bytes. Indicates user ID or system parameters.  \n\n\nSize\n: 4 bytes. Indicates the size of binary data following the command packet such as fingerprint templates or images.  \n\n\nFlag/Error\n: 1 byte. Indicates flag data in the request command sent to the module, and error code in the response command received from the module, respectively.  \n\n\nChecksum\n: 1 byte. Checks the validity of a packet. Checksum is a remainder of the sum of each field, from the Start code to Flag/Error, divided by 256 (0x100).  \n\n\nEnd code\n: 1 byte. Indicates the end of a packet. It always should be 0x0A. It is also used as a code indicating the end of a binary data such as fingerprint templates.  \n\n\n\n\n\n\n\n\nThe packet transmitted between the host and the module has the same structures. The commands transmitting from the host to the module are called \nrequest command\n, and the response transmitting from the module to the hosts, \nresponse command\n.  \n\n\nIn general, the host receives one response command for one request command. However, it may receive two response commands for some commands such as Enroll by Scan. The first command comes in the intermediate stage, notifying image scanning completed and the other command notifies process result. If you do not want to receive the intermediate command, you can disable it by changing a system parameter.  \n\n\nThe fingerprint templates vary in size by sensor and firmware version.  \n\n\nIn the following document, \n#\n indicates numbers and the \nnumber of #\n specifies the number of digits. \nN/A\n indicates that any value can be applied to the field and \nNull\n indicates 0x00.  \n\n\nIn the transmission of actual data, the byte order is little endian, the lowest byte is transmitted first. For instance, when transmitting data of 400 (0x190) in the Size field, which is 4 bytes long, the data transmission order is as follows: 0x90, 0x01, 0x00, 0x00. The rule also holds for the data received from the module.  \n\n\nTake \nES\n command (0x05) as an example, the following is the data transmission order and computation of the checksum of the command:\nWhen enrolling a new fingerprint with an ID,\u20180x9929\u2019:  \n\n\n\n\n\n\n\n\n\n\nStart code\n\n\nCommand\n\n\nParam\n\n\nSize\n\n\nFlag/Error\n\n\nChecksum\n\n\nEnd code\n\n\n\n\n\n\n\n\n\n\n0x40\n\n\n0x05\n\n\n0x9929\n\n\n0x00\n\n\n0x00\n\n\n0x07\n\n\n0x0A\n\n\n\n\n\n\n\n\nActual values input in the Param:\n\n\n\n\n\n\n\n\n1\nst\nplace\n\n\n2\nnd\n place\n\n\n3\nrd\n place\n\n\n4\nth\n place\n\n\n\n\n\n\n\n\n\n\n0x29\n\n\n0x99\n\n\n0x00\n\n\n0x00\n\n\n\n\n\n\n\n\nByte transmission order:\n\n\n0x40, 0x05, 0x29, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0A\n\n\nTo compute the checksum, first compute the sum of each byte of the packet (from start code to flag/error) as demonstrated below:\n\n\n0x40 + 0x05 + 0x29 + 0x99 + 0x00 + 0x00 + 0x00 + 0x00 + 0x00 + 0x00 = 0x107\n\n\nDivide the above value by 0x100(256). The remainder of this division is 0x07 and this value is the checksum.\n\n\n\n\nNetwork Packet Protocol\n\u00b6\n\n\nIn order to support RS422 or RS485 network interfaces, UniFinger modules support network packet protocols. Network packet is composed of \n15 bytes\n, whose start code is different from the standard packet, and includes 2 bytes for terminal ID. The terminal ID is correspondent to the lower 2 bytes of Module ID of system parameter.\n\n\n\n\nThe contents of the network packet, including command, param, size, and flag are same as those of standard packet. Checksum field is the checksum value of preceding 13 bytes.\n\nUntil firmware V1.3, SFM3000/3500 modules respond both standard and network packets regardless of Network Mode system parameter. However, since firmware V1.4, the modules only respond to 15 byte network packets if Network Mode system parameter is on. See Network Mode system parameter for details.\n\n\n\n\nBroadcast Packet Protocol\n\u00b6\n\n\nIn RS422 or RS485 network environments, a host can send broadcast packets to all the modules in the network. The only difference between network packets and broadcast packets is that the Terminal ID field of the latter should be 0x00.\n\n\n\n\nAll the modules in the network process the broadcast packet, but do not send response packet to prevent packet collisions. Therefore, if the host wants to confirm that the broadcast request is handled correctly, it should send another request packet to each module using Network Packet Protocol. There is only one exception to this rule. See ID command for details.\n\nBroadcast Packet Protocol is provided for SFM3000/3500/4000/5000/5500/6020/6030/6050 series only. The 13 byte broadcast packet protocol introduced in V1.3 firmware is not supported any longer.\n\nThree types of packet protocol can be summarized as follows:  \n\n\n\n\nSystem Parameter Summary\n\u00b6\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nDescription\n\n\nValue (*denotes default value)\n\n\n\n\n\n\n\n\n\n\nTimeout\n\n\n0x62\n\n\nTimeout period\n\n\n0x30 : infinite \n 0x31 : 1 second \n ... \n *0x3A : 10 seconds \n ... \n 0x44 : 20 seconds\n\n\n\n\n\n\nTemplate Size \n1\n\n\n0x64\n\n\nTemplate size. When the Encryption Mode is on, it should be a multiple of 32.\n\n\nInteger between 256 and *384\n4\n\n\n\n\n\n\nEnroll Mode\n\n\n0x65\n\n\nEnroll mode\n\n\n0x30 : 1 time \n 0x31 : 2 times ( 1 request command & 2 response commands ) \n 0x32 : 2 times II ( 2 request commands & 2 response commands ) \n *0x41 : 2 templates ( 1 request command & 2 response commands ) \n1\n \n 0x42 : 2 templates II ( 2 request commands & 2 response commands ) \n1\n \n\n\n\n\n\n\nSecurity Level\n\n\n0x66\n\n\nSecurity Level\n\n\n0x30 : 1/10 FAR( False Acceptance Rate ) \n1\n5\n \n 0x31 : 1/100(5) \n  0x32 : 1/1,000(5) \n 0x33 : 1/10,000 \n 0x34 : 1/100,000 \n 0x35 : 1/1,000,000 \n 0x36 : 1/10,000,000 \n1\n \n 0x37 : 1/100,000,000 \n1\n \n 0x40 : 3/100 \n1\n5\n \n 0x41 : 3/1,000 \n1\n5\n \n 0x42 : 3/10,000 \n1\n5\n \n 0x43 : 3/100,000 \n1\n \n 0x44 : 3/1,000,000 \n1\n \n 0x45 : 3/10,000,000 \n1\n \n 0x46 : 3/100,000,000 \n1\n \n *0x50 : Automatic Normal\n1\n \n 0x51 : Automatic Secure\n1\n \n 0x52 : Automatic More Secure\n1\n\n\n\n\n\n\nEncryption Mode\n\n\n0x67\n\n\nEncryption mode\n\n\n*0x30 : Encryption off \n 0x31 : Encryption on\n\n\n\n\n\n\nSensor Type\n\n\n0x68\n\n\nSensor Type\n\n\n0x31: FC \n 0x33 : OP / OP2 / OP3 / OP4 / OP5 \n 0x34 : TC1 / TC2 / TC1S / TC2S \n 0x38 : OC2 / OD/ OC4 / OH \n 0x39 : OL \n 0x3C: TS4\n\n\n\n\n\n\nImage Format\n\n\n0x6C\n\n\nImage format\n\n\n0x30 : Gray image \n *0x31 : Binary image \n 0x32 : 4 bit gray image \n 0x33 : WSQ image\n9\n\n\n\n\n\n\nModule ID\n\n\n0x6D\n\n\nModule ID\n\n\nInteger 0 ~ 65535\n\n\n\n\n\n\nFirmware Version\n\n\n0x6E\n\n\nFirmware version\n\n\n4bytes character\n\n\n\n\n\n\nSerial Number\n\n\n0x6F\n\n\nSerial number\n\n\nInteger (4bytes)\n\n\n\n\n\n\nBaudrate\n\n\n0x71\n\n\nHost baudrate setting\n\n\n0x31 : 9600 bps \n 0x32 : 19200 bps \n 0x33 : 38400 bps \n 0x34 : 57600 bps \n *0x35 : 115200 bps \n 0x36 : 230400 bps \n 0x37 : 460800 bps \n 0x38 : 921600 bps\n\n\n\n\n\n\nBaudrate2\n2\n\n\n0x72\n\n\nAuxiliary baudrate setting\n\n\n0x31 : 9600 bps \n 0x32 : 19200 bps \n 0x33 : 38400 bps \n 0x34 : 57600 bps \n *0x35 : 115200 bps\n\n\n\n\n\n\nEnrolled Finger\n\n\n0x73\n\n\nCurrent number of fingerprints enrolled\n\n\nInteger (4bytes)\n\n\n\n\n\n\nAvailable Finger\n\n\n0x74\n\n\nThe available number of fingerprints that can be enrolled\n\n\nInteger (4bytes)\n\n\n\n\n\n\nSend Scan Success\n\n\n0x75\n\n\nEnable sending SCAN_SUCCESS response\n\n\n0x30 : No SCAN_SUCCESS message \n *0x31 : Send SCAN_SUCCESS message\n\n\n\n\n\n\nASCII Packet\n\n\n0x76\n\n\nFlag for packet exchange though HEX-ASCII format\n\n\n*0x30 : Hexadecimal packet \n 0x31 : ASCII packet\n\n\n\n\n\n\nRotate Image\n\n\n0x77\n\n\nFlag for rotating sensor image in capture\n\n\n*0x30 : Upright image \n 0x31 : Upside down image\n\n\n\n\n\n\nRotation\n1\n\n\n0x78\n\n\nMaximum allowable rotation for matching\n\n\n0x31: 15 degree \n * 0x32: 30 degree \n 0x33: 45 degree \n 0x34: 60 degree \n 0x35: 75 degree \n 0x36: 90 degree\n\n\n\n\n\n\nSensitivity\n\n\n0x80\n\n\nParameter for sensor sensitivity\n\n\n0x30 : Least sensitive \n \u2026 \n *0x37 : Most sensitive\n\n\n\n\n\n\nImage Quality\n\n\n0x81\n\n\nParameter for qualifying scanned image\n\n\n0x30 : Weak qualification \n *0x31 : Moderate qualification \n 0x32 : Strong qualification \n 0x33 : Strongest qualification\n\n\n\n\n\n\nAuto Response\n\n\n0x82\n\n\nFlag for sending automatic response as the result of GPIO input or FreeScan\n\n\n*0x30 : No response command \n 0x31 : Send response command ( host ) \n 0x32 : Send response command ( aux ) \n2\n \n 0x33 : Send response command ( both ) \n2\n\n\n\n\n\n\nNetwork Mode\n\n\n0x83\n\n\nFlag for default operation mode\n\n\n*0x30 : Single mode \n 0x31 : Network mode ( half duplex ) \n 0x32 : Network mode ( full duplex )\n2\n\n\n\n\n\n\nFree Scan\n\n\n0x84\n\n\nScan always fingerprint images for identification on idle state\n\n\n*0x30 : Normal mode \n 0x31 : Free scan mode\n\n\n\n\n\n\nProvisional Enroll\n\n\n0x85\n\n\nSave enrolled templates at flash memory permanently or not\n\n\n*0x30 : Permanent enrollment \n 0x31 : Provisional enrollment\n\n\n\n\n\n\nPass When Empty\n\n\n0x86\n\n\nPass or fail when fingerprint DB is empty\n\n\n*0x30 : Fail when DB is empty \n 0x31 : Pass when DB is empty\n\n\n\n\n\n\nResponse Delay\n\n\n0x87\n\n\nDelay for response command\n\n\n*0x30 : No delay \n 0x31 : 20 msec \n \u2026 \n 0x35 : 100 msec \n \u2026 \n 0x3A : 200 msec\n\n\n\n\n\n\nMatching Timeout\n\n\n0x88\n\n\nTimeout period for matching in identification\n\n\n0x30 : infinite \n 0x31 : 1 second \n \u2026 \n *0x33: 3 seconds \n \u2026 \n 0x3A : 10 seconds \n \u2026 \n 0x44 : 20 seconds\n\n\n\n\n\n\nBuild Number\n\n\n0x89\n\n\nBuild number\n\n\n4bytes character\n\n\n\n\n\n\nEnroll Displacement\n3\n\n\n0x8A\n\n\nDisplacement between two fingerprints for enrollment in case EnrollMode parameter is 2 times or 2 templates\n\n\n*0x30 : No check \n 0x31 : Above 1 mm away \n \u2026 \n 0x35 : Above 5 mm away \n \u2026 \n 0x3A : Above 10 mm away\n\n\n\n\n\n\nLighting Condition\n1\n\n\n0x90\n\n\nTune optical sensors based on lighting conditions\n\n\n*0x30: Outdoor \n 0x31: Indoor\n\n\n\n\n\n\nFree Scan Delay\n1\n\n\n0x91\n\n\nDelay between consecutive identification processes in Free Scan Mode.\n\n\n0x30: No delay \n *0x31: 1 second \n \u2026 \n0x40: 10 seconds\n\n\n\n\n\n\nFast Mode\n1\n\n\n0x93\n\n\nFast mode for 1:N matching\n\n\n0x30: Normal \n 0x31: Fast mode 1 \n \u2026 \n 0x35: Fast mode 5(Fastest) \n *0x36: Automatic\n\n\n\n\n\n\nWatchdog\n1\n\n\n0x94\n\n\nWatchdog timer\n\n\n0x30: Don\u2019t use Watchdog timer \n *0x31: Use Watchdog timer\n\n\n\n\n\n\nTemplate Type\n1\n\n\n0x96\n\n\nTemplate type\n\n\n*0x30: Suprema \n 0x31: ISO 19794-2 \n 0x32: ANSI 378\n\n\n\n\n\n\nEnhanced Privacy\n1\n\n\n0x97\n\n\nEnhanced privacy mode\n\n\n*0x30: Enhanced mode off \n 0x31: Enhanced mode on\n\n\n\n\n\n\nFake Finger Detection\n1\n\n\n0x98\n\n\nFake finger detection option\n\n\n*0x30: Fake detection off \n 0x31: Fake detection on ( Weak\n8\n) \n 0x32: Normal\n8\n \n 0x33: Strong\n8\n\n\n\n\n\n\nCheck Latent Fingerprint\n6\n\n\n0x9A\n\n\nLatent fingerprint detection option\n\n\n*0x30: Don\u2019t check latent fingerprints when enrolling \n 0x31: Don\u2019t check latent fingerprints \n 0x32: Check latent fingerprints always\n\n\n\n\n\n\nVoltage Warning\n7\n\n\n0x9B\n\n\nVoltage warning threshold\n\n\n*0: Don\u2019t check voltage \n 1 ~ 12000: Threshold voltage in mV\n\n\n\n\n\n\nPowerOff\n\n\n0x9C\n\n\nTimeout for automatic power off\n\n\n*0: No timeout\n\n\n\n\n\n\n\n\n\n\nCommand Summary\n\u00b6\n\n\n\n\n\n\n\n\nCategory\n\n\nName\n\n\nCode\n\n\nDescription\n\n\n3000 / 4000 / 5000\n\n\n3500 / 5500\n\n\n6000\n\n\n\n\n\n\n\n\n\n\nSystem Configuration\n\n\nSW\n\n\n0x01\n\n\nWrite system parameter\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nSF\n\n\n0x02\n\n\nSave system parameter\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nSR\n\n\n0x03\n\n\nRead system parameter\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nCS\n\n\n0x1A\n\n\nCalibrate sensor\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nSS\n\n\n0x04\n\n\nCheck system status\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nCA\n\n\n0x60\n\n\nCancel\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nID\n\n\n0x85\n\n\nGet the module ID\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nUG\n\n\n0x62\n\n\nUpgrade firmware\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nRS\n\n\n0xD0\n\n\nReset the module\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nLM\n\n\n0xB1\n\n\nLock the module\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUM\n\n\n0xB0\n\n\nUnlock the module\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nMP\n\n\n0xB2\n\n\nChange the master password\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nOFF\n\n\n0xD2\n\n\nTurn off the module\n\n\nO\n7\n\n\nX\n\n\nX\n\n\n\n\n\n\nEnroll\n\n\nES\n\n\n0x05\n\n\nEnroll by scan\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nESA\n\n\n0x70\n\n\nES with administrator\u2019s verification\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nEI\n\n\n0x06\n\n\nEnroll by image\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nEIX\n\n\n0x80\n\n\nEI with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nET\n\n\n0x07\n\n\nEnroll by template\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nETX\n\n\n0x87\n\n\nET with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nEW\n\n\n0x1C\n\n\nEnroll by Wiegand ID\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nEWA\n\n\n0x71\n\n\nEW with administrator\u2019s verification\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nVerify\n\n\nVS\n\n\n0x08\n\n\nVerify by scan\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nVI\n\n\n0x09\n\n\nVerify by image\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nVIX\n\n\n0x82\n\n\nVI with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nVT\n\n\n0x10\n\n\nVerify by template\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nVW\n\n\n0x1D\n\n\nVerify by Wiegand ID\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nVH\n\n\n0x22\n\n\nVerify host template by scan\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nWSL\n\n\n0x6B\n\n\nWrite security level of a user\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nRSL\n\n\n0x6C\n\n\nRead security level of a user\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nIdentify\n\n\nIS\n\n\n0x11\n\n\nIdentify by scan\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nII\n\n\n0x12\n\n\nIdentify by image\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nIIX\n\n\n0x81\n\n\nII with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nIT\n\n\n0x13\n\n\nIdentify by template\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nDelete\n\n\nDA\n\n\n0x17\n\n\nDelete all templates\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nDAA\n\n\n0x74\n\n\nDA with administrator\u2019s verification\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nDT\n\n\n0x16\n\n\nDelete template\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nDS\n\n\n0x1E\n\n\nDelete by scan\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nDSA\n\n\n0x72\n\n\nDS with administrator\u2019s verification\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nDW\n\n\n0x1F\n\n\nDelete by Wiegand ID\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nDWA\n\n\n0x73\n\n\nDW with administrator\u2019s verification\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nTemplate management\n\n\nLT\n\n\n0x18\n\n\nList user ID\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nLTX\n\n\n0x86\n\n\nList user ID with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nCT\n\n\n0x19\n\n\nCheck user ID\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nFP\n\n\n0x23\n\n\nFix all provisional templates\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nDP\n\n\n0x24\n\n\nDelete all provisional templates\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nGet image and template\n\n\nRI\n\n\n0x20\n\n\nRead image\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nRIX\n\n\n0x84\n\n\nRI with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nSI\n\n\n0x15\n\n\nScan image\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nSIX\n\n\n0x83\n\n\nSI with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nRT\n\n\n0x14\n\n\nRead template\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nRTX\n\n\n0x89\n\n\nRT with extended data transfer protocol\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nST\n\n\n0x21\n\n\nScan template\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nKS\n\n\n0x35\n\n\nScan template with challenge data\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nKW\n\n\n0x34\n\n\nWrite encryption key\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nUser memory management\n\n\nML\n\n\n0x31\n\n\nGet size of user memory\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nMW\n\n\n0x32\n\n\nWrite to user memory\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nMR\n\n\n0x33\n\n\nRead from user memory\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nTime and log management\n\n\nTW\n\n\n0x3A\n\n\nWrite current time\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nTR\n\n\n0x3B\n\n\nRead current time\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nLN\n\n\n0x3C\n\n\nGet number of log data\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nLR\n\n\n0x3D\n\n\nRead log data\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nLD\n\n\n0x3E\n\n\nDelete log data\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nLC\n\n\n0x3F\n\n\nSet / Get the custom log field\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nRCL\n\n\n0xEC\n\n\nRead log cache\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nCCL\n\n\n0xEB\n\n\nClear log cache\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nWiegand configuration\n\n\nWW\n\n\n0x41\n\n\nWrite Wiegand configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWR\n\n\n0x42\n\n\nRead Wiegand configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWG\n\n\n0x43\n\n\nGet Wiegand input\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWS\n\n\n0x44\n\n\nSet Wiegand output\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWM\n\n\n0x68\n\n\nMap Wiegand ID to input function\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWL\n\n\n0x69\n\n\nList Wiegand ID mapping\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWC\n\n\n0x6A\n\n\nClear Wiegand ID mapping\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nExtended Wiegand configuration\n\n\nWWX\n\n\n0xC0\n\n\nWrite Wiegand configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWRX\n\n\n0xC1\n\n\nRead Wiegand configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWGX\n\n\n0xC2\n\n\nGet Wiegand input\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWSX\n\n\n0xC3\n\n\nSet Wiegand output\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWFW\n\n\n0xC4\n\n\nSet alternative value of a field\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWFR\n\n\n0xC5\n\n\nGet alternative value of a filed\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWPW\n\n\n0xC6\n\n\nWrite Wiegand I/O settings\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nWPR\n\n\n0xC7\n\n\nRead Wiegand I/O settings\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nInput configuration\n\n\nIW\n\n\n0x47\n\n\nWrite input configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nIR\n\n\n0x48\n\n\nRead input configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nIG\n\n\n0x49\n\n\nGet input state\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nOutput configuration\n\n\nOW\n\n\n0x4A\n\n\nWrite output configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nOR\n\n\n0x4B\n\n\nRead output configuration\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nOL\n\n\n0x4C\n\n\nRead output configuration list\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nOS\n\n\n0x4D\n\n\nSet output state\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nGPIO configuration\n\n\nGW\n\n\n0x37\n\n\nWrite GPIO configuration\n\n\nO\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nGR\n\n\n0x36\n\n\nRead GPIO configuration\n\n\nO\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nGC\n\n\n0x38\n\n\nClear GPIO configuration\n\n\nO\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\nGD\n\n\n0x39\n\n\nSet default GPIO configuration\n\n\nO\n\n\nX\n\n\nO\n\n\n\n\n\n\nAdmin level configuration\n\n\nAW\n\n\n0x65\n\n\nWrite administration level\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nAR\n\n\n0x66\n\n\nRead administration level\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\n\n\nAC\n\n\n0x67\n\n\nClear administration level\n\n\nO\n\n\nO\n\n\nO\n\n\n\n\n\n\nAuth. mode configuration\n\n\nUW\n\n\n0xA3\n\n\nWrite authentication mode\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUR\n\n\n0xA4\n\n\nRead authentication mode\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUC\n\n\n0xA5\n\n\nReset authentication mode to default\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nUL\n\n\n0xA6\n\n\nList user IDs grouped by authentication mode\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nBlacklist configuration\n\n\nABL\n\n\n0xF3\n\n\nAdd an ID to blacklist\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nDBL\n\n\n0xF4\n\n\nDelete an ID from blacklist\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nRBL\n\n\n0xF5\n\n\nRead blacklist\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nCBL\n\n\n0xF6\n\n\nClear blacklist\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nEntrance limit configuration\n\n\nWME\n\n\n0xF0\n\n\nWrite entrance limit\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nRME\n\n\n0xF1\n\n\nRead entrance limit\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\n\n\nCME\n\n\n0xF2\n\n\nClear entrance limit\n\n\nX\n\n\nO\n\n\nX\n\n\n\n\n\n\nSystem Parameter\n\n\nFR\n\n\n0xFA\n\n\nFactory reset by erasing system parameter\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\nFile System\n\n\nFF\n\n\n0xFF\n\n\nRaw format userdb partition\n\n\nX\n\n\nX\n\n\nO\n\n\n\n\n\n\n\n\n\n\nContact us\n\n\nIf you need more detail information about this document (UF_Protocol_Manual), please contact at \nsales_sol@suprema.co.kr\n\n\n\n\n\n\n\n\n\n\n\n\nSFM3000/3500/4000/5000 only\u00a0\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\n\n\n\n\n\nSFM3500 only\u00a0\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\n\n\n\n\n\nSFM3000/3500/4000/5000 only\u00a0\n\u21a9\n\n\n\n\n\n\nReducing template size might affect authentication performance.\u00a0\n\u21a9\n\n\n\n\n\n\nSince firmware V1.3, the minimum security level of SFM3000/3500 series is changed to 1/10,000.\u00a0\n\u21a9\n\u21a9\n\u21a9\n\u21a9\n\n\n\n\n\n\nSFM3020-OP, SFM3520-OP, SFM4020-OP, SFM5020-OP only\u00a0\n\u21a9\n\n\n\n\n\n\nSFM4000 only\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nSFM5060-OH only\u00a0\n\u21a9\n\u21a9\n\u21a9\n\n\n\n\n\n\nSFM5500 only\u00a0\n\u21a9\n\n\n\n\n\n\nSFM60x0 only\u00a0\n\u21a9",
            "title": "UF Protocol Manual"
        },
        {
            "location": "/documents/UF_Protocol_Manual/#uf-protocol-manual",
            "text": "",
            "title": "UF Protocol Manual"
        },
        {
            "location": "/documents/UF_Protocol_Manual/#packet-protocol",
            "text": "In the packet protocol of UniFinger, 1 packet is  13 bytes  long and its structure is as follows.     Start code  Command  Param  Size  Flag/Error  Checksum  End code      1byte  1byte  4bytes  4bytes  1byte  1byte  1byte      Start code : 1 byte. Indicates the beginning of a packet. It always should be 0x40.    Command : 1 byte. Refer to the \"Command Summary\" on page 66.    Param : 4 bytes. Indicates user ID or system parameters.    Size : 4 bytes. Indicates the size of binary data following the command packet such as fingerprint templates or images.    Flag/Error : 1 byte. Indicates flag data in the request command sent to the module, and error code in the response command received from the module, respectively.    Checksum : 1 byte. Checks the validity of a packet. Checksum is a remainder of the sum of each field, from the Start code to Flag/Error, divided by 256 (0x100).    End code : 1 byte. Indicates the end of a packet. It always should be 0x0A. It is also used as a code indicating the end of a binary data such as fingerprint templates.       The packet transmitted between the host and the module has the same structures. The commands transmitting from the host to the module are called  request command , and the response transmitting from the module to the hosts,  response command .    In general, the host receives one response command for one request command. However, it may receive two response commands for some commands such as Enroll by Scan. The first command comes in the intermediate stage, notifying image scanning completed and the other command notifies process result. If you do not want to receive the intermediate command, you can disable it by changing a system parameter.    The fingerprint templates vary in size by sensor and firmware version.    In the following document,  #  indicates numbers and the  number of #  specifies the number of digits.  N/A  indicates that any value can be applied to the field and  Null  indicates 0x00.    In the transmission of actual data, the byte order is little endian, the lowest byte is transmitted first. For instance, when transmitting data of 400 (0x190) in the Size field, which is 4 bytes long, the data transmission order is as follows: 0x90, 0x01, 0x00, 0x00. The rule also holds for the data received from the module.    Take  ES  command (0x05) as an example, the following is the data transmission order and computation of the checksum of the command:\nWhen enrolling a new fingerprint with an ID,\u20180x9929\u2019:        Start code  Command  Param  Size  Flag/Error  Checksum  End code      0x40  0x05  0x9929  0x00  0x00  0x07  0x0A     Actual values input in the Param:     1 st place  2 nd  place  3 rd  place  4 th  place      0x29  0x99  0x00  0x00     Byte transmission order:  0x40, 0x05, 0x29, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0A  To compute the checksum, first compute the sum of each byte of the packet (from start code to flag/error) as demonstrated below:  0x40 + 0x05 + 0x29 + 0x99 + 0x00 + 0x00 + 0x00 + 0x00 + 0x00 + 0x00 = 0x107 \nDivide the above value by 0x100(256). The remainder of this division is 0x07 and this value is the checksum.",
            "title": "Packet Protocol"
        },
        {
            "location": "/documents/UF_Protocol_Manual/#network-packet-protocol",
            "text": "In order to support RS422 or RS485 network interfaces, UniFinger modules support network packet protocols. Network packet is composed of  15 bytes , whose start code is different from the standard packet, and includes 2 bytes for terminal ID. The terminal ID is correspondent to the lower 2 bytes of Module ID of system parameter.   The contents of the network packet, including command, param, size, and flag are same as those of standard packet. Checksum field is the checksum value of preceding 13 bytes. \nUntil firmware V1.3, SFM3000/3500 modules respond both standard and network packets regardless of Network Mode system parameter. However, since firmware V1.4, the modules only respond to 15 byte network packets if Network Mode system parameter is on. See Network Mode system parameter for details.",
            "title": "Network Packet Protocol"
        },
        {
            "location": "/documents/UF_Protocol_Manual/#broadcast-packet-protocol",
            "text": "In RS422 or RS485 network environments, a host can send broadcast packets to all the modules in the network. The only difference between network packets and broadcast packets is that the Terminal ID field of the latter should be 0x00.   All the modules in the network process the broadcast packet, but do not send response packet to prevent packet collisions. Therefore, if the host wants to confirm that the broadcast request is handled correctly, it should send another request packet to each module using Network Packet Protocol. There is only one exception to this rule. See ID command for details. \nBroadcast Packet Protocol is provided for SFM3000/3500/4000/5000/5500/6020/6030/6050 series only. The 13 byte broadcast packet protocol introduced in V1.3 firmware is not supported any longer. \nThree types of packet protocol can be summarized as follows:",
            "title": "Broadcast Packet Protocol"
        },
        {
            "location": "/documents/UF_Protocol_Manual/#system-parameter-summary",
            "text": "Name  Code  Description  Value (*denotes default value)      Timeout  0x62  Timeout period  0x30 : infinite   0x31 : 1 second   ...   *0x3A : 10 seconds   ...   0x44 : 20 seconds    Template Size  1  0x64  Template size. When the Encryption Mode is on, it should be a multiple of 32.  Integer between 256 and *384 4    Enroll Mode  0x65  Enroll mode  0x30 : 1 time   0x31 : 2 times ( 1 request command & 2 response commands )   0x32 : 2 times II ( 2 request commands & 2 response commands )   *0x41 : 2 templates ( 1 request command & 2 response commands )  1    0x42 : 2 templates II ( 2 request commands & 2 response commands )  1      Security Level  0x66  Security Level  0x30 : 1/10 FAR( False Acceptance Rate )  1 5    0x31 : 1/100(5)    0x32 : 1/1,000(5)   0x33 : 1/10,000   0x34 : 1/100,000   0x35 : 1/1,000,000   0x36 : 1/10,000,000  1    0x37 : 1/100,000,000  1    0x40 : 3/100  1 5    0x41 : 3/1,000  1 5    0x42 : 3/10,000  1 5    0x43 : 3/100,000  1    0x44 : 3/1,000,000  1    0x45 : 3/10,000,000  1    0x46 : 3/100,000,000  1    *0x50 : Automatic Normal 1    0x51 : Automatic Secure 1    0x52 : Automatic More Secure 1    Encryption Mode  0x67  Encryption mode  *0x30 : Encryption off   0x31 : Encryption on    Sensor Type  0x68  Sensor Type  0x31: FC   0x33 : OP / OP2 / OP3 / OP4 / OP5   0x34 : TC1 / TC2 / TC1S / TC2S   0x38 : OC2 / OD/ OC4 / OH   0x39 : OL   0x3C: TS4    Image Format  0x6C  Image format  0x30 : Gray image   *0x31 : Binary image   0x32 : 4 bit gray image   0x33 : WSQ image 9    Module ID  0x6D  Module ID  Integer 0 ~ 65535    Firmware Version  0x6E  Firmware version  4bytes character    Serial Number  0x6F  Serial number  Integer (4bytes)    Baudrate  0x71  Host baudrate setting  0x31 : 9600 bps   0x32 : 19200 bps   0x33 : 38400 bps   0x34 : 57600 bps   *0x35 : 115200 bps   0x36 : 230400 bps   0x37 : 460800 bps   0x38 : 921600 bps    Baudrate2 2  0x72  Auxiliary baudrate setting  0x31 : 9600 bps   0x32 : 19200 bps   0x33 : 38400 bps   0x34 : 57600 bps   *0x35 : 115200 bps    Enrolled Finger  0x73  Current number of fingerprints enrolled  Integer (4bytes)    Available Finger  0x74  The available number of fingerprints that can be enrolled  Integer (4bytes)    Send Scan Success  0x75  Enable sending SCAN_SUCCESS response  0x30 : No SCAN_SUCCESS message   *0x31 : Send SCAN_SUCCESS message    ASCII Packet  0x76  Flag for packet exchange though HEX-ASCII format  *0x30 : Hexadecimal packet   0x31 : ASCII packet    Rotate Image  0x77  Flag for rotating sensor image in capture  *0x30 : Upright image   0x31 : Upside down image    Rotation 1  0x78  Maximum allowable rotation for matching  0x31: 15 degree   * 0x32: 30 degree   0x33: 45 degree   0x34: 60 degree   0x35: 75 degree   0x36: 90 degree    Sensitivity  0x80  Parameter for sensor sensitivity  0x30 : Least sensitive   \u2026   *0x37 : Most sensitive    Image Quality  0x81  Parameter for qualifying scanned image  0x30 : Weak qualification   *0x31 : Moderate qualification   0x32 : Strong qualification   0x33 : Strongest qualification    Auto Response  0x82  Flag for sending automatic response as the result of GPIO input or FreeScan  *0x30 : No response command   0x31 : Send response command ( host )   0x32 : Send response command ( aux )  2    0x33 : Send response command ( both )  2    Network Mode  0x83  Flag for default operation mode  *0x30 : Single mode   0x31 : Network mode ( half duplex )   0x32 : Network mode ( full duplex ) 2    Free Scan  0x84  Scan always fingerprint images for identification on idle state  *0x30 : Normal mode   0x31 : Free scan mode    Provisional Enroll  0x85  Save enrolled templates at flash memory permanently or not  *0x30 : Permanent enrollment   0x31 : Provisional enrollment    Pass When Empty  0x86  Pass or fail when fingerprint DB is empty  *0x30 : Fail when DB is empty   0x31 : Pass when DB is empty    Response Delay  0x87  Delay for response command  *0x30 : No delay   0x31 : 20 msec   \u2026   0x35 : 100 msec   \u2026   0x3A : 200 msec    Matching Timeout  0x88  Timeout period for matching in identification  0x30 : infinite   0x31 : 1 second   \u2026   *0x33: 3 seconds   \u2026   0x3A : 10 seconds   \u2026   0x44 : 20 seconds    Build Number  0x89  Build number  4bytes character    Enroll Displacement 3  0x8A  Displacement between two fingerprints for enrollment in case EnrollMode parameter is 2 times or 2 templates  *0x30 : No check   0x31 : Above 1 mm away   \u2026   0x35 : Above 5 mm away   \u2026   0x3A : Above 10 mm away    Lighting Condition 1  0x90  Tune optical sensors based on lighting conditions  *0x30: Outdoor   0x31: Indoor    Free Scan Delay 1  0x91  Delay between consecutive identification processes in Free Scan Mode.  0x30: No delay   *0x31: 1 second   \u2026  0x40: 10 seconds    Fast Mode 1  0x93  Fast mode for 1:N matching  0x30: Normal   0x31: Fast mode 1   \u2026   0x35: Fast mode 5(Fastest)   *0x36: Automatic    Watchdog 1  0x94  Watchdog timer  0x30: Don\u2019t use Watchdog timer   *0x31: Use Watchdog timer    Template Type 1  0x96  Template type  *0x30: Suprema   0x31: ISO 19794-2   0x32: ANSI 378    Enhanced Privacy 1  0x97  Enhanced privacy mode  *0x30: Enhanced mode off   0x31: Enhanced mode on    Fake Finger Detection 1  0x98  Fake finger detection option  *0x30: Fake detection off   0x31: Fake detection on ( Weak 8 )   0x32: Normal 8    0x33: Strong 8    Check Latent Fingerprint 6  0x9A  Latent fingerprint detection option  *0x30: Don\u2019t check latent fingerprints when enrolling   0x31: Don\u2019t check latent fingerprints   0x32: Check latent fingerprints always    Voltage Warning 7  0x9B  Voltage warning threshold  *0: Don\u2019t check voltage   1 ~ 12000: Threshold voltage in mV    PowerOff  0x9C  Timeout for automatic power off  *0: No timeout",
            "title": "System Parameter Summary"
        },
        {
            "location": "/documents/UF_Protocol_Manual/#command-summary",
            "text": "Category  Name  Code  Description  3000 / 4000 / 5000  3500 / 5500  6000      System Configuration  SW  0x01  Write system parameter  O  O  O     SF  0x02  Save system parameter  O  O  O     SR  0x03  Read system parameter  O  O  O     CS  0x1A  Calibrate sensor  O  O  O     SS  0x04  Check system status  O  O  O     CA  0x60  Cancel  O  O  O     ID  0x85  Get the module ID  O  O  O     UG  0x62  Upgrade firmware  O  O  O     RS  0xD0  Reset the module  O  O  O     LM  0xB1  Lock the module  X  O  X     UM  0xB0  Unlock the module  X  O  X     MP  0xB2  Change the master password  X  O  X     OFF  0xD2  Turn off the module  O 7  X  X    Enroll  ES  0x05  Enroll by scan  O  O  O     ESA  0x70  ES with administrator\u2019s verification  O  O  O     EI  0x06  Enroll by image  O  O  O     EIX  0x80  EI with extended data transfer protocol  O  O  O     ET  0x07  Enroll by template  O  O  O     ETX  0x87  ET with extended data transfer protocol  O  O  O     EW  0x1C  Enroll by Wiegand ID  X  O  X     EWA  0x71  EW with administrator\u2019s verification  X  O  X    Verify  VS  0x08  Verify by scan  O  O  O     VI  0x09  Verify by image  O  O  O     VIX  0x82  VI with extended data transfer protocol  O  O  O     VT  0x10  Verify by template  O  O  O     VW  0x1D  Verify by Wiegand ID  X  O  X     VH  0x22  Verify host template by scan  O  O  O     WSL  0x6B  Write security level of a user  O  O  O     RSL  0x6C  Read security level of a user  O  O  O    Identify  IS  0x11  Identify by scan  O  O  O     II  0x12  Identify by image  O  O  O     IIX  0x81  II with extended data transfer protocol  O  O  O     IT  0x13  Identify by template  O  O  O    Delete  DA  0x17  Delete all templates  O  O  O     DAA  0x74  DA with administrator\u2019s verification  O  O  O     DT  0x16  Delete template  O  O  O     DS  0x1E  Delete by scan  O  O  O     DSA  0x72  DS with administrator\u2019s verification  O  O  O     DW  0x1F  Delete by Wiegand ID  X  O  X     DWA  0x73  DW with administrator\u2019s verification  X  O  X    Template management  LT  0x18  List user ID  O  O  O     LTX  0x86  List user ID with extended data transfer protocol  O  O  O     CT  0x19  Check user ID  O  O  O     FP  0x23  Fix all provisional templates  O  O  O     DP  0x24  Delete all provisional templates  O  O  O    Get image and template  RI  0x20  Read image  O  O  O     RIX  0x84  RI with extended data transfer protocol  O  O  O     SI  0x15  Scan image  O  O  O     SIX  0x83  SI with extended data transfer protocol  O  O  O     RT  0x14  Read template  O  O  O     RTX  0x89  RT with extended data transfer protocol  O  O  O     ST  0x21  Scan template  O  O  O     KS  0x35  Scan template with challenge data  O  O  O     KW  0x34  Write encryption key  O  O  O    User memory management  ML  0x31  Get size of user memory  O  O  O     MW  0x32  Write to user memory  O  O  O     MR  0x33  Read from user memory  O  O  O    Time and log management  TW  0x3A  Write current time  X  O  X     TR  0x3B  Read current time  X  O  X     LN  0x3C  Get number of log data  X  O  X     LR  0x3D  Read log data  X  O  X     LD  0x3E  Delete log data  X  O  X     LC  0x3F  Set / Get the custom log field  X  O  X     RCL  0xEC  Read log cache  X  O  X     CCL  0xEB  Clear log cache  X  O  X    Wiegand configuration  WW  0x41  Write Wiegand configuration  X  O  X     WR  0x42  Read Wiegand configuration  X  O  X     WG  0x43  Get Wiegand input  X  O  X     WS  0x44  Set Wiegand output  X  O  X     WM  0x68  Map Wiegand ID to input function  X  O  X     WL  0x69  List Wiegand ID mapping  X  O  X     WC  0x6A  Clear Wiegand ID mapping  X  O  X    Extended Wiegand configuration  WWX  0xC0  Write Wiegand configuration  X  O  X     WRX  0xC1  Read Wiegand configuration  X  O  X     WGX  0xC2  Get Wiegand input  X  O  X     WSX  0xC3  Set Wiegand output  X  O  X     WFW  0xC4  Set alternative value of a field  X  O  X     WFR  0xC5  Get alternative value of a filed  X  O  X     WPW  0xC6  Write Wiegand I/O settings  X  O  X     WPR  0xC7  Read Wiegand I/O settings  X  O  X    Input configuration  IW  0x47  Write input configuration  X  O  X     IR  0x48  Read input configuration  X  O  X     IG  0x49  Get input state  X  O  X    Output configuration  OW  0x4A  Write output configuration  X  O  X     OR  0x4B  Read output configuration  X  O  X     OL  0x4C  Read output configuration list  X  O  X     OS  0x4D  Set output state  X  O  X    GPIO configuration  GW  0x37  Write GPIO configuration  O  X  O     GR  0x36  Read GPIO configuration  O  X  O     GC  0x38  Clear GPIO configuration  O  X  O     GD  0x39  Set default GPIO configuration  O  X  O    Admin level configuration  AW  0x65  Write administration level  O  O  O     AR  0x66  Read administration level  O  O  O     AC  0x67  Clear administration level  O  O  O    Auth. mode configuration  UW  0xA3  Write authentication mode  X  O  X     UR  0xA4  Read authentication mode  X  O  X     UC  0xA5  Reset authentication mode to default  X  O  X     UL  0xA6  List user IDs grouped by authentication mode  X  O  X    Blacklist configuration  ABL  0xF3  Add an ID to blacklist  X  O  X     DBL  0xF4  Delete an ID from blacklist  X  O  X     RBL  0xF5  Read blacklist  X  O  X     CBL  0xF6  Clear blacklist  X  O  X    Entrance limit configuration  WME  0xF0  Write entrance limit  X  O  X     RME  0xF1  Read entrance limit  X  O  X     CME  0xF2  Clear entrance limit  X  O  X    System Parameter  FR  0xFA  Factory reset by erasing system parameter  X  X  O    File System  FF  0xFF  Raw format userdb partition  X  X  O      Contact us  If you need more detail information about this document (UF_Protocol_Manual), please contact at  sales_sol@suprema.co.kr       SFM3000/3500/4000/5000 only\u00a0 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9    SFM3500 only\u00a0 \u21a9 \u21a9 \u21a9 \u21a9    SFM3000/3500/4000/5000 only\u00a0 \u21a9    Reducing template size might affect authentication performance.\u00a0 \u21a9    Since firmware V1.3, the minimum security level of SFM3000/3500 series is changed to 1/10,000.\u00a0 \u21a9 \u21a9 \u21a9 \u21a9    SFM3020-OP, SFM3520-OP, SFM4020-OP, SFM5020-OP only\u00a0 \u21a9    SFM4000 only\u00a0 \u21a9 \u21a9    SFM5060-OH only\u00a0 \u21a9 \u21a9 \u21a9    SFM5500 only\u00a0 \u21a9    SFM60x0 only\u00a0 \u21a9",
            "title": "Command Summary"
        },
        {
            "location": "/sdk/c_cpp/",
            "text": "C/C++\n\u00b6\n\n\n\n\n  \n\n\nDownload the latest version of SDK\n.  \n\n\nSFM SDK library included the structure of directories and files as below.\n\n.\n\u251c\u2500\u2500 doc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK_Manual_v3.3.0.pdf\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_3000IO.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_3500IO.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_API.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_AccessControl.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Bitmap.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Command.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Def.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Delete.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Enroll.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Error.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Identify.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Image.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Log.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Module.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Packet.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Serial.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_SmartCard.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Socket.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_SysParameter.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Template.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Upgrade.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_UserMemory.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Verify.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_WSQ.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Wiegand.h\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Version.h\n\u2514\u2500\u2500 lib\n    \u251c\u2500\u2500 linux\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 libSFM_SDK.so\n    \u2514\u2500\u2500 windows\n        \u251c\u2500\u2500 x64\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 SFM_SDK.dll\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK.lib\n        \u251c\u2500\u2500 x64_ordinal\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 SFM_SDK.dll\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK.lib\n        \u251c\u2500\u2500 x86\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 SFM_SDK.dll\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK.lib\n        \u2514\u2500\u2500 x86_ordinal\n            \u251c\u2500\u2500 SFM_SDK.dll\n            \u2514\u2500\u2500 SFM_SDK.lib\n\n\n\n\n\nNote\n\n\nAll the windows DLL files have the same name and the calling convention is \n_stdcall\n. Please use the proper DLL file for your purpose.",
            "title": "C/C++"
        },
        {
            "location": "/sdk/c_cpp/#cc",
            "text": "Download the latest version of SDK .    SFM SDK library included the structure of directories and files as below. .\n\u251c\u2500\u2500 doc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK_Manual_v3.3.0.pdf\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_3000IO.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_3500IO.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_API.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_AccessControl.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Bitmap.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Command.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Def.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Delete.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Enroll.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Error.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Identify.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Image.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Log.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Module.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Packet.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Serial.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_SmartCard.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Socket.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_SysParameter.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Template.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Upgrade.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_UserMemory.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Verify.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_WSQ.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 UF_Wiegand.h\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Version.h\n\u2514\u2500\u2500 lib\n    \u251c\u2500\u2500 linux\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 libSFM_SDK.so\n    \u2514\u2500\u2500 windows\n        \u251c\u2500\u2500 x64\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 SFM_SDK.dll\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK.lib\n        \u251c\u2500\u2500 x64_ordinal\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 SFM_SDK.dll\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK.lib\n        \u251c\u2500\u2500 x86\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 SFM_SDK.dll\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 SFM_SDK.lib\n        \u2514\u2500\u2500 x86_ordinal\n            \u251c\u2500\u2500 SFM_SDK.dll\n            \u2514\u2500\u2500 SFM_SDK.lib   Note  All the windows DLL files have the same name and the calling convention is  _stdcall . Please use the proper DLL file for your purpose.",
            "title": "C/C++"
        },
        {
            "location": "/sdk/NET/",
            "text": ".NET\n\u00b6\n\n\n\n\n\n\n \n\n\nQuick start\n\u00b6\n\n\nStep 1\n\n\nDownload the latest version of SDK\n.  \n\n\n\n\nThe SDK includes these files\n\n\nSFM_SDK.dll\n is a library file for C/C++.\n\n\nSFM_SDK_NET.dll\n is a native library file for .NET\n\n\nSFM_SDK_NET.XML\n is a file for documentation of .NET library.  \n\n\n\n\nStep 2\n\nCreate a .NET project.\n\n\nStep 3\n\nAdd reference on your project above \nSFM_SDK_NET.dll\n file.\n\n\n\n\n\n\nWarning\n\n\nSFM_SDK_NET.XML\n should be located with \nSFM_SDK_NET.dll\n for correct works of intellisense in microsoft visual sutdio.\n\n\n\n\nStep 4\n\nimport reference.  \n\n\nusing\n \nSuprema.SFM_SDK_NET\n;\n\n\n\n\n\n\nNow, Write your source code using \nSDK Manual\n\n\nStep 5\n\nBuild your program. Then run.\n\n\nExample code\n\u00b6\n\n\nHow to init serial COM port?\n\u00b6\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nSystem.Collections.Generic\n;\n\n\nusing\n \nSystem.Linq\n;\n\n\nusing\n \nSystem.Text\n;\n\n\nusing\n \nSystem.Threading.Tasks\n;\n\n\nusing\n \nSuprema.SFM_SDK_NET\n;\n\n\n\nnamespace\n \nSample\n\n\n{\n\n\n    \nclass\n \nProgram\n\n\n    \n{\n\n\n        \nstatic\n \nvoid\n \nMain\n(\nstring\n[]\n \nargs\n)\n\n\n        \n{\n\n\n            \nSFM_SDK_NET\n \nSFM\n \n=\n \nnew\n \nSFM_SDK_NET\n();\n\n\n            \nUF_RET_CODE\n \nresult\n \n=\n \nnew\n \nUF_RET_CODE\n();\n\n\n            \nresult\n \n=\n \nSFM\n.\nUF_InitCommPort\n(\n\"COM3\"\n,\n \n19200\n,\n \nfalse\n);\n\n\n            \nConsole\n.\nWriteLine\n(\nresult\n.\nToString\n());\n\n\n        \n}\n\n\n    \n}\n\n\n}",
            "title": ".NET"
        },
        {
            "location": "/sdk/NET/#net",
            "text": "",
            "title": ".NET"
        },
        {
            "location": "/sdk/NET/#quick-start",
            "text": "Step 1  Download the latest version of SDK .     The SDK includes these files  SFM_SDK.dll  is a library file for C/C++.  SFM_SDK_NET.dll  is a native library file for .NET  SFM_SDK_NET.XML  is a file for documentation of .NET library.     Step 2 \nCreate a .NET project.  Step 3 \nAdd reference on your project above  SFM_SDK_NET.dll  file.    Warning  SFM_SDK_NET.XML  should be located with  SFM_SDK_NET.dll  for correct works of intellisense in microsoft visual sutdio.   Step 4 \nimport reference.    using   Suprema.SFM_SDK_NET ;    Now, Write your source code using  SDK Manual  Step 5 \nBuild your program. Then run.",
            "title": "Quick start"
        },
        {
            "location": "/sdk/NET/#example-code",
            "text": "",
            "title": "Example code"
        },
        {
            "location": "/sdk/NET/#how-to-init-serial-com-port",
            "text": "using   System ;  using   System.Collections.Generic ;  using   System.Linq ;  using   System.Text ;  using   System.Threading.Tasks ;  using   Suprema.SFM_SDK_NET ;  namespace   Sample  {       class   Program       {           static   void   Main ( string []   args )           {               SFM_SDK_NET   SFM   =   new   SFM_SDK_NET ();               UF_RET_CODE   result   =   new   UF_RET_CODE ();               result   =   SFM . UF_InitCommPort ( \"COM3\" ,   19200 ,   false );               Console . WriteLine ( result . ToString ());           }       }  }",
            "title": "How to init serial COM port?"
        },
        {
            "location": "/sdk/android/",
            "text": "Android\n\u00b6\n\n\n\n\n\n\n\n\n\n\nSFM SDK for Android is a library wrapping a Java library with SFM SDK based on C/C++ using JNI. You can easily use the SFM SDK for Android using JitPack. Also, you can download the source code of the SFM SDK for Android on our Github repository. \n\n\nMeanwhile, some functions are not supported. If you want to use that of functions, please modify the source code. And, If you want to share your modified codes, we are always welcome to your contributions.\n\n\nRelease notes\n\u00b6\n\n\nv0.6.0 - November 16, 2021\n\u00b6\n\n\n\n- SFM SDK version has been updated. \n  - Added secure packet protocol APIs.\n  - Added key management APIs.\n  - See details in \nSFM SDK Manual v3.3.0\n\n- Firmware version information has been added.   \n\n\nv0.5.2 - March 31, 2020\n\u00b6\n\n\n\n- Minor fix. \n\n\nv0.5.1 - March 17, 2020\n\u00b6\n\n\n\n- UART has become more stable.\nThere was a problem that the UART connection is disconnected with an error message of \nUF_ERR_READ_SERIAL_TIMEOUT\n when you receive data from the SFM on the Android app. This problem has been resolved at this release. \n\n\nv0.5.0 - March 10, 2020\n\u00b6\n\n\n\n- UART is supported for rooted Android devices.\n\n- Added native callback functions in JNI for using SFM SDK.  \n\n\nv0.4.0 - Feburary 13, 2020\n\u00b6\n\n\n\n\nNew SFM SDK for Android has been released. \nFrom now on, you can easily use the SFM SDK for Android using JitPack. Or, you can download the SFM SDK for android manually in Github repository\n\n\nhttps://github.com/supremainc/sfm-sdk-android\n\n\n\n\nUsage\n\u00b6\n\n\nInstallation\n\u00b6\n\n\nHow to use using JitPack\n\u00b6\n\n\nTo get a Git project into your build:\n\n\nStep 1.\n Add the JitPack repository to your build file\n\n\nAdd it in your root build.gradle at the end of repositories. (\n/your_project_root_path/build.gradle\n)\n\n\nallprojects {\n    repositories {\n    ...\n    maven { url 'https://jitpack.io' }\n    }\n}\n\n\n\nStep 2.\n Add the dependency in your app build.gradle (\n/your_project_root_path/app/build.gradle\n)\n\n\ndependencies {\n    ...\n    implementation 'com.github.supremainc:sfm-sdk-android:0.5.0'\n    ...\n}\n\n\n\nIf you are using the Java8, you need to insert the below over the dependency.\n\n\ncompileOptions{\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n}\n\ndependencies {\n    ...\n    implementation 'com.github.supremainc:sfm-sdk-android:0.5.0'\n    ...\n}\n\n\n\nStep 3.\n Include scripts for using the USB service and changing user-permission to access the storage in your device.\n\n\nThe SFM SDK for Android includes USB Library by default. You don't need to implement codes related to the USB controls. The USB Library\nis used from \nhttps://github.com/felHR85/UsbSerial\n in the SFM SDK for Android. Also, it's version is \nv6.1.0\n.\n\n\nBasically, you should insert the below script to \n/your_project_root_path/app/src/main/AndroidManifest.xml\n for proper working with the USB Library.\n\n\n\n\n    \n<service\n\n        \nandroid:name=\n\"com.supremainc.sfm_sdk.UsbService\"\n\n        \nandroid:enabled=\n\"true\"\n>\n\n    \n</service>\n\n\n\n\nAlso, you need to insert the below script for using storage in your device.\n\n\n\n\n    \n<uses-permission\n \nandroid:name=\n\"android.permission.READ_EXTERNAL_STORAGE\"\n></uses-permission>\n\n    \n<uses-permission\n \nandroid:name=\n\"android.permission.WRITE_EXTERNAL_STORAGE\"\n></uses-permission>\n   \n\n\n\nPlease refer to \nhttps://github.com/supremainc/sfm-sdk-android/blob/master/app/src/main/AndroidManifest.xml\n\n\nAndroidManifest.xml\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!--\n\n\n  ~ Copyright (c) 2001 - 2019. Suprema Inc. All rights reserved.\n\n\n  ~ Licensed under the MIT license. See LICENSE file in the project root for details.\n\n\n  -->\n\n\n\n<manifest\n \nxmlns:android=\n\"http://schemas.android.com/apk/res/android\"\n\n    \npackage=\n\"com.supremainc.sfm_sdk_android\"\n>\n\n\n    \n<uses-feature\n \nandroid:name=\n\"android.hardware.usb.host\"\n\n        \nandroid:required=\n\"true\"\n/>\n\n\n    \n<application\n\n        \nandroid:allowBackup=\n\"true\"\n\n        \nandroid:icon=\n\"@mipmap/ic_launcher\"\n\n        \nandroid:label=\n\"@string/app_name\"\n\n        \nandroid:roundIcon=\n\"@mipmap/ic_launcher_round\"\n\n        \nandroid:supportsRtl=\n\"true\"\n\n        \nandroid:theme=\n\"@style/AppTheme\"\n>\n\n        \n<activity\n \nandroid:name=\n\".MainActivity\"\n>\n\n            \n<intent-filter>\n\n                \n<action\n \nandroid:name=\n\"android.intent.action.MAIN\"\n \n/>\n\n\n                \n<category\n \nandroid:name=\n\"android.intent.category.LAUNCHER\"\n \n/>\n\n            \n</intent-filter>\n\n        \n</activity>\n\n\n        \n<service\n\n            \nandroid:name=\n\"com.supremainc.sfm_sdk.UsbService\"\n\n            \nandroid:enabled=\n\"true\"\n>\n\n        \n</service>\n\n\n    \n</application>\n\n\n    \n<uses-permission\n \nandroid:name=\n\"android.permission.READ_EXTERNAL_STORAGE\"\n></uses-permission>\n\n    \n<uses-permission\n \nandroid:name=\n\"android.permission.WRITE_EXTERNAL_STORAGE\"\n></uses-permission>\n\n\n</manifest>\n\n\n\n\nHow to upgrade using JitPack\n\u00b6\n\n\nTo upgrade SFM SDK for Android, change the JitPack version in your root build.gradle at the end of repositories. (\n/your_project_root_path/build.gradle\n)\n\n\nIn the root build.gradle file, you should just change the JitPack version from \n0.5.0\n to \nJitPack version to upgrade\n.\n\ndependencies {\n    ...\n    implementation 'com.github.supremainc:sfm-sdk-android:0.5.0'\n    ...\n}\n\n\n\n\n\n[DEPRECATED]\n\u00b6\n\n\nSFM SDK for Android (beta)\n\u00b6\n\n\n\n\nInfo\n\n\nThe previous version of the SFM SDK for Android (beta) was deprecated.\nthe repository moved to \nhttps://github.com/supremainc/sfm-sdk-android/tree/sfm-sdk-android-beta\n\n\n\n\nYou have to connect the SDK callback function to the communication function on Android for using android SFM_SDK.(See the below for details). Android sfm-sdk was made by C language and compiled using NDK. We currently provide SFM_SDK beta version 1.0.\n\n\n\n\nTip\n\n\nYou can download all about android SFM_SDK(library, example project, document) through below github URL.\n\nhttps://github.com/supremainc/sfm-sdk-android\n\n\n\n\nQuick start\n\u00b6\n\n\nStep 1\n\nDownload these files.\n\n\narm64-v8a_libSFM_SDK_android.so\n\n\narmeabi-v7a_libSFM_SDK_android.so\n\n\narmeabi_libSFM_SDK_android.so\n\n\nJNI_Header.zip\n\n\nUnifingerUI for Android.docx\n \n\n\n\n\nNote\n\n\narm64-v8a_libSFM_SDK_android.so\n is a library file for 64bits arm processor.\n\n\narmeabi-v7a_libSFM_SDK_android.so\n is a library file for arm processor V7 or more up version.\n\n\narmeabi_libSFM_SDK_android.so\n is a library file for arm processor V5 or V6.\n\n\nJNI_Header.zip\n is a header files for library.\n\n\nUnifingerUI for Android.docx\n is a file for documentation of android library.  \n\n\n\n\nStep 2\n\nCreate a android project.\n\n\nStep 3\n\nAdd library files on your project.\n\n\n\n\n\n\nNote\n\n\njnilib folder does not exist. Just make it.(you can use any name).\n\n\n\n\nStep 4\n\nUnzip JNI_Header.zip. And add header files in jni folder.\n\n\n\n\nStep 5\n\nImplement write call back function in java.\n\n\nprivate\n \nint\n \nSendPacketCallback\n(\nString\n \nvar\n)\nthrows\n \nInterruptedException\n,\n \nExecutionException\n,\n \nTimeoutException\n{\n\n    \nint\n \nreturnSize\n \n=\n \nSendPacket\n(\nvar\n);\n\n    \nreturn\n \nreturnSize\n;\n\n\n}\n\n\n\npublic\n \nint\n \nSendPacket\n(\nString\n \nvar\n)\n \nthrows\n \nInterruptedException\n,\n \nExecutionException\n,\n \nTimeoutException\n \n{\n\n    \nint\n \nreturnSize\n \n=\n0\n;\n\n    \nbyte\n[]\n \nsendPacket\n \n=\n \nnew\n \nBigInteger\n(\nvar\n,\n16\n).\ntoByteArray\n();\n\n    \ntry\n \n{\n\n        \nmOutputStream\n.\nwrite\n(\nsendPacket\n);\n\n    \n}\n \ncatch\n \n(\nIOException\n \ne\n)\n \n{\n\n        \ne\n.\nprintStackTrace\n();\n\n    \n}\n\n    \nreturnSize\n \n=\n \nPACKET_INFO\n.\nUF_PACKET_LEN\n;\n\n\n    \nreturn\n \nreturnSize\n;\n\n\n}\n\n\n\n\nStep 6\n\nImplement read call back function in java.\n\n\nprivate\n \nint\n \nReadPacketCallback\n(\nint\n \nsize\n,\n \nbyte\n[]\n \nread_buffer\n)\n \nthrows\n \nInterruptedException\n,\n \nTimeoutException\n,\n \nExecutionException\n \n{\n\n    \nint\n \nreadSize\n \n=\n \nm_SerialConnect\n.\nReadPacket\n(\nsize\n,\nread_buffer\n);\n\n\n    \nreturn\n \nreadSize\n;\n\n\n}\n\n\n\npublic\n \nint\n \nReadPacket\n(\nint\n \nsize\n,\n \nbyte\n[]\n \nread_buffer\n)\n \nthrows\n \nInterruptedException\n,\n \nExecutionException\n,\n \nTimeoutException\n \n{\n\n    \nlong\n \nlnStart\n \n=\n0\n,\n \nlnEnd\n \n=\n0\n;\n\n    \nint\n \nnTime_out\n \n=\n \n8000\n;\n\n    \nint\n \nreturnSize\n \n=\n \n0\n;\n\n    \nm_nRead_len\n \n=\n \n0\n;\n\n\n    \nlnStart\n \n=\n \nSystemClock\n.\ncurrentThreadTimeMillis\n();\n\n\n    \ndo\n \n{\n\n        \ntempBuffer\n \n=\n \nnew\n \nbyte\n[\nsize\n \n-\n \nreturnSize\n]\n;\n\n\n        \nFuture\n<\nInteger\n>\n \nfuture\n \n=\n \nexecutor\n.\nsubmit\n(\nreadTask\n);\n\n        \nm_nRead_len\n \n=\n \nfuture\n.\nget\n(\nnTime_out\n,\n \nTimeUnit\n.\nMILLISECONDS\n);\n\n\n        \nif\n \n(\nm_nRead_len\n \n>\n \n0\n)\n \n{\n\n            \nSystem\n.\narraycopy\n(\ntempBuffer\n,\n \n0\n,\n \nread_buffer\n,\n \nreturnSize\n,\n \nm_nRead_len\n);\n\n            \nreturnSize\n \n+=\n \nm_nRead_len\n;\n\n        \n}\n\n\n        \nlnEnd\n \n=\n \nSystemClock\n.\ncurrentThreadTimeMillis\n();\n\n    \n}\n \nwhile\n \n(\nreturnSize\n \n<\n \nsize\n \n&&\n \n((\nlnEnd\n \n-\n \nlnStart\n)\n \n<\n \nnTime_out\n));\n\n\n\n}\n\n\n\nCallable\n<\nInteger\n>\n \nreadTask\n \n=\n \nnew\n \nCallable\n<\nInteger\n>\n()\n \n{\n\n    \n@Override\n\n    \npublic\n \nInteger\n \ncall\n()\n \nthrows\n \nException\n \n{\n\n        \nint\n \nretSize\n \n=\n \n0\n;\n\n\n        \ndo\n \n{\n\n            \nretSize\n \n=\n \nmInputStream\n.\nread\n(\ntempBuffer\n);\n\n        \n}\n \nwhile\n \n(\nretSize\n \n<=\n \n0\n);\n\n\n        \nreturn\n \nretSize\n;\n\n    \n}\n\n\n};\n\n\n\n\n\n\nTip\n\n\nWrite/Read callback funciotn is used in SFM_SDK. It means SFM_SDK calls these function to communication with module.\nSo you have to create proper Write/Read callback funciotn(Keep parameter type and return type). \nAnd then connect these functions using setting functions like step 7.\n\n\n\n\nStep 7\n\nConnect to communication function(write/read callback) with SDK using JNI.\n\n\nSetCommandClassName\n(\n\"com/suprema/www/unifingerui/CommandCall\"\n);\n\n\nSetReadCallbackFunctionName\n(\n\"ReadPacketCallbakc\"\n);\n\n\nSetWriteCallbackFunctionName\n(\n\"SendPacketCallback\"\n);\n\n\n\n\n\n\nNote\n\n\nSetCommandClassName()\n's parameter is JNI class name that is made by you. \n\n\n\n\nNow, You can use SFM library in JNI class that is made by you.\n\n\nStep 8\n\nBuild your program. Then run.\n\n\n\n\nNote\n\n\nIf you want more detail explanation to use library and work environment or about license refer to documentation\n\n\n\n\nExample code\n\u00b6\n\n\nHow to call identify function?\n\u00b6\n\n\nJNIEXPORT\n \njint\n \nJNICALL\n \nJava_com_suprema_www_unifingerui_Command_UF_1Identify\n  \n(\nJNIEnv\n \n*\n \nenv\n,\n \njobject\n \nobj\n)\n\n\n{\n\n\n    \ngobj\n=\nobj\n;\n\n\n    \nint\n \nresult\n=\n0\n;\n\n\n    \nunsigned\n \nint\n \nuserID\n=\n0\n;\n\n\n    \nunsigned\n \nchar\n \nsubID\n=\n0\n;\n\n\n    \nresult\n=\nUF_Identify\n(\n&\nuserID\n,\n&\nsubID\n);\n\n\n\n    \nif\n(\nresult\n!=\nUF_RET_SUCCESS\n)\n\n\n    \n{\n\n\n        \nUpdate_UI_Result\n(\nresult\n);\n\n\n        \nreturn\n \n-1\n;\n\n\n    \n}\n\n\n\n    \nUpdate_UI_Result\n(\nuserID\n);\n\n\n\n    \nreturn\n \nresult\n;\n\n\n}",
            "title": "Android"
        },
        {
            "location": "/sdk/android/#android",
            "text": "SFM SDK for Android is a library wrapping a Java library with SFM SDK based on C/C++ using JNI. You can easily use the SFM SDK for Android using JitPack. Also, you can download the source code of the SFM SDK for Android on our Github repository.   Meanwhile, some functions are not supported. If you want to use that of functions, please modify the source code. And, If you want to share your modified codes, we are always welcome to your contributions.",
            "title": "Android"
        },
        {
            "location": "/sdk/android/#release-notes",
            "text": "",
            "title": "Release notes"
        },
        {
            "location": "/sdk/android/#v060-november-16-2021",
            "text": "- SFM SDK version has been updated. \n  - Added secure packet protocol APIs.\n  - Added key management APIs.\n  - See details in  SFM SDK Manual v3.3.0 \n- Firmware version information has been added.",
            "title": "v0.6.0 - November 16, 2021"
        },
        {
            "location": "/sdk/android/#v052-march-31-2020",
            "text": "- Minor fix.",
            "title": "v0.5.2 - March 31, 2020"
        },
        {
            "location": "/sdk/android/#v051-march-17-2020",
            "text": "- UART has become more stable.\nThere was a problem that the UART connection is disconnected with an error message of  UF_ERR_READ_SERIAL_TIMEOUT  when you receive data from the SFM on the Android app. This problem has been resolved at this release.",
            "title": "v0.5.1 - March 17, 2020"
        },
        {
            "location": "/sdk/android/#v050-march-10-2020",
            "text": "- UART is supported for rooted Android devices. \n- Added native callback functions in JNI for using SFM SDK.",
            "title": "v0.5.0 - March 10, 2020"
        },
        {
            "location": "/sdk/android/#v040-feburary-13-2020",
            "text": "New SFM SDK for Android has been released. \nFrom now on, you can easily use the SFM SDK for Android using JitPack. Or, you can download the SFM SDK for android manually in Github repository  https://github.com/supremainc/sfm-sdk-android",
            "title": "v0.4.0 - Feburary 13, 2020"
        },
        {
            "location": "/sdk/android/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/sdk/android/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/sdk/android/#how-to-use-using-jitpack",
            "text": "To get a Git project into your build:  Step 1.  Add the JitPack repository to your build file  Add it in your root build.gradle at the end of repositories. ( /your_project_root_path/build.gradle )  allprojects {\n    repositories {\n    ...\n    maven { url 'https://jitpack.io' }\n    }\n}  Step 2.  Add the dependency in your app build.gradle ( /your_project_root_path/app/build.gradle )  dependencies {\n    ...\n    implementation 'com.github.supremainc:sfm-sdk-android:0.5.0'\n    ...\n}  If you are using the Java8, you need to insert the below over the dependency.  compileOptions{\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n}\n\ndependencies {\n    ...\n    implementation 'com.github.supremainc:sfm-sdk-android:0.5.0'\n    ...\n}  Step 3.  Include scripts for using the USB service and changing user-permission to access the storage in your device.  The SFM SDK for Android includes USB Library by default. You don't need to implement codes related to the USB controls. The USB Library\nis used from  https://github.com/felHR85/UsbSerial  in the SFM SDK for Android. Also, it's version is  v6.1.0 .  Basically, you should insert the below script to  /your_project_root_path/app/src/main/AndroidManifest.xml  for proper working with the USB Library.        <service \n         android:name= \"com.supremainc.sfm_sdk.UsbService\" \n         android:enabled= \"true\" > \n     </service>   Also, you need to insert the below script for using storage in your device.        <uses-permission   android:name= \"android.permission.READ_EXTERNAL_STORAGE\" ></uses-permission> \n     <uses-permission   android:name= \"android.permission.WRITE_EXTERNAL_STORAGE\" ></uses-permission>      Please refer to  https://github.com/supremainc/sfm-sdk-android/blob/master/app/src/main/AndroidManifest.xml  AndroidManifest.xml  <?xml version=\"1.0\" encoding=\"utf-8\"?> <!--    ~ Copyright (c) 2001 - 2019. Suprema Inc. All rights reserved.    ~ Licensed under the MIT license. See LICENSE file in the project root for details.    -->  <manifest   xmlns:android= \"http://schemas.android.com/apk/res/android\" \n     package= \"com.supremainc.sfm_sdk_android\" > \n\n     <uses-feature   android:name= \"android.hardware.usb.host\" \n         android:required= \"true\" /> \n\n     <application \n         android:allowBackup= \"true\" \n         android:icon= \"@mipmap/ic_launcher\" \n         android:label= \"@string/app_name\" \n         android:roundIcon= \"@mipmap/ic_launcher_round\" \n         android:supportsRtl= \"true\" \n         android:theme= \"@style/AppTheme\" > \n         <activity   android:name= \".MainActivity\" > \n             <intent-filter> \n                 <action   android:name= \"android.intent.action.MAIN\"   /> \n\n                 <category   android:name= \"android.intent.category.LAUNCHER\"   /> \n             </intent-filter> \n         </activity> \n\n         <service \n             android:name= \"com.supremainc.sfm_sdk.UsbService\" \n             android:enabled= \"true\" > \n         </service> \n\n     </application> \n\n     <uses-permission   android:name= \"android.permission.READ_EXTERNAL_STORAGE\" ></uses-permission> \n     <uses-permission   android:name= \"android.permission.WRITE_EXTERNAL_STORAGE\" ></uses-permission>  </manifest>",
            "title": "How to use using JitPack"
        },
        {
            "location": "/sdk/android/#how-to-upgrade-using-jitpack",
            "text": "To upgrade SFM SDK for Android, change the JitPack version in your root build.gradle at the end of repositories. ( /your_project_root_path/build.gradle )  In the root build.gradle file, you should just change the JitPack version from  0.5.0  to  JitPack version to upgrade . dependencies {\n    ...\n    implementation 'com.github.supremainc:sfm-sdk-android:0.5.0'\n    ...\n}",
            "title": "How to upgrade using JitPack"
        },
        {
            "location": "/sdk/android/#deprecated",
            "text": "",
            "title": "[DEPRECATED]"
        },
        {
            "location": "/sdk/android/#sfm-sdk-for-android-beta",
            "text": "Info  The previous version of the SFM SDK for Android (beta) was deprecated.\nthe repository moved to  https://github.com/supremainc/sfm-sdk-android/tree/sfm-sdk-android-beta   You have to connect the SDK callback function to the communication function on Android for using android SFM_SDK.(See the below for details). Android sfm-sdk was made by C language and compiled using NDK. We currently provide SFM_SDK beta version 1.0.   Tip  You can download all about android SFM_SDK(library, example project, document) through below github URL. https://github.com/supremainc/sfm-sdk-android",
            "title": "SFM SDK for Android (beta)"
        },
        {
            "location": "/sdk/android/#quick-start",
            "text": "Step 1 \nDownload these files.  arm64-v8a_libSFM_SDK_android.so  armeabi-v7a_libSFM_SDK_android.so  armeabi_libSFM_SDK_android.so  JNI_Header.zip  UnifingerUI for Android.docx     Note  arm64-v8a_libSFM_SDK_android.so  is a library file for 64bits arm processor.  armeabi-v7a_libSFM_SDK_android.so  is a library file for arm processor V7 or more up version.  armeabi_libSFM_SDK_android.so  is a library file for arm processor V5 or V6.  JNI_Header.zip  is a header files for library.  UnifingerUI for Android.docx  is a file for documentation of android library.     Step 2 \nCreate a android project.  Step 3 \nAdd library files on your project.    Note  jnilib folder does not exist. Just make it.(you can use any name).   Step 4 \nUnzip JNI_Header.zip. And add header files in jni folder.   Step 5 \nImplement write call back function in java.  private   int   SendPacketCallback ( String   var ) throws   InterruptedException ,   ExecutionException ,   TimeoutException { \n     int   returnSize   =   SendPacket ( var ); \n     return   returnSize ;  }  public   int   SendPacket ( String   var )   throws   InterruptedException ,   ExecutionException ,   TimeoutException   { \n     int   returnSize   = 0 ; \n     byte []   sendPacket   =   new   BigInteger ( var , 16 ). toByteArray (); \n     try   { \n         mOutputStream . write ( sendPacket ); \n     }   catch   ( IOException   e )   { \n         e . printStackTrace (); \n     } \n     returnSize   =   PACKET_INFO . UF_PACKET_LEN ; \n\n     return   returnSize ;  }   Step 6 \nImplement read call back function in java.  private   int   ReadPacketCallback ( int   size ,   byte []   read_buffer )   throws   InterruptedException ,   TimeoutException ,   ExecutionException   { \n     int   readSize   =   m_SerialConnect . ReadPacket ( size , read_buffer ); \n\n     return   readSize ;  }  public   int   ReadPacket ( int   size ,   byte []   read_buffer )   throws   InterruptedException ,   ExecutionException ,   TimeoutException   { \n     long   lnStart   = 0 ,   lnEnd   = 0 ; \n     int   nTime_out   =   8000 ; \n     int   returnSize   =   0 ; \n     m_nRead_len   =   0 ; \n\n     lnStart   =   SystemClock . currentThreadTimeMillis (); \n\n     do   { \n         tempBuffer   =   new   byte [ size   -   returnSize ] ; \n\n         Future < Integer >   future   =   executor . submit ( readTask ); \n         m_nRead_len   =   future . get ( nTime_out ,   TimeUnit . MILLISECONDS ); \n\n         if   ( m_nRead_len   >   0 )   { \n             System . arraycopy ( tempBuffer ,   0 ,   read_buffer ,   returnSize ,   m_nRead_len ); \n             returnSize   +=   m_nRead_len ; \n         } \n\n         lnEnd   =   SystemClock . currentThreadTimeMillis (); \n     }   while   ( returnSize   <   size   &&   (( lnEnd   -   lnStart )   <   nTime_out ));  }  Callable < Integer >   readTask   =   new   Callable < Integer > ()   { \n     @Override \n     public   Integer   call ()   throws   Exception   { \n         int   retSize   =   0 ; \n\n         do   { \n             retSize   =   mInputStream . read ( tempBuffer ); \n         }   while   ( retSize   <=   0 ); \n\n         return   retSize ; \n     }  };    Tip  Write/Read callback funciotn is used in SFM_SDK. It means SFM_SDK calls these function to communication with module.\nSo you have to create proper Write/Read callback funciotn(Keep parameter type and return type). \nAnd then connect these functions using setting functions like step 7.   Step 7 \nConnect to communication function(write/read callback) with SDK using JNI.  SetCommandClassName ( \"com/suprema/www/unifingerui/CommandCall\" );  SetReadCallbackFunctionName ( \"ReadPacketCallbakc\" );  SetWriteCallbackFunctionName ( \"SendPacketCallback\" );    Note  SetCommandClassName() 's parameter is JNI class name that is made by you.    Now, You can use SFM library in JNI class that is made by you.  Step 8 \nBuild your program. Then run.   Note  If you want more detail explanation to use library and work environment or about license refer to documentation",
            "title": "Quick start"
        },
        {
            "location": "/sdk/android/#example-code",
            "text": "",
            "title": "Example code"
        },
        {
            "location": "/sdk/android/#how-to-call-identify-function",
            "text": "JNIEXPORT   jint   JNICALL   Java_com_suprema_www_unifingerui_Command_UF_1Identify    ( JNIEnv   *   env ,   jobject   obj )  {       gobj = obj ;       int   result = 0 ;       unsigned   int   userID = 0 ;       unsigned   char   subID = 0 ;       result = UF_Identify ( & userID , & subID );       if ( result != UF_RET_SUCCESS )       {           Update_UI_Result ( result );           return   -1 ;       }       Update_UI_Result ( userID );       return   result ;  }",
            "title": "How to call identify function?"
        },
        {
            "location": "/sdk/python/",
            "text": "python\n\u00b6\n\n\n\n\n\n\n\n\n\n\nQuick start\n\u00b6\n\n\nSFM SDK for python is called as \npysfm\n. Also, it is hosted on \nhttps://pypi.python.org/\n.\nThe pysfm is programmed by pure python source code. So it is basically works based on cross-platform SDK. \nIt is tested on Windows, Linux and Mac OSX.\n\n\nInstallation\n\u00b6\n\n\nInstall the latest version of \npysfm\n with \npip\n:\n\n\npip install pysfm\n\n\n\n\nUpgrading\n\u00b6\n\n\nTo upgrade \npysfm\n to the latest version, use \npip\n:\n\n\npip install --upgrade pysfm\n\n\n\n\nExamples\n\u00b6\n\n\nSome examples are shared at \nhttps://github.com/supremainc/sfm-sdk-python\n\n\nFor detailed instructions, see the \ntutorial of pysfm",
            "title": "python"
        },
        {
            "location": "/sdk/python/#python",
            "text": "",
            "title": "python"
        },
        {
            "location": "/sdk/python/#quick-start",
            "text": "SFM SDK for python is called as  pysfm . Also, it is hosted on  https://pypi.python.org/ .\nThe pysfm is programmed by pure python source code. So it is basically works based on cross-platform SDK. \nIt is tested on Windows, Linux and Mac OSX.",
            "title": "Quick start"
        },
        {
            "location": "/sdk/python/#installation",
            "text": "Install the latest version of  pysfm  with  pip :  pip install pysfm",
            "title": "Installation"
        },
        {
            "location": "/sdk/python/#upgrading",
            "text": "To upgrade  pysfm  to the latest version, use  pip :  pip install --upgrade pysfm",
            "title": "Upgrading"
        },
        {
            "location": "/sdk/python/#examples",
            "text": "Some examples are shared at  https://github.com/supremainc/sfm-sdk-python  For detailed instructions, see the  tutorial of pysfm",
            "title": "Examples"
        },
        {
            "location": "/sdk/sdk-license-agreement/",
            "text": "SDK LICENSE AGREEMENT\n\u00b6\n\n\nThis License Agreement forms a legally binding contract between you and [Suprema Inc.] in relation to your use of the Software Development Kit. \n\n\n1  Definitions\n\u00b6\n\n\n1.1 \u201c[SUPREMA]\u201d or \u201cWe\u201d means [Suprema Inc.], organized under the laws of the Republic of Korea, and operating under the laws of the Republic of Korea with principal place of business at [17F-5, Parkview Office Tower, 248, Jeongjail-ro, Seongnam-si, Gyeonggi-do, 13554].\n\n1.2 \u201cSDK\u201d means the [SFM] Software Development Kit that includes software files, documentation, software code, other related items, and any modified versions or upgrades thereof.  \n\n\n2  Accepting this License Agreement\n\u00b6\n\n\n2.1 In order to use the SDK, you must first agree to this License Agreement.\n\n2.2 BY INSTALLING, ACTIVATING, ACCESSING OR OTHERWISE USING THE SDK, YOU HEREBY AGREE TO THIS LICENSE AGREEMENT. IF YOU DO NOT AGREE TO THE TERMS OF THIS LICENSE AGREEMENT, DO NOT INSTALL, ACTIVATE, ACCESS OR USE THE SDK.\n\n2.3 By accepting this License Agreement, you represent and warrant that you have full legal authority to bind yourself or your entity to this License Agreement.  \n\n\n3  Grant of License; Reservation of Rights\n\u00b6\n\n\n3.1 Subject to the terms of this License Agreement, we hereby grant you a limited, non-exclusive, and non-transferable, and worldwide license to use the SDK solely to develop application programs designed to function with our products.\n\n3.2 You agree that we or third parties own all legal right, title and interest in or to the SDK, including any Intellectual Property Rights that subsist in the SDK. \"Intellectual Property Rights\" means any and all rights under patent law, copyright law, trade secret law, trademark law, and any and all other proprietary rights.  We reserve all rights not expressly granted to you under this License Agreement.\n\n3.3 You may not use the SDK for any purpose not expressly permitted by this License Agreement. Except to the extent required by applicable third party licenses, you may not copy (except for backup purposes), modify, adapt, redistribute, decompile, reverse engineer, disassemble, or create derivative works of the SDK or any part of the SDK.\n\n3.4 Use, reproduction and distribution of components of the SDK licensed under an open source software license are governed solely by the terms of that open source software license and not this License Agreement.\n\n3.5 You agree that the form and nature of the SDK may change without prior notice to you and that future versions of the SDK may be incompatible with applications developed on previous versions of the SDK. You agree that we may stop (permanently or temporarily) providing the SDK (or any features within the SDK) to you or to users generally at our sole discretion, without prior notice to you.\n\n3.6 Nothing in this License Agreement gives you a right to use any of our trade names, trademarks, service marks, logos, domain names, or other distinctive brand features.\n\n3.7 You agree that you will not remove, obscure, or alter any proprietary rights notices (including copyright and trademark notices) that may be affixed to or contained within the SDK.  \n\n\n4  Your Responsibility\n\u00b6\n\n\n4.1 You agree to use the SDK only for purposes that are permitted by this License Agreement and not to use the SDK in any manner unlawful or unethical under any applicable law, regulation or generally accepted practices or guidelines in the relevant jurisdictions.\n\n4.2 You agree that if you use the SDK to develop applications for general public users, you will protect the privacy and legal rights of those users. If the users provide you with any personal data, you must process such data as required by applicable data protection laws or related policies.\n\n4.3 You agree that you are solely responsible for any breach of your obligations under this License Agreement, any applicable third party terms and conditions, or any applicable law or regulation, and for the consequences (including any loss or damage which we or any third party may suffer) of any such breach.  \n\n\n5  Privacy and Information\n\u00b6\n\n\n5.1 In order to continually innovate and improve the SDK, we may collect certain usage statistics from the software including but not limited to a unique identifier, associated IP address, version number of the software, and information on which tools and/or services in the SDK are being used and how they are being used.\n\n5.2 The data collected is examined in the aggregate to improve the SDK and is maintained in accordance with our Privacy Policy.\n\n5.3 Anonymized and aggregated sets of the data may be shared with our partners to improve the SDK.  \n\n\n6  Third Party Applications\n\u00b6\n\n\n6.1 If you use the SDK to run applications developed by a third party or that access data, content or resources provided by a third party (\u201cThird Party Applications\u201d), you agree that we are not liable for any loss or damage that you may experience as a result of the use or access of any of those Third Party Applications.\n\n6.2 You should be aware the Third Party Applications may be protected by intellectual property rights which are owned by the relevant third parties. You may not modify, rent, lease, loan, sell, distribute or create derivative works based on these data, content, or resources (either in whole or in part) unless you have been specifically given permission to do so by the relevant parties.\n\n6.3 You acknowledge that your use of such Third Party Applications may be subject to separate terms between you and the relevant third party. In that case, this License Agreement does not affect your legal relationship with the third party.  \n\n\n7  Use of APIs\n\u00b6\n\n\n7.1 If you use any API to retrieve data from us, you acknowledge that the data may be protected by intellectual property rights which are owned by us or those parties that provide the data (or by other individuals or entities on their behalf). Your use of any such API may be subject to separate terms and conditions. You may not modify, rent, lease, loan, sell, distribute or create derivative works based on this data (either in whole or in part) unless allowed by the relevant terms and conditions.  \n\n\n8  Term; Termination\n\u00b6\n\n\n8.1 This License Agreement is effective until terminated.\n\n8.2 If you want to terminate this License Agreement, you may do so by ceasing your use of the SDK.\n\n8.3 We may terminate this License Agreement at any time if you fail to comply with any term herein or at our sole discretion.\n\n8.4 Upon termination, you agree to remove all items in the SDK and discontinue the use of the items.  \n\n\n9  DISCLAIMER OF WARRANTIES\n\u00b6\n\n\n9.1 YOU EXPRESSLY UNDERSTAND AND AGREE THAT YOUR USE OF THE SDK IS AT YOUR SOLE RISK AND THAT THE SDK IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND FROM US.\n\n9.2 YOUR USE OF THE SDK AND ANY MATERIAL DOWNLOADED OR OTHERWISE OBTAINED THROUGH THE USE OF THE SDK IS AT YOUR OWN DISCRETION AND RISK AND YOU ARE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR COMPUTER SYSTEM OR OTHER DEVICE OR LOSS OF DATA THAT RESULTS FROM SUCH USE.\n\n9.3 WE FURTHER EXPRESSLY DISCLAIMS ALL WARRANTIES AND CONDITIONS OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES AND CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  \n\n\n10 LIMITATION OF LIABILITY\n\u00b6\n\n\n10.1    IN NO EVENT WILL WE , OUR SUBSIDIARIES AND AFFILIATES, AND OUR LICENSORS BE LIABLE TO YOU FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF DATA, LOSS OF BUSINESS PROFITS OR ANY OTHER PECUNIARY LOSS) OF ANY KIND OR NATURE ARISING OUT OF THE USE OR INABILIYTY TO USE THE ITEMS IN THE SDK, EVEN IF WE OR OUR REPRESENTATIVES HAVE BEEN ADVISED OF OR SHOULD HAVE BEEN AWARE OF THE POSSIBILITY OF SUCH DAMAGES.  \n\n\n11 Indemnification\n\u00b6\n\n\n11.1    To the maximum extent permitted by law, you agree to defend, indemnify and hold harmless us, our affiliates and their respective directors, officers, employees and agents from and against any and all claims, actions, suits or proceedings, as well as any and all losses, liabilities, damages, costs and expenses (including reasonable attorneys\u2019 fees) arising out of or accruing from (a) your use of the SDK; (b) any application you develop on the SDK that infringes any copyright, trademark, trade secret, trade dress, patent or other intellectual property right of any person or defames any person or violates their rights of publicity or privacy; and/or \u00a9 any non-compliance by you with this License Agreement. \n\n\n12 General\n\u00b6\n\n\n12.1    This License Agreement constitutes the whole legal agreement between you and us and governs your use of the SDK (excluding any services which we may provide to you under a separate written agreement), and completely replaces any prior agreements between you and us in relation to the SDK. \n12.2    You agree that if we do not exercise or enforce any legal right or remedy which is contained in the License Agreement (or which we have the benefit of under any applicable law), this will not be taken to be a formal waiver of our rights and that those rights or remedies will still be available to us.\n\n12.3    If any court of law, having the jurisdiction to decide on this matter, rules that any provision of this License Agreement is invalid, then that provision will be removed from this License Agreement without affecting the rest of this License Agreement. The remaining provisions of this License Agreement will continue to be valid and enforceable.\n\n12.4    You acknowledge and agree that each member of the group of companies of which we are the parent shall be third party beneficiaries to this License Agreement and that such other companies shall be entitled to directly enforce, and rely upon, any provision of this License Agreement that confers a benefit on (or rights in favor of) them. Other than this, no other person or company shall be third party beneficiaries to this License Agreement.\n\n12.5    The rights granted in this License Agreement may not be assigned or transferred by either you or us without the prior written approval of the other party. Neither you nor we shall be permitted to delegate their responsibilities or obligations under this License Agreement without the prior written approval of the other party.\n\n12.6    This License Agreement, and your relationship with us under this License Agreement, shall be governed by the laws of the Republic of Korea without regard to its conflict of laws provisions. You and we agree to submit to the exclusive jurisdiction of Seoul Central District Court in Seoul, South Korea to resolve any legal matter arising from this License Agreement. Notwithstanding this, you agree that we shall still be allowed to apply for injunctive remedies (or an equivalent type of urgent legal relief) in any jurisdiction.  \n\n\n\n\nSDK \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d (\ud55c\uad6d\uc5b4)\n\u00b6\n\n\n\ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc740 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \uac1c\ubc1c \ud0a4\ud2b8 \uc0ac\uc6a9\uacfc \uad00\ub828\ud558\uc5ec \uadc0\ud558\uc640 [\uc8fc\uc2dd\ud68c\uc0ac \uc288\ud504\ub9ac\ub9c8]\uac04\uc5d0 \ubc95\uc801 \uad6c\uc18d\ub825\uc774 \uc788\ub294 \uacc4\uc57d\uc744 \ud615\uc131\ud569\ub2c8\ub2e4.\n\n\n1 \uc815\uc758\n\u00b6\n\n\n1.1\u201c[\uc288\ud504\ub9ac\ub9c8]\u201d \ub610\ub294 \u201c\ub2f9\uc0ac\u201d\ub294 \ub300\ud55c\ubbfc\uad6d \ubc95\ub960\uc5d0 \ub530\ub77c \uc870\uc9c1\ub418\uace0 \uc6b4\uc601\ub418\uba70 [\uacbd\uae30\ub3c4 \uc131\ub0a8\uc2dc \ubd84\ub2f9\uad6c \uc815\uc790\uc77c\ub85c 248 \ud30c\ud06c\ubdf0\uc624\ud53c\uc2a4\ud0c0\uc6cc17F-5]\ub97c \ubcf8\uc810 \uc18c\uc7ac\uc9c0\ub85c \ub450\uace0\uc788\ub294 [\uc8fc\uc2dd\ud68c\uc0ac \uc288\ud504\ub9ac\ub9c8]\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4.\n\n1.2 \"SDK\"\ub294 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ud30c\uc77c, \ubb38\uc11c, \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ucf54\ub4dc, \uae30\ud0c0 \uad00\ub828 \ud56d\ubaa9 \ubc0f \uadf8 \uc218\uc815\ub41c \ubc84\uc804 \ub610\ub294 \uc5c5\uadf8\ub808\uc774\ub4dc\uac00 \ud3ec\ud568\ub41c [SFM SDKs] \uc18c\ud504\ud2b8\uc6e8\uc5b4 \uac1c\ubc1c \ud0a4\ud2b8\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4.  \n\n\n2 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\n\u00b6\n\n\n2.1 SDK\ub97c \uc0ac\uc6a9\ud558\ub824\uba74 \uba3c\uc800 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud558\uc9c0 \uc54a\uc73c\uba74 SDK\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\n2.2 SDK\ub97c \uc124\uce58, \uc5f4\ub78c, \uc0ac\uc6a9\ud568\uc73c\ub85c\uc368 \uadc0\ud558\ub294 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud55c \uac83\uc73c\ub85c \uac04\uc8fc\ud569\ub2c8\ub2e4. \n\n2.3 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud568\uc73c\ub85c\uc368 \uadc0\ud558\ub294 \uadc0\ud558 \uc790\uc2e0 \ub610\ub294 \uadc0\ud558\uc758 \ubc95\uc778\uc744 \ubcf8 \uacc4\uc57d\uc5d0 \uad6c\uc18d\uc2dc\ud0ac \uc644\uc804\ud55c \ubc95\uc801 \uad8c\ud55c\uc774 \uc788\uc74c\uc744 \uc9c4\uc220\ud558\uace0 \ubcf4\uc99d\ud569\ub2c8\ub2e4.  \n\n\n3 \ub77c\uc774\uc120\uc2a4 \ubd80\uc5ec; \uad8c\ub9ac \uc720\ubcf4\n\u00b6\n\n\n3.1 \ubcf8 \uacc4\uc57d\uc758 \uc870\uac74\uc5d0 \ub530\ub77c \ub2f9\uc0ac\ub294 \ub2f9\uc0ac \uc81c\ud488\uacfc \ud568\uaed8 \uc791\ub3d9\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc744 \uac1c\ubc1c\ud558\uae30 \uc704\ud574\uc11c\ub9cc SDK\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub294 \uc81c\ud55c\uc801\uc774\uace0 \ube44 \ub3c5\uc810\uc801\uc774\uba70 \uc591\ub3c4 \ubd88\uac00\ub2a5\ud55c \uc804 \uc138\uacc4\uc801 \ub77c\uc774\uc120\uc2a4\ub97c \uadc0\ud558\uc5d0\uac8c \ubd80\uc5ec\ud569\ub2c8\ub2e4.\n\n3.2 \uadc0\ud558\ub294 SDK\uc5d0 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 \uc9c0\uc2dd \uc7ac\uc0b0\uad8c\uc744 \ud3ec\ud568\ud558\uc5ec \ub2f9\uc0ac \ub610\ub294 \uc81c 3\uc790\uac00 SDK\uc5d0 \ub300\ud55c \ubaa8\ub4e0 \ubc95\uc801 \uad8c\ub9ac, \uc18c\uc720\uad8c \ubc0f \uc774\uad8c\uc744 \uc18c\uc720\ud55c\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \"\uc9c0\uc2dd \uc7ac\uc0b0\uad8c\"\uc740 \ud2b9\ud5c8\ubc95, \uc800\uc791\uad8c\ubc95, \uc601\uc5c5 \ube44\ubc00, \uc0c1\ud45c\ubc95 \ubc0f \uae30\ud0c0  \ubaa8\ub4e0 \uc7ac\uc0b0\uc801 \uad8c\ub9ac\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4. \ub2f9\uc0ac\ub294 \ubcf8 \uacc4\uc57d\uc774 \uadc0\ud558\uc5d0\uac8c \uba85\uc2dc\uc801\uc73c\ub85c \ubd80\uc5ec\ub418\uc9c0 \uc54a\uc740 \ubaa8\ub4e0 \uad8c\ub9ac\ub97c \ubcf4\uc720\ud569\ub2c8\ub2e4.\n\n3.3 \ubcf8 \uacc4\uc57d\uc774 \uba85\uc2dc\uc801\uc73c\ub85c \ud5c8\uc6a9\ud558\uc9c0 \uc54a\ub294 \ubaa9\uc801\uc73c\ub85c SDK\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc801\uc6a9\uac00\ub2a5\ud55c \uc81c 3 \uc790 \ub77c\uc774\uc120\uc2a4\uc5d0\uc11c \uc694\uad6c\ud558\ub294 \uacbd\uc6b0\ub97c \uc81c\uc678\ud558\uace0, \uadc0\ud558\ub294 SDK \ub610\ub294 SDK\uc758 \uc77c\ubd80\ub97c \ubcf5\uc0ac (\ubc31\uc5c5 \ubaa9\uc801 \uc81c\uc678), \uc218\uc815, \uac1c\uc870, \uc7ac\ubc30\ud3ec, \ub514 \ucef4\ud30c\uc77c, \ub9ac\ubc84\uc2a4 \uc5d4\uc9c0\ub2c8\uc5b4\ub9c1, \ubd84\ud574 \ub610\ub294 \ud30c\uc0dd\ubb3c \uc0dd\uc131\uc744 \ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\n3.4 \uc624\ud508 \uc18c\uc2a4 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ub77c\uc774\uc120\uc2a4\uc5d0 \ub530\ub77c \ub77c\uc774\uc120\uc2a4\uac00 \ubd80\uc5ec\ub41c SDK \uad6c\uc131 \uc694\uc18c\uc758 \uc0ac\uc6a9, \ubcf5\uc81c \ubc0f \ubc30\ud3ec\ub294 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc774 \uc544\ub2cc \ud574\ub2f9 \uc624\ud508 \uc18c\uc2a4 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ub77c\uc774\uc120\uc2a4\uc758 \uc801\uc6a9\uc744 \ubc1b\uc2b5\ub2c8\ub2e4.\n\n3.5 \uadc0\ud558\ub294 SDK\uc758 \ud615\uc2dd\uacfc \ud2b9\uc131\uc774 \uc0ac\uc804 \ud1b5\uc9c0\uc5c6\uc774 \ubcc0\uacbd\ub420 \uc218 \uc788\uc73c\uba70 SDK\uc758 \ud5a5\ud6c4 \ubc84\uc804\uc774 \uc774\uc804 \ubc84\uc804\uc758 SDK\uc5d0\uc11c \uac1c\ubc1c\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uacfc \ud638\ud658\ub418\uc9c0 \uc54a\uc744 \uc218 \uc788\uc74c\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uadc0\ud558\ub294 \uc77c\ubc18\uc801\uc73c\ub85c \uadc0\ud558\uc5d0\uac8c \uc0ac\uc804 \ud1b5\uc9c0\uc5c6\uc774 \ub2f9\uc0ac\uc758 \ub2e8\ub3c5 \uc7ac\ub7c9\uc5d0 \ub530\ub77c \uadc0\ud558 \ub610\ub294 \uc0ac\uc6a9\uc790\uc5d0\uac8c SDK (\ub610\ub294 SDK \ub0b4\uc758 \ubaa8\ub4e0 \uae30\ub2a5) \uc81c\uacf5\uc744 (\uc601\uad6c\uc801\uc73c\ub85c \ub610\ub294 \uc77c\uc2dc\uc801\uc73c\ub85c) \uc911\ub2e8\ud560 \uc218 \uc788\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.\n\n3.6 \ubcf8 \ub77c\uc774\uc13c\uc2a4 \uacc4\uc57d\uc758 \uc5b4\ub5a0\ud55c \ub0b4\uc6a9\ub3c4 \uadc0\ud558\uc5d0\uac8c \ub2f9\uc0ac\uc758 \uc0c1\ud638, \uc0c1\ud45c, \uc11c\ube44\uc2a4 \ub9c8\ud06c, \ub85c\uace0, \ub3c4\uba54\uc778 \uc774\ub984 \ub610\ub294 \uae30\ud0c0 \uace0\uc720\ud55c \ube0c\ub79c\ub4dc \ud2b9\uc131\uc744 \uc0ac\uc6a9\ud560 \uad8c\ub9ac\ub97c \ubd80\uc5ec\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\n\n3.7 \uadc0\ud558\ub294 SDK\uc5d0 \ucca8\ubd80\ub418\uac70\ub098 SDK \ub0b4\uc5d0 \ud3ec\ud568\ub420 \uc218 \uc788\ub294 \ubaa8\ub4e0 \uc18c\uc720\uad8c \uace0\uc9c0 (\uc800\uc791\uad8c \ubc0f \uc0c1\ud45c \uace0\uc9c0 \ud3ec\ud568)\ub97c \uc81c\uac70\ud558\uac70\ub098 \uac00\ub9ac\uac70\ub098 \ubcc0\uacbd\ud558\uc9c0 \uc54a\uc744 \uac83\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4.  \n\n\n4 \uadc0\ud558\uc758 \ucc45\uc784\n\u00b6\n\n\n4.1 \uadc0\ud558\ub294 \ubcf8 \uacc4\uc57d\uc5d0\uc11c \ud5c8\uc6a9\ud558\ub294 \ubaa9\uc801\uc73c\ub85c\ub9cc SDK\ub97c \uc0ac\uc6a9\ud558\uace0 \uad00\ub828 \ubc95\ub960, \uaddc\uc815 \ub610\ub294 \uad00\ub828 \uad00\ud560\uad8c\uc5d0\uc11c \uc77c\ubc18\uc801\uc73c\ub85c \ud5c8\uc6a9\ub418\ub294 \uad00\ud589 \ub610\ub294 \uc9c0\uce68\uc5d0 \ub530\ub974\uba70 \ubd88\ubc95\uc801\uc774\uac70\ub098 \ube44 \uc724\ub9ac\uc801\uc778 \ubc29\uc2dd\uc73c\ub85c SDK\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc744 \uac83\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4.\n\n4.2 \uadc0\ud558\ub294 SDK\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc77c\ubc18 \uc0ac\uc6a9\uc790\ub97c \uc704\ud55c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uac1c\ubc1c\ud558\ub294 \uacbd\uc6b0 \ud574\ub2f9 \uc0ac\uc6a9\uc790\uc758 \uac1c\uc778 \uc815\ubcf4 \ubc0f \ubc95\uc801 \uad8c\ub9ac\ub97c \ubcf4\ud638\ud560 \uac83\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uc0ac\uc6a9\uc790\uac00 \uac1c\uc778 \ub370\uc774\ud130\ub97c \uc81c\uacf5\ud558\ub294 \uacbd\uc6b0 \ud574\ub2f9 \ub370\uc774\ud130 \ubcf4\ud638\ubc95 \ub610\ub294 \uad00\ub828 \uc815\ucc45\uc5d0\uc11c \uc694\uad6c\ud558\ub294\ub300\ub85c \ud574\ub2f9 \ub370\uc774\ud130\ub97c \ucc98\ub9ac\ud574\uc57c\ud569\ub2c8\ub2e4.\n\n4.3 \uadc0\ud558\ub294 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d, \uc801\uc6a9 \uac00\ub2a5\ud55c \uc81c 3 \uc790 \uacc4\uc57d \uc870\uac74 \ub610\ub294 \uad00\ub828 \ubc95\ub960 \ub610\ub294 \uaddc\uc815\uc5d0 \ub530\ub978 \uc758\ubb34 \uc704\ubc18 \ubc0f \uacb0\uacfc (\ub2f9\uc0ac \ub610\ub294 \uc81c 3\uc790\uac00 \uc785\uc740 \uc190\uc2e4 \ub610\ub294 \uc190\ud574 \ud3ec\ud568)\uc5d0 \ub300\ud574 \uc804\uc801\uc73c\ub85c \ucc45\uc784\uc744 \uc9c4\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.  \n\n\n5 \uac1c\uc778 \uc815\ubcf4 \ubcf4\ud638\n\u00b6\n\n\n5.1 SDK\ub97c \uc9c0\uc18d\uc801\uc73c\ub85c \ud601\uc2e0\ud558\uace0 \uac1c\uc120\ud558\uae30 \uc704\ud574, \ub2f9\uc0ac\ub294 \uace0\uc720 \uc2dd\ubcc4\uc790, \uad00\ub828 IP \uc8fc\uc18c, \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ubc84\uc804 \ubc88\ud638, SDK\uc5d0 \uc0ac\uc6a9\ub41c \ub3c4\uad6c \ubc0f / \ub610\ub294 \uc11c\ube44\uc2a4\uc640 \uc0ac\uc6a9\ubc29\uc2dd\uc5d0 \uad00\ud55c \uc815\ubcf4\ub97c \ud3ec\ud568\ud558\uc5ec \uc18c\ud504\ud2b8\uc6e8\uc5b4\uc5d0\uc11c \ud2b9\uc815 \uc0ac\uc6a9 \ud1b5\uacc4\ub97c \uc218\uc9d1\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \n\n5.2 \uc218\uc9d1\ub41c \ub370\uc774\ud130\ub294 SDK\ub97c \uac1c\uc120\ud558\uae30 \uc704\ud574 \ucd1d\uccb4\uc801\uc73c\ub85c \uac80\ud1a0\ub418\uba70 \ub2f9\uc0ac\uc758 \uac1c\uc778 \uc815\ubcf4 \ubcf4\ud638 \uc815\ucc45\uc5d0 \ub530\ub77c \uc720\uc9c0\ub429\ub2c8\ub2e4.\n\n5.3 \uc775\uba85\ud654\ud55c \ucde8\ud569 \ub370\uc774\ud130\ub294 SDK \uac1c\uc120\uc744 \uc704\ud574 \ud30c\ud2b8\ub108\uc640 \uacf5\uc720\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4.  \n\n\n6 \ud0c0\uc0ac \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\n\u00b6\n\n\n6.1 SDK\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc81c 3\uc790\uac00 \uac1c\ubc1c\ud55c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uc2e4\ud589\ud558\uac70\ub098 \uc81c 3\uc790\uac00 \uc81c\uacf5\ud55c \ub370\uc774\ud130, \ucf58\ud150\uce20 \ub610\ub294 \ub9ac\uc18c\uc2a4 ( \"\uc81c 3 \uc790 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\")\uc758 \uc0ac\uc6a9 \ub610\ub294 \uc561\uc138\uc2a4\uc758 \uacb0\uacfc\ub85c \uadc0\ud558\uc5d0\uac8c \ubc1c\uc0dd\ud560 \uc218 \uc788\ub294 \uc190\uc2e4 \ub610\ub294 \uc190\ud574\uc5d0 \ub300\ud574 \ub2f9\uc0ac\uac00 \ucc45\uc784\uc9c0\uc9c0 \uc54a\ub294\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \n\n62 \uc81c 3 \uc790 \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc740 \uad00\ub828 \uc81c 3\uc790\uac00 \uc18c\uc720\ud55c \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc5d0 \uc758\ud574 \ubcf4\ud638 \ub420 \uc218 \uc788\uc74c\uc744 \uc778\uc2dd\ud574\uc57c \ud569\ub2c8\ub2e4. \uad00\ub828 \ub2f9\uc0ac\uc790\uac00 \ud2b9\ubcc4\ud788 \ud5c8\uc6a9\ud558\uc9c0 \uc54a\ub294 \ud55c \uc774\ub7ec\ud55c \ub370\uc774\ud130, \ucf58\ud150\uce20 \ub610\ub294 \ub9ac\uc18c\uc2a4 (\uc804\uccb4 \ub610\ub294 \uc77c\ubd80)\ub97c \uae30\ubc18\uc73c\ub85c \ud55c \ud30c\uc0dd\ubb3c\uc744 \uc218\uc815, \ub300\uc5ec, \ud310\ub9e4, \ubc30\ud3ec \ub610\ub294 \uc0dd\uc131\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\n6.3 \uadc0\ud558\ub294 \uadf8\ub7ec\ud55c \uc81c 3 \uc790 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc758 \uc0ac\uc6a9\uc774 \uadc0\ud558\uc640 \uad00\ub828 \uc81c 3 \uc790\uac04 \uc57d\uc815\ub41c \ubcc4\ub3c4\uc758 \uc870\uac74\uc744 \ub530\ub97c \uc218 \uc788\uc74c\uc744 \uc778\uc815\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0 \ubcf8 \uacc4\uc57d\uc740 \uc81c 3 \uc790\uc640\uc758 \ubc95\uc801 \uad00\uacc4\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.  \n\n\n7 API \uc0ac\uc6a9\n\u00b6\n\n\n7.1 \uadc0\ud558\uac00 \ub2f9\uc0ac\uc5d0\uc11c \ub370\uc774\ud130\ub97c \uac80\uc0c9\ud558\uae30 \uc704\ud574 API\ub97c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 \uadc0\ud558\ub294 \ub2f9\uc0ac \ub610\ub294 \ub370\uc774\ud130\ub97c \uc81c\uacf5\ud558\ub294 \ub2f9\uc0ac\uc790 (\ub610\ub294 \uc774\ub4e4\uc744 \ub300\uc2e0\ud558\ub294 \ub2e4\ub978 \uac1c\uc778 \ub610\ub294 \ubc95\uc778)\uac00 \uc18c\uc720\ud55c \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc5d0 \uc758\ud574 \ub370\uc774\ud130\uac00 \ubcf4\ud638\ub420 \uc218 \uc788\uc74c\uc744 \uc778\uc815\ud569\ub2c8\ub2e4. \uc774\ub7ec\ud55c API\ub97c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 \ubcc4\ub3c4\uc758 \uc57d\uad00\uc774 \uc801\uc6a9\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uad00\ub828 \uc57d\uad00\uc5d0\uc11c \ud5c8\uc6a9\ud558\uc9c0 \uc54a\ub294 \ud55c \uc774 \ub370\uc774\ud130 (\uc804\uccb4 \ub610\ub294 \uc77c\ubd80)\ub97c \uae30\ubc18\uc73c\ub85c \ud55c \ud30c\uc0dd\ubb3c\uc744 \uc218\uc815, \ub300\uc5ec, \ud310\ub9e4, \ubc30\ud3ec \ub610\ub294 \uc0dd\uc131\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.  \n\n\n8 \uae30\uac04; \ud574\uc9c0\n\u00b6\n\n\n8.1 \ubcf8 \uacc4\uc57d\uc740 \ud574\uc9c0\ub420 \ub54c\uae4c\uc9c0 \uc720\ud6a8\ud569\ub2c8\ub2e4.\n\n8.2 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc744 \ud574\uc9c0\ud558\ub824\uba74 SDK\uc758 \uc0ac\uc6a9\uc744 \uc911\ub2e8\ud558\uba74 \ub429\ub2c8\ub2e4.\n\n8.3 \ub2f9\uc0ac\ub294 \uadc0\ud558\uac00 \ubcf8 \ubb38\uc11c\uc758 \uc870\uac74\uc744 \uc900\uc218\ud558\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \ub610\ub294 \ub2f9\uc0ac\uc758 \ub2e8\ub3c5 \uc7ac\ub7c9\uc5d0 \ub530\ub77c \uc5b8\uc81c\ub4e0\uc9c0 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc744 \ud574\uc9c0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n8.4 \ubcf8 \uacc4\uc57d \ud574\uc9c0\uc2dc \uadc0\ud558\ub294 SDK\uc758 \ubaa8\ub4e0 \ud56d\ubaa9\uc744 \uc81c\uac70\ud558\uace0 \uc0ac\uc6a9\uc744 \uc911\ub2e8\ud558\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.  \n\n\n9 \ubcf4\uc99d\uc758 \ubd80\uc778\n\u00b6\n\n\n9.1 \uadc0\ud558\ub294 SDK \uc0ac\uc6a9\uc774 \uc804\uc801\uc73c\ub85c \uadc0\ud558\uc758 \ucc45\uc784\uc774\uba70 SDK\uac00 \ub2f9\uc0ac\uc758 \uc5b4\ub5a0\ud55c \ubcf4\uc99d \uc5c6\uc774 \"\uc788\ub294 \uadf8\ub300\ub85c\" \uc81c\uacf5\ub41c\ub2e4\ub294 \uac83\uc744 \uba85\uc2dc \uc801\uc73c\ub85c \uc774\ud574\ud558\uace0 \ub3d9\uc758\ud569\ub2c8\ub2e4.\n\n9.2 SDK \ubc0f SDK \uc0ac\uc6a9\uc744 \ud1b5\ud574 \ub2e4\uc6b4\ub85c\ub4dc\ud558\uac70\ub098 \ub2e4\ub978 \ubc29\uc2dd\uc73c\ub85c \ud68d\ub4dd\ud55c \ubaa8\ub4e0 \uc790\ub8cc\uc758 \uc0ac\uc6a9\uc740 \uadc0\ud558\uc758 \uc7ac\ub7c9 \ubc0f \ub9ac\uc2a4\ud06c\uc774\uba70 \uadc0\ud558\ub294 \uadc0\ud558\uc758 \ucef4\ud4e8\ud130 \uc2dc\uc2a4\ud15c \ub610\ub294 \uae30\ud0c0 \uc7a5\uce58\uc758 \uc190\uc0c1 \ub610\ub294 \uc774\ub7ec\ud55c \uc0ac\uc6a9\uc73c\ub85c \uc778\ud55c \ub370\uc774\ud130 \uc190\uc2e4\uc5d0 \ub300\ud574 \uc804\uc801\uc73c\ub85c \ucc45\uc784\uc744 \uc9d1\ub2c8\ub2e4. \n\n9.3 \ub610\ud55c \ub2f9\uc0ac\ub294 \uc0c1\ud488\uc131, \ud2b9\uc815 \ubaa9\uc801\uc5d0\uc758 \uc801\ud569\uc131 \ubc0f \ube44 \uce68\ud574\uc5d0 \ub300\ud55c \ubb35\uc2dc\uc801 \ubcf4\uc99d\uc744 \ud3ec\ud568\ud55c \ubaa8\ub4e0 \ubcf4\uc99d\uc744 \uba85\uc2dc\uc801\uc73c\ub85c \ubd80\uc778\ud569\ub2c8\ub2e4.  \n\n\n10 \ucc45\uc784\uc758 \uc81c\ud55c\n\u00b6\n\n\n1.1 \uc5b4\ub5a0\ud55c \uacbd\uc6b0\uc5d0\ub3c4 \ub2f9\uc0ac, \ub2f9\uc0ac\uc758 \uc790\ud68c\uc0ac \ubc0f \uacc4\uc5f4\uc0ac \ubc0f \ub77c\uc774\uc120\uc2a4 \uc81c\uacf5\uc790\ub294 \ubaa8\ub4e0 \uc9c1\uc811\uc801, \uac04\uc811\uc801, \ubd80\uc218\uc801, \ud2b9\uc218, \uacb0\uacfc\uc801 \ub610\ub294 \uc9d5\ubc8c\uc801 \uc190\ud574(\ub370\uc774\ud130 \uc190\uc2e4, \ube44\uc988\ub2c8\uc2a4 \uc774\uc775 \uc190\uc2e4 \ub4f1 \ud3ec\ud568)\uc5d0 \ub300\ud558\uc5ec \ub2f9\uc0ac \ub610\ub294 \ub2f9\uc0ac\uc758 \ub300\ub9ac\uc778\uc774 \uadf8\ub7ec\ud55c \uc190\ud574\uc758 \uac00\ub2a5\uc131\uc5d0 \ub300\ud55c \uc778\uc9c0 \uc5ec\ubd80\uc640 \uad00\uacc4\uc5c6\uc774 \ubaa8\ub4e0 \uc190\ud574\uc5d0 \ub300\ud558\uc5ec \uadc0\ud558\uc5d0\uac8c \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.   \n\n\n11 \uba74\ucc45\n\u00b6\n\n\n11.1 \ubc95\ub960\uc774 \ud5c8\uc6a9\ud558\ub294 \ubc94\uc704 \uc548\uc5d0\uc11c \uadc0\ud558\ub294 \ub2f9\uc0ac, \ub2f9\uc0ac\uc758 \uacc4\uc5f4\uc0ac \ubc0f \uc774\uc0ac, \uc784\uc6d0, \uc9c1\uc6d0 \ubc0f \ub300\ub9ac\uc778\uc744 (a) \uadc0\ud558\uc758 SDK \uc0ac\uc6a9; (b) \uc800\uc791\uad8c, \uc0c1\ud45c, \uc601\uc5c5 \ube44\ubc00, \ud2b9\ud5c8 \ub610\ub294 \uae30\ud0c0 \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc744 \uce68\ud574\ud558\uac70\ub098 \ud0c0\uc778\uc758 \uba85\uc608\uc640 \uac1c\uc778 \uc815\ubcf4\uc5d0 \ub300\ud55c \uad8c\ub9ac \uce68\ud574; \ubc0f / \ub610\ub294 \u00a9 \ubcf8 \uacc4\uc57d \ubd88\uc774\ud589\uc73c\ub85c \uc778\ud574 \ubc1c\uc0dd\ud55c \ubaa8\ub4e0 \uc18c\uc1a1, \uccad\uad6c, \uc190\uc2e4, \uc190\ud574, \ucc45\uc784 \ubc0f \ube44\uc6a9(\ubcc0\ud638\uc0ac \ube44\uc6a9 \ud3ec\ud568)\uc73c\ub85c\ubd80\ud130 \ubc29\uc5b4\ud558\uace0 \uba74\ucc45\ud574\uc57c \ud569\ub2c8\ub2e4.  \n\n\n12 \uc77c\ubc18\uc870\uac74\n\u00b6\n\n\n12.1 \ubcf8 \uacc4\uc57d\uc740 \uadc0\ud558\uc640 \ub2f9\uc0ac \uac04\uc758 \uc644\uc804\ud55c \ubc95\uc801 \uacc4\uc57d\uc774\uba70 \uadc0\ud558\uc758 SDK\uc0ac\uc6a9\uc744 \uaddc\uc728\ud558\uace0 (\ubcc4\ub3c4\uc758 \uc11c\uba74 \uacc4\uc57d\uc5d0 \ub530\ub77c \ub2f9\uc0ac\uac00 \uadc0\ud558\uc5d0\uac8c \uc81c\uacf5\ud560 \uc218 \uc788\ub294 \uc11c\ube44\uc2a4 \uc81c\uc678) SDK\uc640 \uad00\ub828\ud558\uc5ec \uadc0\ud558\uc640 \ub2f9\uc0ac \uac04 \uccb4\uacb0\ub41c \ubaa8\ub4e0 \uc774\uc804 \uacc4\uc57d\uc744 \uc644\uc804\ud788 \ub300\uccb4\ud569\ub2c8\ub2e4. \n\n12.2 \uadc0\ud558\ub294 \ub2f9\uc0ac\uac00 \ubcf8 \uacc4\uc57d\uc5d0 \ud3ec\ud568\ub41c (\ub610\ub294 \ud574\ub2f9 \ubc95\ub960\uc5d0 \ub530\ub77c \ub2f9\uc0ac\uac00 \ubc1b\ub294) \ubc95\uc801 \uad8c\ub9ac \ub610\ub294 \uad6c\uc81c\ucc45\uc744 \ud589\uc0ac\ud558\uac70\ub098 \uc2dc\ud589\ud558\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc774\ub294 \ub2f9\uc0ac\uc758 \uad8c\ub9ac\ub97c \uacf5\uc2dd\uc801\uc73c\ub85c \ud3ec\uae30\ud558\ub294 \uac83\uc73c\ub85c \uac04\uc8fc\ub418\uc9c0 \uc54a\ub294\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uadf8\ub7ec\ud55c \uad8c\ub9ac\ub098 \uad6c\uc81c\ucc45\uc740 \uc5ec\uc804\ud788 \uc720\ud6a8\ud569\ub2c8\ub2e4.\n\n12.3 \uad00\ud560\uad8c\uc744 \uac00\uc9c4 \ubc95\uc6d0\uc774 \ubcf8 \uacc4\uc57d\uc758 \uc870\ud56d\uc774 \uc720\ud6a8\ud558\uc9c0 \uc54a\ub2e4\uace0 \ud310\uacb0\ud558\ub294 \uacbd\uc6b0, \ud574\ub2f9 \uc870\ud56d\uc740 \ubcf8 \uacc4\uc57d\uc758 \uc774\uc678 \uc870\ud56d\uc5d0 \uc601\ud5a5\uc744 \uc8fc\uc9c0 \uc54a\uace0 \ubcf8 \uacc4\uc57d\uc5d0\uc11c \uc0ad\uc81c\ub429\ub2c8\ub2e4.  \ubcf8 \uacc4\uc57d\uc758 \uc774\uc678 \uc870\ud56d\uc740 \uacc4\uc18d \uc720\ud6a8\ud558\uace0 \uc2dc\ud589 \uac00\ub2a5\ud569\ub2c8\ub2e4.\n\n12.4 \uadc0\ud558\ub294 \ub2f9\uc0ac\uc758 \ubaa8\ud68c\uc0ac \uac01 \uad6c\uc131\uc6d0\uc774 \ubcf8 \uacc4\uc57d\uc758 \uc81c 3 \uc790 \uc218\ud61c\uc790\uc774\uba70 \uadf8\ub7ec\ud55c \ud68c\uc0ac\uac00 \ubcf8 \uacc4\uc57d\uc758 \uc870\ud56d\uc744 \uc9c1\uc811 \uc2dc\ud589\ud560 \uc790\uaca9\uc774 \uc788\uc74c\uc744 \uc778\uc815\ud558\uace0 \uc774\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uc774 \uc678\uc5d0 \ub2e4\ub978 \uac1c\uc778\uc774\ub098 \ubc95\uc778\uc740 \ubcf8 \uacc4\uc57d\uc758 \uc81c 3 \uc790 \uc218\ud61c\uc790\uac00 \ub420 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\n12.5 \ubcf8 \uacc4\uc57d\uc5d0\uc11c \ubd80\uc5ec\ud55c \uad8c\ub9ac\ub294 \uc0c1\ub300\ubc29\uc758 \uc0ac\uc804 \uc11c\uba74 \uc2b9\uc778\uc5c6\uc774 \uadc0\ud558 \ub610\ub294 \ub2f9\uc0ac\uc5d0 \uc758\ud574 \uc591\ub3c4\ub420 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uadc0\ud558\uc640 \ub2f9\uc0ac\ub294 \uc0c1\ub300\ubc29\uc758 \uc0ac\uc804 \uc11c\uba74 \uc2b9\uc778\uc5c6\uc774 \ubcf8 \uacc4\uc57d\uc5d0 \ub530\ub978 \ucc45\uc784\uc774\ub098 \uc758\ubb34\ub97c \uc704\uc784\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\n12.6 \ubcf8 \uacc4\uc57d\uc740 \ub300\ud55c\ubbfc\uad6d \ubc95\ub960\uc758 \uc801\uc6a9\uc744 \ubc1b\uc2b5\ub2c8\ub2e4. \uadc0\ud558\uc640 \ub2f9\uc0ac\ub294 \ubcf8 \uacc4\uc57d\uc73c\ub85c \uc778\ud574 \ubc1c\uc0dd\ud558\ub294 \ubaa8\ub4e0 \ubc95\uc801 \ubb38\uc81c\ub97c \ud574\uacb0\ud558\uae30 \uc704\ud574 \ub300\ud55c\ubbfc\uad6d \uc11c\uc6b8\uc758 \uc11c\uc6b8 \uc911\uc559 \uc9c0\ubc29 \ubc95\uc6d0\uc758 \uc804\uc18d \uad00\ud560\uc5d0 \ub530\ub974\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uadf8\ub7fc\uc5d0\ub3c4 \ubd88\uad6c\ud558\uace0 \uadc0\ud558\ub294 \ub2f9\uc0ac\uac00 \ubaa8\ub4e0 \uad00\ud560\uad8c\uc5d0\uc11c \uac15\uc81c \uad6c\uc81c \uc870\uce58 (\ub610\ub294 \uc774\uc5d0 \uc0c1\uc751\ud558\ub294 \uc720\ud615\uc758 \uae34\uae09 \ubc95\uc801 \uad6c\uc81c)\ub97c \uc2e0\uccad\ud560 \uc218 \uc788\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.",
            "title": "SDK License Agreement"
        },
        {
            "location": "/sdk/sdk-license-agreement/#sdk-license-agreement",
            "text": "This License Agreement forms a legally binding contract between you and [Suprema Inc.] in relation to your use of the Software Development Kit.",
            "title": "SDK LICENSE AGREEMENT"
        },
        {
            "location": "/sdk/sdk-license-agreement/#1-definitions",
            "text": "1.1 \u201c[SUPREMA]\u201d or \u201cWe\u201d means [Suprema Inc.], organized under the laws of the Republic of Korea, and operating under the laws of the Republic of Korea with principal place of business at [17F-5, Parkview Office Tower, 248, Jeongjail-ro, Seongnam-si, Gyeonggi-do, 13554]. \n1.2 \u201cSDK\u201d means the [SFM] Software Development Kit that includes software files, documentation, software code, other related items, and any modified versions or upgrades thereof.",
            "title": "1  Definitions"
        },
        {
            "location": "/sdk/sdk-license-agreement/#2-accepting-this-license-agreement",
            "text": "2.1 In order to use the SDK, you must first agree to this License Agreement. \n2.2 BY INSTALLING, ACTIVATING, ACCESSING OR OTHERWISE USING THE SDK, YOU HEREBY AGREE TO THIS LICENSE AGREEMENT. IF YOU DO NOT AGREE TO THE TERMS OF THIS LICENSE AGREEMENT, DO NOT INSTALL, ACTIVATE, ACCESS OR USE THE SDK. \n2.3 By accepting this License Agreement, you represent and warrant that you have full legal authority to bind yourself or your entity to this License Agreement.",
            "title": "2  Accepting this License Agreement"
        },
        {
            "location": "/sdk/sdk-license-agreement/#3-grant-of-license-reservation-of-rights",
            "text": "3.1 Subject to the terms of this License Agreement, we hereby grant you a limited, non-exclusive, and non-transferable, and worldwide license to use the SDK solely to develop application programs designed to function with our products. \n3.2 You agree that we or third parties own all legal right, title and interest in or to the SDK, including any Intellectual Property Rights that subsist in the SDK. \"Intellectual Property Rights\" means any and all rights under patent law, copyright law, trade secret law, trademark law, and any and all other proprietary rights.  We reserve all rights not expressly granted to you under this License Agreement. \n3.3 You may not use the SDK for any purpose not expressly permitted by this License Agreement. Except to the extent required by applicable third party licenses, you may not copy (except for backup purposes), modify, adapt, redistribute, decompile, reverse engineer, disassemble, or create derivative works of the SDK or any part of the SDK. \n3.4 Use, reproduction and distribution of components of the SDK licensed under an open source software license are governed solely by the terms of that open source software license and not this License Agreement. \n3.5 You agree that the form and nature of the SDK may change without prior notice to you and that future versions of the SDK may be incompatible with applications developed on previous versions of the SDK. You agree that we may stop (permanently or temporarily) providing the SDK (or any features within the SDK) to you or to users generally at our sole discretion, without prior notice to you. \n3.6 Nothing in this License Agreement gives you a right to use any of our trade names, trademarks, service marks, logos, domain names, or other distinctive brand features. \n3.7 You agree that you will not remove, obscure, or alter any proprietary rights notices (including copyright and trademark notices) that may be affixed to or contained within the SDK.",
            "title": "3  Grant of License; Reservation of Rights"
        },
        {
            "location": "/sdk/sdk-license-agreement/#4-your-responsibility",
            "text": "4.1 You agree to use the SDK only for purposes that are permitted by this License Agreement and not to use the SDK in any manner unlawful or unethical under any applicable law, regulation or generally accepted practices or guidelines in the relevant jurisdictions. \n4.2 You agree that if you use the SDK to develop applications for general public users, you will protect the privacy and legal rights of those users. If the users provide you with any personal data, you must process such data as required by applicable data protection laws or related policies. \n4.3 You agree that you are solely responsible for any breach of your obligations under this License Agreement, any applicable third party terms and conditions, or any applicable law or regulation, and for the consequences (including any loss or damage which we or any third party may suffer) of any such breach.",
            "title": "4  Your Responsibility"
        },
        {
            "location": "/sdk/sdk-license-agreement/#5-privacy-and-information",
            "text": "5.1 In order to continually innovate and improve the SDK, we may collect certain usage statistics from the software including but not limited to a unique identifier, associated IP address, version number of the software, and information on which tools and/or services in the SDK are being used and how they are being used. \n5.2 The data collected is examined in the aggregate to improve the SDK and is maintained in accordance with our Privacy Policy. \n5.3 Anonymized and aggregated sets of the data may be shared with our partners to improve the SDK.",
            "title": "5  Privacy and Information"
        },
        {
            "location": "/sdk/sdk-license-agreement/#6-third-party-applications",
            "text": "6.1 If you use the SDK to run applications developed by a third party or that access data, content or resources provided by a third party (\u201cThird Party Applications\u201d), you agree that we are not liable for any loss or damage that you may experience as a result of the use or access of any of those Third Party Applications. \n6.2 You should be aware the Third Party Applications may be protected by intellectual property rights which are owned by the relevant third parties. You may not modify, rent, lease, loan, sell, distribute or create derivative works based on these data, content, or resources (either in whole or in part) unless you have been specifically given permission to do so by the relevant parties. \n6.3 You acknowledge that your use of such Third Party Applications may be subject to separate terms between you and the relevant third party. In that case, this License Agreement does not affect your legal relationship with the third party.",
            "title": "6  Third Party Applications"
        },
        {
            "location": "/sdk/sdk-license-agreement/#7-use-of-apis",
            "text": "7.1 If you use any API to retrieve data from us, you acknowledge that the data may be protected by intellectual property rights which are owned by us or those parties that provide the data (or by other individuals or entities on their behalf). Your use of any such API may be subject to separate terms and conditions. You may not modify, rent, lease, loan, sell, distribute or create derivative works based on this data (either in whole or in part) unless allowed by the relevant terms and conditions.",
            "title": "7  Use of APIs"
        },
        {
            "location": "/sdk/sdk-license-agreement/#8-term-termination",
            "text": "8.1 This License Agreement is effective until terminated. \n8.2 If you want to terminate this License Agreement, you may do so by ceasing your use of the SDK. \n8.3 We may terminate this License Agreement at any time if you fail to comply with any term herein or at our sole discretion. \n8.4 Upon termination, you agree to remove all items in the SDK and discontinue the use of the items.",
            "title": "8  Term; Termination"
        },
        {
            "location": "/sdk/sdk-license-agreement/#9-disclaimer-of-warranties",
            "text": "9.1 YOU EXPRESSLY UNDERSTAND AND AGREE THAT YOUR USE OF THE SDK IS AT YOUR SOLE RISK AND THAT THE SDK IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND FROM US. \n9.2 YOUR USE OF THE SDK AND ANY MATERIAL DOWNLOADED OR OTHERWISE OBTAINED THROUGH THE USE OF THE SDK IS AT YOUR OWN DISCRETION AND RISK AND YOU ARE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR COMPUTER SYSTEM OR OTHER DEVICE OR LOSS OF DATA THAT RESULTS FROM SUCH USE. \n9.3 WE FURTHER EXPRESSLY DISCLAIMS ALL WARRANTIES AND CONDITIONS OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES AND CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.",
            "title": "9  DISCLAIMER OF WARRANTIES"
        },
        {
            "location": "/sdk/sdk-license-agreement/#10-limitation-of-liability",
            "text": "10.1    IN NO EVENT WILL WE , OUR SUBSIDIARIES AND AFFILIATES, AND OUR LICENSORS BE LIABLE TO YOU FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF DATA, LOSS OF BUSINESS PROFITS OR ANY OTHER PECUNIARY LOSS) OF ANY KIND OR NATURE ARISING OUT OF THE USE OR INABILIYTY TO USE THE ITEMS IN THE SDK, EVEN IF WE OR OUR REPRESENTATIVES HAVE BEEN ADVISED OF OR SHOULD HAVE BEEN AWARE OF THE POSSIBILITY OF SUCH DAMAGES.",
            "title": "10 LIMITATION OF LIABILITY"
        },
        {
            "location": "/sdk/sdk-license-agreement/#11-indemnification",
            "text": "11.1    To the maximum extent permitted by law, you agree to defend, indemnify and hold harmless us, our affiliates and their respective directors, officers, employees and agents from and against any and all claims, actions, suits or proceedings, as well as any and all losses, liabilities, damages, costs and expenses (including reasonable attorneys\u2019 fees) arising out of or accruing from (a) your use of the SDK; (b) any application you develop on the SDK that infringes any copyright, trademark, trade secret, trade dress, patent or other intellectual property right of any person or defames any person or violates their rights of publicity or privacy; and/or \u00a9 any non-compliance by you with this License Agreement.",
            "title": "11 Indemnification"
        },
        {
            "location": "/sdk/sdk-license-agreement/#12-general",
            "text": "12.1    This License Agreement constitutes the whole legal agreement between you and us and governs your use of the SDK (excluding any services which we may provide to you under a separate written agreement), and completely replaces any prior agreements between you and us in relation to the SDK. \n12.2    You agree that if we do not exercise or enforce any legal right or remedy which is contained in the License Agreement (or which we have the benefit of under any applicable law), this will not be taken to be a formal waiver of our rights and that those rights or remedies will still be available to us. \n12.3    If any court of law, having the jurisdiction to decide on this matter, rules that any provision of this License Agreement is invalid, then that provision will be removed from this License Agreement without affecting the rest of this License Agreement. The remaining provisions of this License Agreement will continue to be valid and enforceable. \n12.4    You acknowledge and agree that each member of the group of companies of which we are the parent shall be third party beneficiaries to this License Agreement and that such other companies shall be entitled to directly enforce, and rely upon, any provision of this License Agreement that confers a benefit on (or rights in favor of) them. Other than this, no other person or company shall be third party beneficiaries to this License Agreement. \n12.5    The rights granted in this License Agreement may not be assigned or transferred by either you or us without the prior written approval of the other party. Neither you nor we shall be permitted to delegate their responsibilities or obligations under this License Agreement without the prior written approval of the other party. \n12.6    This License Agreement, and your relationship with us under this License Agreement, shall be governed by the laws of the Republic of Korea without regard to its conflict of laws provisions. You and we agree to submit to the exclusive jurisdiction of Seoul Central District Court in Seoul, South Korea to resolve any legal matter arising from this License Agreement. Notwithstanding this, you agree that we shall still be allowed to apply for injunctive remedies (or an equivalent type of urgent legal relief) in any jurisdiction.",
            "title": "12 General"
        },
        {
            "location": "/sdk/sdk-license-agreement/#sdk",
            "text": "\ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc740 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \uac1c\ubc1c \ud0a4\ud2b8 \uc0ac\uc6a9\uacfc \uad00\ub828\ud558\uc5ec \uadc0\ud558\uc640 [\uc8fc\uc2dd\ud68c\uc0ac \uc288\ud504\ub9ac\ub9c8]\uac04\uc5d0 \ubc95\uc801 \uad6c\uc18d\ub825\uc774 \uc788\ub294 \uacc4\uc57d\uc744 \ud615\uc131\ud569\ub2c8\ub2e4.",
            "title": "SDK \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d (\ud55c\uad6d\uc5b4)"
        },
        {
            "location": "/sdk/sdk-license-agreement/#1",
            "text": "1.1\u201c[\uc288\ud504\ub9ac\ub9c8]\u201d \ub610\ub294 \u201c\ub2f9\uc0ac\u201d\ub294 \ub300\ud55c\ubbfc\uad6d \ubc95\ub960\uc5d0 \ub530\ub77c \uc870\uc9c1\ub418\uace0 \uc6b4\uc601\ub418\uba70 [\uacbd\uae30\ub3c4 \uc131\ub0a8\uc2dc \ubd84\ub2f9\uad6c \uc815\uc790\uc77c\ub85c 248 \ud30c\ud06c\ubdf0\uc624\ud53c\uc2a4\ud0c0\uc6cc17F-5]\ub97c \ubcf8\uc810 \uc18c\uc7ac\uc9c0\ub85c \ub450\uace0\uc788\ub294 [\uc8fc\uc2dd\ud68c\uc0ac \uc288\ud504\ub9ac\ub9c8]\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4. \n1.2 \"SDK\"\ub294 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ud30c\uc77c, \ubb38\uc11c, \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ucf54\ub4dc, \uae30\ud0c0 \uad00\ub828 \ud56d\ubaa9 \ubc0f \uadf8 \uc218\uc815\ub41c \ubc84\uc804 \ub610\ub294 \uc5c5\uadf8\ub808\uc774\ub4dc\uac00 \ud3ec\ud568\ub41c [SFM SDKs] \uc18c\ud504\ud2b8\uc6e8\uc5b4 \uac1c\ubc1c \ud0a4\ud2b8\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4.",
            "title": "1 \uc815\uc758"
        },
        {
            "location": "/sdk/sdk-license-agreement/#2",
            "text": "2.1 SDK\ub97c \uc0ac\uc6a9\ud558\ub824\uba74 \uba3c\uc800 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud558\uc9c0 \uc54a\uc73c\uba74 SDK\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \n2.2 SDK\ub97c \uc124\uce58, \uc5f4\ub78c, \uc0ac\uc6a9\ud568\uc73c\ub85c\uc368 \uadc0\ud558\ub294 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud55c \uac83\uc73c\ub85c \uac04\uc8fc\ud569\ub2c8\ub2e4.  \n2.3 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758\ud568\uc73c\ub85c\uc368 \uadc0\ud558\ub294 \uadc0\ud558 \uc790\uc2e0 \ub610\ub294 \uadc0\ud558\uc758 \ubc95\uc778\uc744 \ubcf8 \uacc4\uc57d\uc5d0 \uad6c\uc18d\uc2dc\ud0ac \uc644\uc804\ud55c \ubc95\uc801 \uad8c\ud55c\uc774 \uc788\uc74c\uc744 \uc9c4\uc220\ud558\uace0 \ubcf4\uc99d\ud569\ub2c8\ub2e4.",
            "title": "2 \ubcf8 \uacc4\uc57d\uc5d0 \ub3d9\uc758"
        },
        {
            "location": "/sdk/sdk-license-agreement/#3",
            "text": "3.1 \ubcf8 \uacc4\uc57d\uc758 \uc870\uac74\uc5d0 \ub530\ub77c \ub2f9\uc0ac\ub294 \ub2f9\uc0ac \uc81c\ud488\uacfc \ud568\uaed8 \uc791\ub3d9\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc744 \uac1c\ubc1c\ud558\uae30 \uc704\ud574\uc11c\ub9cc SDK\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub294 \uc81c\ud55c\uc801\uc774\uace0 \ube44 \ub3c5\uc810\uc801\uc774\uba70 \uc591\ub3c4 \ubd88\uac00\ub2a5\ud55c \uc804 \uc138\uacc4\uc801 \ub77c\uc774\uc120\uc2a4\ub97c \uadc0\ud558\uc5d0\uac8c \ubd80\uc5ec\ud569\ub2c8\ub2e4. \n3.2 \uadc0\ud558\ub294 SDK\uc5d0 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 \uc9c0\uc2dd \uc7ac\uc0b0\uad8c\uc744 \ud3ec\ud568\ud558\uc5ec \ub2f9\uc0ac \ub610\ub294 \uc81c 3\uc790\uac00 SDK\uc5d0 \ub300\ud55c \ubaa8\ub4e0 \ubc95\uc801 \uad8c\ub9ac, \uc18c\uc720\uad8c \ubc0f \uc774\uad8c\uc744 \uc18c\uc720\ud55c\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \"\uc9c0\uc2dd \uc7ac\uc0b0\uad8c\"\uc740 \ud2b9\ud5c8\ubc95, \uc800\uc791\uad8c\ubc95, \uc601\uc5c5 \ube44\ubc00, \uc0c1\ud45c\ubc95 \ubc0f \uae30\ud0c0  \ubaa8\ub4e0 \uc7ac\uc0b0\uc801 \uad8c\ub9ac\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4. \ub2f9\uc0ac\ub294 \ubcf8 \uacc4\uc57d\uc774 \uadc0\ud558\uc5d0\uac8c \uba85\uc2dc\uc801\uc73c\ub85c \ubd80\uc5ec\ub418\uc9c0 \uc54a\uc740 \ubaa8\ub4e0 \uad8c\ub9ac\ub97c \ubcf4\uc720\ud569\ub2c8\ub2e4. \n3.3 \ubcf8 \uacc4\uc57d\uc774 \uba85\uc2dc\uc801\uc73c\ub85c \ud5c8\uc6a9\ud558\uc9c0 \uc54a\ub294 \ubaa9\uc801\uc73c\ub85c SDK\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uc801\uc6a9\uac00\ub2a5\ud55c \uc81c 3 \uc790 \ub77c\uc774\uc120\uc2a4\uc5d0\uc11c \uc694\uad6c\ud558\ub294 \uacbd\uc6b0\ub97c \uc81c\uc678\ud558\uace0, \uadc0\ud558\ub294 SDK \ub610\ub294 SDK\uc758 \uc77c\ubd80\ub97c \ubcf5\uc0ac (\ubc31\uc5c5 \ubaa9\uc801 \uc81c\uc678), \uc218\uc815, \uac1c\uc870, \uc7ac\ubc30\ud3ec, \ub514 \ucef4\ud30c\uc77c, \ub9ac\ubc84\uc2a4 \uc5d4\uc9c0\ub2c8\uc5b4\ub9c1, \ubd84\ud574 \ub610\ub294 \ud30c\uc0dd\ubb3c \uc0dd\uc131\uc744 \ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \n3.4 \uc624\ud508 \uc18c\uc2a4 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ub77c\uc774\uc120\uc2a4\uc5d0 \ub530\ub77c \ub77c\uc774\uc120\uc2a4\uac00 \ubd80\uc5ec\ub41c SDK \uad6c\uc131 \uc694\uc18c\uc758 \uc0ac\uc6a9, \ubcf5\uc81c \ubc0f \ubc30\ud3ec\ub294 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc774 \uc544\ub2cc \ud574\ub2f9 \uc624\ud508 \uc18c\uc2a4 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ub77c\uc774\uc120\uc2a4\uc758 \uc801\uc6a9\uc744 \ubc1b\uc2b5\ub2c8\ub2e4. \n3.5 \uadc0\ud558\ub294 SDK\uc758 \ud615\uc2dd\uacfc \ud2b9\uc131\uc774 \uc0ac\uc804 \ud1b5\uc9c0\uc5c6\uc774 \ubcc0\uacbd\ub420 \uc218 \uc788\uc73c\uba70 SDK\uc758 \ud5a5\ud6c4 \ubc84\uc804\uc774 \uc774\uc804 \ubc84\uc804\uc758 SDK\uc5d0\uc11c \uac1c\ubc1c\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uacfc \ud638\ud658\ub418\uc9c0 \uc54a\uc744 \uc218 \uc788\uc74c\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uadc0\ud558\ub294 \uc77c\ubc18\uc801\uc73c\ub85c \uadc0\ud558\uc5d0\uac8c \uc0ac\uc804 \ud1b5\uc9c0\uc5c6\uc774 \ub2f9\uc0ac\uc758 \ub2e8\ub3c5 \uc7ac\ub7c9\uc5d0 \ub530\ub77c \uadc0\ud558 \ub610\ub294 \uc0ac\uc6a9\uc790\uc5d0\uac8c SDK (\ub610\ub294 SDK \ub0b4\uc758 \ubaa8\ub4e0 \uae30\ub2a5) \uc81c\uacf5\uc744 (\uc601\uad6c\uc801\uc73c\ub85c \ub610\ub294 \uc77c\uc2dc\uc801\uc73c\ub85c) \uc911\ub2e8\ud560 \uc218 \uc788\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \n3.6 \ubcf8 \ub77c\uc774\uc13c\uc2a4 \uacc4\uc57d\uc758 \uc5b4\ub5a0\ud55c \ub0b4\uc6a9\ub3c4 \uadc0\ud558\uc5d0\uac8c \ub2f9\uc0ac\uc758 \uc0c1\ud638, \uc0c1\ud45c, \uc11c\ube44\uc2a4 \ub9c8\ud06c, \ub85c\uace0, \ub3c4\uba54\uc778 \uc774\ub984 \ub610\ub294 \uae30\ud0c0 \uace0\uc720\ud55c \ube0c\ub79c\ub4dc \ud2b9\uc131\uc744 \uc0ac\uc6a9\ud560 \uad8c\ub9ac\ub97c \ubd80\uc5ec\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \n3.7 \uadc0\ud558\ub294 SDK\uc5d0 \ucca8\ubd80\ub418\uac70\ub098 SDK \ub0b4\uc5d0 \ud3ec\ud568\ub420 \uc218 \uc788\ub294 \ubaa8\ub4e0 \uc18c\uc720\uad8c \uace0\uc9c0 (\uc800\uc791\uad8c \ubc0f \uc0c1\ud45c \uace0\uc9c0 \ud3ec\ud568)\ub97c \uc81c\uac70\ud558\uac70\ub098 \uac00\ub9ac\uac70\ub098 \ubcc0\uacbd\ud558\uc9c0 \uc54a\uc744 \uac83\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4.",
            "title": "3 \ub77c\uc774\uc120\uc2a4 \ubd80\uc5ec; \uad8c\ub9ac \uc720\ubcf4"
        },
        {
            "location": "/sdk/sdk-license-agreement/#4",
            "text": "4.1 \uadc0\ud558\ub294 \ubcf8 \uacc4\uc57d\uc5d0\uc11c \ud5c8\uc6a9\ud558\ub294 \ubaa9\uc801\uc73c\ub85c\ub9cc SDK\ub97c \uc0ac\uc6a9\ud558\uace0 \uad00\ub828 \ubc95\ub960, \uaddc\uc815 \ub610\ub294 \uad00\ub828 \uad00\ud560\uad8c\uc5d0\uc11c \uc77c\ubc18\uc801\uc73c\ub85c \ud5c8\uc6a9\ub418\ub294 \uad00\ud589 \ub610\ub294 \uc9c0\uce68\uc5d0 \ub530\ub974\uba70 \ubd88\ubc95\uc801\uc774\uac70\ub098 \ube44 \uc724\ub9ac\uc801\uc778 \ubc29\uc2dd\uc73c\ub85c SDK\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc744 \uac83\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \n4.2 \uadc0\ud558\ub294 SDK\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc77c\ubc18 \uc0ac\uc6a9\uc790\ub97c \uc704\ud55c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uac1c\ubc1c\ud558\ub294 \uacbd\uc6b0 \ud574\ub2f9 \uc0ac\uc6a9\uc790\uc758 \uac1c\uc778 \uc815\ubcf4 \ubc0f \ubc95\uc801 \uad8c\ub9ac\ub97c \ubcf4\ud638\ud560 \uac83\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uc0ac\uc6a9\uc790\uac00 \uac1c\uc778 \ub370\uc774\ud130\ub97c \uc81c\uacf5\ud558\ub294 \uacbd\uc6b0 \ud574\ub2f9 \ub370\uc774\ud130 \ubcf4\ud638\ubc95 \ub610\ub294 \uad00\ub828 \uc815\ucc45\uc5d0\uc11c \uc694\uad6c\ud558\ub294\ub300\ub85c \ud574\ub2f9 \ub370\uc774\ud130\ub97c \ucc98\ub9ac\ud574\uc57c\ud569\ub2c8\ub2e4. \n4.3 \uadc0\ud558\ub294 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d, \uc801\uc6a9 \uac00\ub2a5\ud55c \uc81c 3 \uc790 \uacc4\uc57d \uc870\uac74 \ub610\ub294 \uad00\ub828 \ubc95\ub960 \ub610\ub294 \uaddc\uc815\uc5d0 \ub530\ub978 \uc758\ubb34 \uc704\ubc18 \ubc0f \uacb0\uacfc (\ub2f9\uc0ac \ub610\ub294 \uc81c 3\uc790\uac00 \uc785\uc740 \uc190\uc2e4 \ub610\ub294 \uc190\ud574 \ud3ec\ud568)\uc5d0 \ub300\ud574 \uc804\uc801\uc73c\ub85c \ucc45\uc784\uc744 \uc9c4\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.",
            "title": "4 \uadc0\ud558\uc758 \ucc45\uc784"
        },
        {
            "location": "/sdk/sdk-license-agreement/#5",
            "text": "5.1 SDK\ub97c \uc9c0\uc18d\uc801\uc73c\ub85c \ud601\uc2e0\ud558\uace0 \uac1c\uc120\ud558\uae30 \uc704\ud574, \ub2f9\uc0ac\ub294 \uace0\uc720 \uc2dd\ubcc4\uc790, \uad00\ub828 IP \uc8fc\uc18c, \uc18c\ud504\ud2b8\uc6e8\uc5b4 \ubc84\uc804 \ubc88\ud638, SDK\uc5d0 \uc0ac\uc6a9\ub41c \ub3c4\uad6c \ubc0f / \ub610\ub294 \uc11c\ube44\uc2a4\uc640 \uc0ac\uc6a9\ubc29\uc2dd\uc5d0 \uad00\ud55c \uc815\ubcf4\ub97c \ud3ec\ud568\ud558\uc5ec \uc18c\ud504\ud2b8\uc6e8\uc5b4\uc5d0\uc11c \ud2b9\uc815 \uc0ac\uc6a9 \ud1b5\uacc4\ub97c \uc218\uc9d1\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.  \n5.2 \uc218\uc9d1\ub41c \ub370\uc774\ud130\ub294 SDK\ub97c \uac1c\uc120\ud558\uae30 \uc704\ud574 \ucd1d\uccb4\uc801\uc73c\ub85c \uac80\ud1a0\ub418\uba70 \ub2f9\uc0ac\uc758 \uac1c\uc778 \uc815\ubcf4 \ubcf4\ud638 \uc815\ucc45\uc5d0 \ub530\ub77c \uc720\uc9c0\ub429\ub2c8\ub2e4. \n5.3 \uc775\uba85\ud654\ud55c \ucde8\ud569 \ub370\uc774\ud130\ub294 SDK \uac1c\uc120\uc744 \uc704\ud574 \ud30c\ud2b8\ub108\uc640 \uacf5\uc720\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4.",
            "title": "5 \uac1c\uc778 \uc815\ubcf4 \ubcf4\ud638"
        },
        {
            "location": "/sdk/sdk-license-agreement/#6",
            "text": "6.1 SDK\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc81c 3\uc790\uac00 \uac1c\ubc1c\ud55c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uc2e4\ud589\ud558\uac70\ub098 \uc81c 3\uc790\uac00 \uc81c\uacf5\ud55c \ub370\uc774\ud130, \ucf58\ud150\uce20 \ub610\ub294 \ub9ac\uc18c\uc2a4 ( \"\uc81c 3 \uc790 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\")\uc758 \uc0ac\uc6a9 \ub610\ub294 \uc561\uc138\uc2a4\uc758 \uacb0\uacfc\ub85c \uadc0\ud558\uc5d0\uac8c \ubc1c\uc0dd\ud560 \uc218 \uc788\ub294 \uc190\uc2e4 \ub610\ub294 \uc190\ud574\uc5d0 \ub300\ud574 \ub2f9\uc0ac\uac00 \ucc45\uc784\uc9c0\uc9c0 \uc54a\ub294\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.  \n62 \uc81c 3 \uc790 \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc740 \uad00\ub828 \uc81c 3\uc790\uac00 \uc18c\uc720\ud55c \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc5d0 \uc758\ud574 \ubcf4\ud638 \ub420 \uc218 \uc788\uc74c\uc744 \uc778\uc2dd\ud574\uc57c \ud569\ub2c8\ub2e4. \uad00\ub828 \ub2f9\uc0ac\uc790\uac00 \ud2b9\ubcc4\ud788 \ud5c8\uc6a9\ud558\uc9c0 \uc54a\ub294 \ud55c \uc774\ub7ec\ud55c \ub370\uc774\ud130, \ucf58\ud150\uce20 \ub610\ub294 \ub9ac\uc18c\uc2a4 (\uc804\uccb4 \ub610\ub294 \uc77c\ubd80)\ub97c \uae30\ubc18\uc73c\ub85c \ud55c \ud30c\uc0dd\ubb3c\uc744 \uc218\uc815, \ub300\uc5ec, \ud310\ub9e4, \ubc30\ud3ec \ub610\ub294 \uc0dd\uc131\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \n6.3 \uadc0\ud558\ub294 \uadf8\ub7ec\ud55c \uc81c 3 \uc790 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc758 \uc0ac\uc6a9\uc774 \uadc0\ud558\uc640 \uad00\ub828 \uc81c 3 \uc790\uac04 \uc57d\uc815\ub41c \ubcc4\ub3c4\uc758 \uc870\uac74\uc744 \ub530\ub97c \uc218 \uc788\uc74c\uc744 \uc778\uc815\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0 \ubcf8 \uacc4\uc57d\uc740 \uc81c 3 \uc790\uc640\uc758 \ubc95\uc801 \uad00\uacc4\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.",
            "title": "6 \ud0c0\uc0ac \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8"
        },
        {
            "location": "/sdk/sdk-license-agreement/#7-api",
            "text": "7.1 \uadc0\ud558\uac00 \ub2f9\uc0ac\uc5d0\uc11c \ub370\uc774\ud130\ub97c \uac80\uc0c9\ud558\uae30 \uc704\ud574 API\ub97c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 \uadc0\ud558\ub294 \ub2f9\uc0ac \ub610\ub294 \ub370\uc774\ud130\ub97c \uc81c\uacf5\ud558\ub294 \ub2f9\uc0ac\uc790 (\ub610\ub294 \uc774\ub4e4\uc744 \ub300\uc2e0\ud558\ub294 \ub2e4\ub978 \uac1c\uc778 \ub610\ub294 \ubc95\uc778)\uac00 \uc18c\uc720\ud55c \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc5d0 \uc758\ud574 \ub370\uc774\ud130\uac00 \ubcf4\ud638\ub420 \uc218 \uc788\uc74c\uc744 \uc778\uc815\ud569\ub2c8\ub2e4. \uc774\ub7ec\ud55c API\ub97c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 \ubcc4\ub3c4\uc758 \uc57d\uad00\uc774 \uc801\uc6a9\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uad00\ub828 \uc57d\uad00\uc5d0\uc11c \ud5c8\uc6a9\ud558\uc9c0 \uc54a\ub294 \ud55c \uc774 \ub370\uc774\ud130 (\uc804\uccb4 \ub610\ub294 \uc77c\ubd80)\ub97c \uae30\ubc18\uc73c\ub85c \ud55c \ud30c\uc0dd\ubb3c\uc744 \uc218\uc815, \ub300\uc5ec, \ud310\ub9e4, \ubc30\ud3ec \ub610\ub294 \uc0dd\uc131\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.",
            "title": "7 API \uc0ac\uc6a9"
        },
        {
            "location": "/sdk/sdk-license-agreement/#8",
            "text": "8.1 \ubcf8 \uacc4\uc57d\uc740 \ud574\uc9c0\ub420 \ub54c\uae4c\uc9c0 \uc720\ud6a8\ud569\ub2c8\ub2e4. \n8.2 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc744 \ud574\uc9c0\ud558\ub824\uba74 SDK\uc758 \uc0ac\uc6a9\uc744 \uc911\ub2e8\ud558\uba74 \ub429\ub2c8\ub2e4. \n8.3 \ub2f9\uc0ac\ub294 \uadc0\ud558\uac00 \ubcf8 \ubb38\uc11c\uc758 \uc870\uac74\uc744 \uc900\uc218\ud558\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \ub610\ub294 \ub2f9\uc0ac\uc758 \ub2e8\ub3c5 \uc7ac\ub7c9\uc5d0 \ub530\ub77c \uc5b8\uc81c\ub4e0\uc9c0 \ubcf8 \ub77c\uc774\uc120\uc2a4 \uacc4\uc57d\uc744 \ud574\uc9c0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \n8.4 \ubcf8 \uacc4\uc57d \ud574\uc9c0\uc2dc \uadc0\ud558\ub294 SDK\uc758 \ubaa8\ub4e0 \ud56d\ubaa9\uc744 \uc81c\uac70\ud558\uace0 \uc0ac\uc6a9\uc744 \uc911\ub2e8\ud558\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.",
            "title": "8 \uae30\uac04; \ud574\uc9c0"
        },
        {
            "location": "/sdk/sdk-license-agreement/#9",
            "text": "9.1 \uadc0\ud558\ub294 SDK \uc0ac\uc6a9\uc774 \uc804\uc801\uc73c\ub85c \uadc0\ud558\uc758 \ucc45\uc784\uc774\uba70 SDK\uac00 \ub2f9\uc0ac\uc758 \uc5b4\ub5a0\ud55c \ubcf4\uc99d \uc5c6\uc774 \"\uc788\ub294 \uadf8\ub300\ub85c\" \uc81c\uacf5\ub41c\ub2e4\ub294 \uac83\uc744 \uba85\uc2dc \uc801\uc73c\ub85c \uc774\ud574\ud558\uace0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \n9.2 SDK \ubc0f SDK \uc0ac\uc6a9\uc744 \ud1b5\ud574 \ub2e4\uc6b4\ub85c\ub4dc\ud558\uac70\ub098 \ub2e4\ub978 \ubc29\uc2dd\uc73c\ub85c \ud68d\ub4dd\ud55c \ubaa8\ub4e0 \uc790\ub8cc\uc758 \uc0ac\uc6a9\uc740 \uadc0\ud558\uc758 \uc7ac\ub7c9 \ubc0f \ub9ac\uc2a4\ud06c\uc774\uba70 \uadc0\ud558\ub294 \uadc0\ud558\uc758 \ucef4\ud4e8\ud130 \uc2dc\uc2a4\ud15c \ub610\ub294 \uae30\ud0c0 \uc7a5\uce58\uc758 \uc190\uc0c1 \ub610\ub294 \uc774\ub7ec\ud55c \uc0ac\uc6a9\uc73c\ub85c \uc778\ud55c \ub370\uc774\ud130 \uc190\uc2e4\uc5d0 \ub300\ud574 \uc804\uc801\uc73c\ub85c \ucc45\uc784\uc744 \uc9d1\ub2c8\ub2e4.  \n9.3 \ub610\ud55c \ub2f9\uc0ac\ub294 \uc0c1\ud488\uc131, \ud2b9\uc815 \ubaa9\uc801\uc5d0\uc758 \uc801\ud569\uc131 \ubc0f \ube44 \uce68\ud574\uc5d0 \ub300\ud55c \ubb35\uc2dc\uc801 \ubcf4\uc99d\uc744 \ud3ec\ud568\ud55c \ubaa8\ub4e0 \ubcf4\uc99d\uc744 \uba85\uc2dc\uc801\uc73c\ub85c \ubd80\uc778\ud569\ub2c8\ub2e4.",
            "title": "9 \ubcf4\uc99d\uc758 \ubd80\uc778"
        },
        {
            "location": "/sdk/sdk-license-agreement/#10",
            "text": "1.1 \uc5b4\ub5a0\ud55c \uacbd\uc6b0\uc5d0\ub3c4 \ub2f9\uc0ac, \ub2f9\uc0ac\uc758 \uc790\ud68c\uc0ac \ubc0f \uacc4\uc5f4\uc0ac \ubc0f \ub77c\uc774\uc120\uc2a4 \uc81c\uacf5\uc790\ub294 \ubaa8\ub4e0 \uc9c1\uc811\uc801, \uac04\uc811\uc801, \ubd80\uc218\uc801, \ud2b9\uc218, \uacb0\uacfc\uc801 \ub610\ub294 \uc9d5\ubc8c\uc801 \uc190\ud574(\ub370\uc774\ud130 \uc190\uc2e4, \ube44\uc988\ub2c8\uc2a4 \uc774\uc775 \uc190\uc2e4 \ub4f1 \ud3ec\ud568)\uc5d0 \ub300\ud558\uc5ec \ub2f9\uc0ac \ub610\ub294 \ub2f9\uc0ac\uc758 \ub300\ub9ac\uc778\uc774 \uadf8\ub7ec\ud55c \uc190\ud574\uc758 \uac00\ub2a5\uc131\uc5d0 \ub300\ud55c \uc778\uc9c0 \uc5ec\ubd80\uc640 \uad00\uacc4\uc5c6\uc774 \ubaa8\ub4e0 \uc190\ud574\uc5d0 \ub300\ud558\uc5ec \uadc0\ud558\uc5d0\uac8c \ucc45\uc784\uc9c0\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.",
            "title": "10 \ucc45\uc784\uc758 \uc81c\ud55c"
        },
        {
            "location": "/sdk/sdk-license-agreement/#11",
            "text": "11.1 \ubc95\ub960\uc774 \ud5c8\uc6a9\ud558\ub294 \ubc94\uc704 \uc548\uc5d0\uc11c \uadc0\ud558\ub294 \ub2f9\uc0ac, \ub2f9\uc0ac\uc758 \uacc4\uc5f4\uc0ac \ubc0f \uc774\uc0ac, \uc784\uc6d0, \uc9c1\uc6d0 \ubc0f \ub300\ub9ac\uc778\uc744 (a) \uadc0\ud558\uc758 SDK \uc0ac\uc6a9; (b) \uc800\uc791\uad8c, \uc0c1\ud45c, \uc601\uc5c5 \ube44\ubc00, \ud2b9\ud5c8 \ub610\ub294 \uae30\ud0c0 \uc9c0\uc2dd\uc7ac\uc0b0\uad8c\uc744 \uce68\ud574\ud558\uac70\ub098 \ud0c0\uc778\uc758 \uba85\uc608\uc640 \uac1c\uc778 \uc815\ubcf4\uc5d0 \ub300\ud55c \uad8c\ub9ac \uce68\ud574; \ubc0f / \ub610\ub294 \u00a9 \ubcf8 \uacc4\uc57d \ubd88\uc774\ud589\uc73c\ub85c \uc778\ud574 \ubc1c\uc0dd\ud55c \ubaa8\ub4e0 \uc18c\uc1a1, \uccad\uad6c, \uc190\uc2e4, \uc190\ud574, \ucc45\uc784 \ubc0f \ube44\uc6a9(\ubcc0\ud638\uc0ac \ube44\uc6a9 \ud3ec\ud568)\uc73c\ub85c\ubd80\ud130 \ubc29\uc5b4\ud558\uace0 \uba74\ucc45\ud574\uc57c \ud569\ub2c8\ub2e4.",
            "title": "11 \uba74\ucc45"
        },
        {
            "location": "/sdk/sdk-license-agreement/#12",
            "text": "12.1 \ubcf8 \uacc4\uc57d\uc740 \uadc0\ud558\uc640 \ub2f9\uc0ac \uac04\uc758 \uc644\uc804\ud55c \ubc95\uc801 \uacc4\uc57d\uc774\uba70 \uadc0\ud558\uc758 SDK\uc0ac\uc6a9\uc744 \uaddc\uc728\ud558\uace0 (\ubcc4\ub3c4\uc758 \uc11c\uba74 \uacc4\uc57d\uc5d0 \ub530\ub77c \ub2f9\uc0ac\uac00 \uadc0\ud558\uc5d0\uac8c \uc81c\uacf5\ud560 \uc218 \uc788\ub294 \uc11c\ube44\uc2a4 \uc81c\uc678) SDK\uc640 \uad00\ub828\ud558\uc5ec \uadc0\ud558\uc640 \ub2f9\uc0ac \uac04 \uccb4\uacb0\ub41c \ubaa8\ub4e0 \uc774\uc804 \uacc4\uc57d\uc744 \uc644\uc804\ud788 \ub300\uccb4\ud569\ub2c8\ub2e4.  \n12.2 \uadc0\ud558\ub294 \ub2f9\uc0ac\uac00 \ubcf8 \uacc4\uc57d\uc5d0 \ud3ec\ud568\ub41c (\ub610\ub294 \ud574\ub2f9 \ubc95\ub960\uc5d0 \ub530\ub77c \ub2f9\uc0ac\uac00 \ubc1b\ub294) \ubc95\uc801 \uad8c\ub9ac \ub610\ub294 \uad6c\uc81c\ucc45\uc744 \ud589\uc0ac\ud558\uac70\ub098 \uc2dc\ud589\ud558\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc774\ub294 \ub2f9\uc0ac\uc758 \uad8c\ub9ac\ub97c \uacf5\uc2dd\uc801\uc73c\ub85c \ud3ec\uae30\ud558\ub294 \uac83\uc73c\ub85c \uac04\uc8fc\ub418\uc9c0 \uc54a\ub294\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uadf8\ub7ec\ud55c \uad8c\ub9ac\ub098 \uad6c\uc81c\ucc45\uc740 \uc5ec\uc804\ud788 \uc720\ud6a8\ud569\ub2c8\ub2e4. \n12.3 \uad00\ud560\uad8c\uc744 \uac00\uc9c4 \ubc95\uc6d0\uc774 \ubcf8 \uacc4\uc57d\uc758 \uc870\ud56d\uc774 \uc720\ud6a8\ud558\uc9c0 \uc54a\ub2e4\uace0 \ud310\uacb0\ud558\ub294 \uacbd\uc6b0, \ud574\ub2f9 \uc870\ud56d\uc740 \ubcf8 \uacc4\uc57d\uc758 \uc774\uc678 \uc870\ud56d\uc5d0 \uc601\ud5a5\uc744 \uc8fc\uc9c0 \uc54a\uace0 \ubcf8 \uacc4\uc57d\uc5d0\uc11c \uc0ad\uc81c\ub429\ub2c8\ub2e4.  \ubcf8 \uacc4\uc57d\uc758 \uc774\uc678 \uc870\ud56d\uc740 \uacc4\uc18d \uc720\ud6a8\ud558\uace0 \uc2dc\ud589 \uac00\ub2a5\ud569\ub2c8\ub2e4. \n12.4 \uadc0\ud558\ub294 \ub2f9\uc0ac\uc758 \ubaa8\ud68c\uc0ac \uac01 \uad6c\uc131\uc6d0\uc774 \ubcf8 \uacc4\uc57d\uc758 \uc81c 3 \uc790 \uc218\ud61c\uc790\uc774\uba70 \uadf8\ub7ec\ud55c \ud68c\uc0ac\uac00 \ubcf8 \uacc4\uc57d\uc758 \uc870\ud56d\uc744 \uc9c1\uc811 \uc2dc\ud589\ud560 \uc790\uaca9\uc774 \uc788\uc74c\uc744 \uc778\uc815\ud558\uace0 \uc774\uc5d0 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uc774 \uc678\uc5d0 \ub2e4\ub978 \uac1c\uc778\uc774\ub098 \ubc95\uc778\uc740 \ubcf8 \uacc4\uc57d\uc758 \uc81c 3 \uc790 \uc218\ud61c\uc790\uac00 \ub420 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \n12.5 \ubcf8 \uacc4\uc57d\uc5d0\uc11c \ubd80\uc5ec\ud55c \uad8c\ub9ac\ub294 \uc0c1\ub300\ubc29\uc758 \uc0ac\uc804 \uc11c\uba74 \uc2b9\uc778\uc5c6\uc774 \uadc0\ud558 \ub610\ub294 \ub2f9\uc0ac\uc5d0 \uc758\ud574 \uc591\ub3c4\ub420 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \uadc0\ud558\uc640 \ub2f9\uc0ac\ub294 \uc0c1\ub300\ubc29\uc758 \uc0ac\uc804 \uc11c\uba74 \uc2b9\uc778\uc5c6\uc774 \ubcf8 \uacc4\uc57d\uc5d0 \ub530\ub978 \ucc45\uc784\uc774\ub098 \uc758\ubb34\ub97c \uc704\uc784\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4. \n12.6 \ubcf8 \uacc4\uc57d\uc740 \ub300\ud55c\ubbfc\uad6d \ubc95\ub960\uc758 \uc801\uc6a9\uc744 \ubc1b\uc2b5\ub2c8\ub2e4. \uadc0\ud558\uc640 \ub2f9\uc0ac\ub294 \ubcf8 \uacc4\uc57d\uc73c\ub85c \uc778\ud574 \ubc1c\uc0dd\ud558\ub294 \ubaa8\ub4e0 \ubc95\uc801 \ubb38\uc81c\ub97c \ud574\uacb0\ud558\uae30 \uc704\ud574 \ub300\ud55c\ubbfc\uad6d \uc11c\uc6b8\uc758 \uc11c\uc6b8 \uc911\uc559 \uc9c0\ubc29 \ubc95\uc6d0\uc758 \uc804\uc18d \uad00\ud560\uc5d0 \ub530\ub974\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4. \uadf8\ub7fc\uc5d0\ub3c4 \ubd88\uad6c\ud558\uace0 \uadc0\ud558\ub294 \ub2f9\uc0ac\uac00 \ubaa8\ub4e0 \uad00\ud560\uad8c\uc5d0\uc11c \uac15\uc81c \uad6c\uc81c \uc870\uce58 (\ub610\ub294 \uc774\uc5d0 \uc0c1\uc751\ud558\ub294 \uc720\ud615\uc758 \uae34\uae09 \ubc95\uc801 \uad6c\uc81c)\ub97c \uc2e0\uccad\ud560 \uc218 \uc788\ub2e4\ub294 \ub370 \ub3d9\uc758\ud569\ub2c8\ub2e4.",
            "title": "12 \uc77c\ubc18\uc870\uac74"
        },
        {
            "location": "/tutorials/pysfm/tutorial/",
            "text": "pysfm\n\u00b6\n\n\nIt is assumed as below:  \n\n\n\n\nThe serial port of the SFM is connected with \"COM8\". (Tested on Windows)\n\n\nAll settings of the SFM are set as factory default.\n\n\n\n\nHow to get serial port information using pysfm?\n\u00b6\n\n\n>>> import pysfm\n\n\n>>> pysfm.get_port_list()\n\n\n[u'COM1', u'COM8']\n\n\n>>>\n\n\n\n\nHow to connect the module?\n\u00b6\n\n\n>>> import pysfm\n\n\n>>> module = pysfm.Module('COM8')\n\n\n>>> module.connect()\n\n\n[SEND] : 40 04 00 00 00 00 00 00 00 00 00 44 0A   # Sent packet\n\n\n[RECV] : 40 04 30 00 00 00 00 00 00 00 61 D5 0A   # Received packet\n\n\nTrue  # Return value of module.connect()\n\n\n>>>\n\n\n\nAs shown in the above, packet trace information is printed by default. If you want to disable this feature, you should call a function deactivate_packet_trace() before connect. (In the opposite case, you should use activate_packet_trace() to enable.)\n\n\n>>> import pysfm\n\n\n>>> module = pysfm.Module('COM8')\n\n\n>>> module.deactivate_packet_trace()\n\n\n>>> module.connect()\n\n\nTrue\n\n\n>>>",
            "title": "pysfm"
        },
        {
            "location": "/tutorials/pysfm/tutorial/#pysfm",
            "text": "It is assumed as below:     The serial port of the SFM is connected with \"COM8\". (Tested on Windows)  All settings of the SFM are set as factory default.",
            "title": "pysfm"
        },
        {
            "location": "/tutorials/pysfm/tutorial/#how-to-get-serial-port-information-using-pysfm",
            "text": ">>> import pysfm  >>> pysfm.get_port_list()  [u'COM1', u'COM8']  >>>",
            "title": "How to get serial port information using pysfm?"
        },
        {
            "location": "/tutorials/pysfm/tutorial/#how-to-connect-the-module",
            "text": ">>> import pysfm  >>> module = pysfm.Module('COM8')  >>> module.connect()  [SEND] : 40 04 00 00 00 00 00 00 00 00 00 44 0A   # Sent packet  [RECV] : 40 04 30 00 00 00 00 00 00 00 61 D5 0A   # Received packet  True  # Return value of module.connect()  >>>  \nAs shown in the above, packet trace information is printed by default. If you want to disable this feature, you should call a function deactivate_packet_trace() before connect. (In the opposite case, you should use activate_packet_trace() to enable.)  >>> import pysfm  >>> module = pysfm.Module('COM8')  >>> module.deactivate_packet_trace()  >>> module.connect()  True  >>>",
            "title": "How to connect the module?"
        }
    ]
}